Title,URL,Companies,Topic,Difficulty,Problem,Solution
Gas Station,https://www.interviewbit.com/problems/gas-station/,"Google, Amazon, Flipkart, Microsoft",Greedy Algorithm,Medium,"Given two integer arrays A and B of size N. There are N gas stations along a circular route, where the amount of gas at station i is A[i].

You have a car with an unlimited gas tank and it costs B[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.

Return the minimum starting gas station's index if you can travel around the circuit once, otherwise return -1.

You can only travel in one direction. i to i+1, i+2, ... n-1, 0, 1, 2.. Completing the circuit means starting at i and ending up at i again.

Problem Constraints
1 <= |A| <= 5 * 10^5
|A| == |B|
0 <= Ai <= 5 * 10^3
0 <= Bi <= 5 * 10^3

Input Format
The first argument given is the integer array A. The second argument given is the integer array B.

Output Format
Return the minimum starting gas station's index if you can travel around the circuit once, otherwise return -1.

Example Input
A = [1, 2]
B = [2, 1]

Example Output
1

Example Explanation
If you start from index 0, you can fill in A[0] = 1 amount of gas.
Now your tank has 1 unit of gas. But you need B[0] = 2 gas to travel to station 1.

If you start from index 1, you can fill in A[1] = 2 amount of gas.
Now your tank has 2 units of gas. You need B[1] = 1 gas to get to station 0.
So, you travel to station 0 and still have 1 unit of gas left over.
You fill in A[0] = 1 unit of additional gas, making your current gas = 2. It costs you B[0] = 2 to get to station 1, which you do and complete the circuit.","int Solution::canCompleteCircuit(const vector<int> &A, const vector<int> &B) {
    long sumGas = 0;
    long sumCost = 0;
    int start = 0;
    int tank = 0;
    assert(A.size() >= 1 && A.size() <= 5e5);
    assert(A.size() == B.size());
    for (int i = 0; i < A.size(); i++) {
        assert(A[i] >= 0 && A[i] <= 5e3);
        assert(B[i] >= 0 && B[i] <= 5e3);
        sumGas += A[i];
        sumCost += B[i];
        tank += A[i] - B[i];
        if (tank < 0) {
            start = i + 1;
            tank = 0;
        }
    }
    if (sumGas < sumCost) {
        return -1;
    } else {
        return start;
    }
}"
Majority Element,https://www.interviewbit.com/problems/majority-element/,"Microsoft, Google, Amazon, Yahoo",Greedy Algorithm,Easy,"Given an array of size N, find the majority element. The majority element is the element that appears more than floor(N/2) times.
You may assume that the array is non-empty and the majority element always exist in the array.

Problem Constraints
1 <= |A| <= 10^6
1 <= Ai <= 10^9

Input Format
The first argument is an integer array A.

Output Format
Return the majority element.

Example Input
A = [2, 1, 2]

Example Output
2

Example Explanation
2 occurs 2 times which is greater than 3/2.","int Solution::majorityElement(const vector<int> &A) {
    int majorityIndex = 0;
    for (int count = 1, i = 1; i < A.size(); i++) {

        A[majorityIndex] == A[i] ? count++ : count--;

        if (count == 0) {
            majorityIndex = i;
            count = 1;
        }
    }

    return A[majorityIndex];
}"
Distribute Candy,https://www.interviewbit.com/problems/distribute-candy/,"Microsoft, Flipkart, Amazon",Greedy Algorithm,Medium,"N children are standing in a line. Each child is assigned a rating value.

You are giving candies to these children subjected to the following requirements:

Each child must have at least one candy.
Children with a higher rating get more candies than their neighbors.
What is the minimum number of candies you must give?

Problem Constraints
1 <= N <= 10^5
-10^9 <= A[i] <= 10^9

Input Format
The first and only argument is an integer array A representing the rating of children.

Output Format
Return an integer representing the minimum candies to be given.

Example Input
Input 1:
 A = [1, 2]
Input 2:
 A = [1, 5, 2, 1]

Example Output
Output 1:
 3
Output 2:
 7

Example Explanation
Explanation 1:
 The candidate with 1 rating gets 1 candy and candidate with rating 2 cannot get 1 candy as 1 is its neighbor. 
 So rating 2 candidate gets 2 candies. In total, 2 + 1 = 3 candies need to be given out.

Explanation 2:
 Candies given = [1, 3, 2, 1]
","int Solution::candy(vector<int> &A) {
    int n=A.size();
    assert(n>=1);
    int dp[n];
    for(int i=0;i<n;i++)
        dp[i]=1;
    for(int i=1;i<n;i++)
    {
        if(A[i]>A[i-1])
            dp[i]=dp[i-1]+1;
    }
    for(int i=n-2;i>=0;i--)
    {
        if(A[i]>A[i+1] && dp[i]<=dp[i+1]+1)
        {
            dp[i]=dp[i+1] + 1;
        }
    }
    int ans=0;
    for(int i=0;i<n;i++)
        ans+=dp[i];
    return ans;
}"
Longest Increasing Subsequence,https://www.interviewbit.com/problems/longest-increasing-subsequence/,"Facebook, Microsoft, Amazon, Yahoo",Dynamic Programming,medium,"Find the longest increasing subsequence of a given array of integers, A.

In other words, find a subsequence of array in which the subsequence's elements are in strictly increasing order, and in which the subsequence is as long as possible.

In this case, return the length of the longest increasing subsequence.

Problem Constraints
1 <= length(A) <= 2500
0 <= A[i] <= 2500

Input Format
The first and the only argument is an integer array A.

Output Format
Return an integer representing the length of the longest increasing subsequence.

Example Input
Input 1:

A = [1, 2, 1, 5]
Input 2:

A = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]
 
Example Output
Output 1:

3
Output 2:

6
 
Example Explanation
Explanation 1:

The longest increasing subsequence: [1, 2, 5]
Explanation 2:

The possible longest increasing subsequences: [0, 2, 6, 9, 13, 15] or [0, 4, 6, 9, 11, 15] or [0, 4, 6, 9, 13, 15]"," int Solution::lis(const vector<int> &A) {
int i, j, max = 0;
int n = A.size();
assert(n >= 1 && n <= 1000);
for(auto &x : A) assert(x >= 0 && x <= 2500);
vector<int> lis(n,1);

/* Compute optimized LIS values in bottom up manner */
for ( i = 1; i < n; i++ )
for ( j = 0; j < i; j++ )
if ( A[i] > A[j] && lis[i] < lis[j] + 1)
lis[i] = lis[j] + 1;

/* Pick maximum of all LIS values */
for ( i = 0; i < n; i++ )
if ( max < lis[i] )
max = lis[i];

return max;
}"
Unique Binary Search Trees,https://www.interviewbit.com/problems/unique-binary-search-trees/,"Amazon, Directi",Dynamic Programming,easy,"Given A, generate all structurally unique BST's (binary search trees) that store values 1...A.


Problem Constraints
1 <= A <= 15


Input Format
The first argument is an integer A.


Output Format
Return an array of TreeNode


Example Input
A = 3


Example Output
1 3 3 2 1
\ / / / \ \
3 2 1 1 3 2
/ / \ \
2 1 2 3",N/A
Max Rectangle in Binary Matrix,https://www.interviewbit.com/problems/max-rectangle-in-binary-matrix/,"Microsoft, Google",Dynamic Programming,medium,"Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing all ones and return its area.

Bonus if you can solve it in O(n^2) or less.

Example :

A : [ 1 1 1
0 1 1
1 0 0
]

Output : 4

As the max area rectangle is created by the 2x2 rectangle created by (0,1), (0,2), (1,1) and (1,2)","int maxRect(int lenTable[], int len) {
stack<int> ss;
int ret = 0, i = 0;
while (i < len) {
if (ss.empty() || lenTable[i] >= lenTable[ss.top()]) {
ss.push(i++);
} else {
int temp = ss.top();
ss.pop();
ret = std::max(ret, lenTable[temp]*(ss.empty() ? i: (i - ss.top() -1)));
}
}
while (!ss.empty()) {
int temp = ss.top();
ss.pop();
ret = std::max(ret, lenTable[temp]*(ss.empty() ? i: (i - ss.top() -1)));
}
return ret;
}
int Solution::maximalRectangle(vector<vector<int> > &A) {
int rows = A.size(), h, w;
if (rows == 0) return 0;
int cols = A[0].size();
if (cols == 0) return 0;

int lenTable[rows][cols];
for (w = 0; w < rows; ++w) {
for (h = 0; h < cols; ++h) {
lenTable[w][h] = 0;
}
}
for (h = 0; h < cols; ++h) {
if (A[0][h] == 1) {
lenTable[0][h] = 1;
}
}

for (w = 1; w < rows; ++w) {
for (h = 0; h < cols; ++h) {
if (A[w][h] == 0) {
continue;
}
lenTable[w][h] = lenTable[w-1][h] + 1;
}
}

/*for (w = 0; w < rows; ++w) {
for (h = 0; h < cols; ++h) {
std::cout << lenTable[w][h] << "";"";
}
std::cout << endl;
}*/
int ret = 0;
for (w=0;w<rows;++w) {
ret = std::max(ret, maxRect(lenTable[w],cols));
//std::cout << ret << endl;
}
return ret;
}"
Distinct Subsequences,https://www.interviewbit.com/problems/distinct-subsequences/,Google,Dynamic Programming,medium,"Given two sequences A, B, count number of unique ways in sequence A, to form a subsequence that is identical to the sequence B.

Subsequence : A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ACE” is a subsequence of “ABCDE” while “AEC” is not).

Input Format:

The first argument of input contains a string, A.
The second argument of input contains a string, B.

Output Format:

Return an integer representing the answer as described in the problem statement.

Constraints:

1 <= length(A), length(B) <= 700

Example :

Input 1:
A = ""abc""
B = ""abc""

Output 1:
1

Explanation 1:
Both the strings are equal.

Input 2:
A = ""rabbbit""
B = ""rabbit""

Output 2:
3

Explanation 2:
These are the possible removals of characters:
=> A = ""ra_bbit""
=> A = ""rab_bit""
=> A = ""rabb_it""

Note: ""_"" marks the removed character.","int Solution::numDistinct(string S, string T) {
int sLen = S.length(), tLen = T.length();
if (sLen < tLen) return 0;
if (sLen == tLen) {
if (S.compare(T) == 0) {
return 1;
} else {
return 0;
}
}

int path[tLen+1][sLen+1], i, j;

for (i = 0; i <= sLen; ++i) {
path[0][i] = 0;
}
for (j = 0; j <= tLen; ++j) {
path[j][0] = 0;
}

for (i = 1; i <= tLen; ++i) {
for (j = 1; j <= sLen; ++j) {
if (T.at(i-1) == S.at(j-1)) {
if (i != 1) {
path[i][j] = path[i][j-1] + path[i-1][j-1];
} else {
path[i][j] = path[i][j-1] + 1;
}
} else {
path[i][j] = path[i][j-1];
}
}
}
return path[tLen][sLen];
}"
Unique Paths in a Grid,https://www.interviewbit.com/problems/distinct-subsequences/,Facebook,Dynamic Programming,medium,"Given a grid of size m * n, lets assume you are starting at (1,1) and your goal is to reach (m,n). At any instance, if you are on (x,y), you can either go to (x, y + 1) or (x + 1, y).

Now consider if some obstacles are added to the grids. How many unique paths would there be?
An obstacle and empty space is marked as 1 and 0 respectively in the grid.

Example :
There is one obstacle in the middle of a 3x3 grid as illustrated below.

[
[0,0,0],
[0,1,0],
[0,0,0]
]

The total number of unique paths is 2.

Note: m and n will be at most 100.","int Solution::uniquePathsWithObstacles(vector<vector<int> > &A) {
int m = A.size();
assert(A.size()>=0 && A.size()<=100 && A[0].size()>=0 && A[0].size()<=100);
if (m == 0) {
return 0;
}
int n = A[0].size();
if (n == 0) {
return 0;
}
int steps[m][n];

int noSteps = 1, i,j;
for (i = 0; i < n; ++i) {
if (A[0][i] == 1) {
noSteps = 0;
}
steps[0][i] = noSteps;
}
noSteps = 1;
for (i = 0; i < m; ++i) {
if (A[i][0] == 1) {
noSteps = 0;
}
steps[i][0] = noSteps;
}
for (i = 1; i < m; i++)
{
for (j = 1; j < n; j++) {
if (A[i][j] == 1) {
steps[i][j] = 0;
} else {
steps[i][j] = steps[i-1][j] + steps[i][j-1]; //+ count[i-1][j-1];
}
}
}
/*for (i = 0; i < m; i++)
{
for (j = 0; j < n; j++) {
std::cout << steps[i][j] << "";"";
}
std::cout << std::endl;
}*/
return steps[m-1][n-1];
}"
Max Product Subarray,https://www.interviewbit.com/problems/max-product-subarray/,"Amazon, Linkedin, Microsoft",Dynamic Programming,medium,"Find the contiguous subarray within an array (containing at least one number) which has the largest product.
Return an integer corresponding to the maximum product possible.

Example :

Input : [2, 3, -2, 4]
Return : 6

Possible with [2, 3]","long long solve(const vector<int> &A,int l,int r)
{
long long ans=1,flag=0,cnt=0;
for(int i=l;i<=r;i++)
{
ans*=(1ll*A[i]);
if(A[i]<0)
cnt++;
}
if(cnt%2==0)
return ans;
long long p1=1,p2=1;
for(int i=l;i<=r;i++)
{
if(flag==1)
p1*=(1ll*A[i]);
if(A[i]<0)
flag=1;
}
for(int i=r;i>=l;i--)
{
if(flag==0)
p2*=(1ll*A[i]);
if(A[i]<0)
flag=0;
}
return max(p1,p2);
}
int Solution::maxProduct(const vector<int> &A) {
long long ans=1;
int l=0,n=A.size(),maxm=INT_MIN;

for(int i=0;i<n;i++)
{
maxm=max(maxm,A[i]);
if(A[i]==0)
{
ans=max(ans,solve(A,l,i-1));
l=i+1;
}
}
if(l!=n)
ans=max(ans,solve(A,l,n-1));
if(maxm<=0&&ans==1)
return maxm;
return (int)ans;
}"
Ways to Decode,https://www.interviewbit.com/problems/ways-to-decode/,"Facebook, Amazon",Dynamic Programming,medium,"A message containing letters from A-Z is being encoded to numbers using the following mapping:

 

'A' -> 1
'B' -> 2
...
'Z' -> 26

Given an encoded message A containing digits, determine the total number of ways to decode it modulo 109 + 7.

 


Problem Constraints
1 <= |A| <= 105


Input Format
The first and the only argument is a string A.


Output Format
Return a single integer denoting the total number of ways to decode it modulo 109 + 7.


Example Input
Input 1:

 

A = ""8""

Input 2:

A = ""12""

 


Example Output
Output 1:

 

1

Output 2:

2

 


Example Explanation
Explanation 1:

 

Given encoded message ""8"", it could be decoded as only ""H"" (8).
The number of ways decoding ""8"" is 1.

Explanation 2:

Given encoded message ""12"", it could be decoded as ""AB"" (1, 2) or ""L"" (12).
The number of ways decoding ""12"" is 2.","const int mod = 1000000007;
const int maxn = 100009;
int dp[maxn];
int solve(int index, string & A) {
if (index >= A.size())
return 1;
if (dp[index] != -1)
return dp[index];
if (A[index] == '0')
return dp[index] = 0;
int ans = solve(index + 1, A);
ans %= mod;
if (index + 1 < A.size()) {
int num = ((A[index] - '0') * 10) + (A[index + 1] - '0');
if (num >= 10 && num <= 26)
ans += solve(index + 2, A);
ans %= mod;
}
return dp[index] = ans;
ans %= mod;
}
int Solution::numDecodings(string A) {
memset(dp, -1, sizeof(dp));
return solve(0, A);
}"
Best Time to Buy and Sell Stocks II,https://www.interviewbit.com/problems/best-time-to-buy-and-sell-stocks-ii/,"Amazon, Facebook",Dynamic Programming,easy,"Say you have an array, A, for which the ith element is the price of a given stock on day i.

 

Design an algorithm to find the maximum profit.

You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).

However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).


Problem Constraints
0 <= len(A) <= 1e5
1 <= A[i] <= 1e7


Input Format
The first and only argument is an array of integers, A.


Output Format
Return an integer, representing the maximum possible profit.


Example Input
Input 1:
A = [1, 2, 3]
Input 2:
A = [5, 2, 10]



Example Output
Output 1:
2
Output 2:
8



Example Explanation
Explanation 1:
=> Buy a stock on day 0.
=> Sell the stock on day 1. (Profit +1)
=> Buy a stock on day 1.
=> Sell the stock on day 2. (Profit +1)

Overall Profit = 2
 

Explanation 2:
=> Buy a stock on day 1.
=> Sell the stock on on day 2. (Profit +8)

Overall profit = 8","int Solution::maxProfit(const vector<int> &A) {
// Prices must be given for at least two days
if (A.size() <= 1) {
return 0;
}

int count = 0; // count of solution pairs
int n = A.size();
// solution vector
int buy[n/2 + 1], sell[n/2 + 1];

// Traverse through given price array
int i = 0;
while (i < n-1)
{
// Find Local Minima. Note that the limit is (n-2) as we are
// comparing present element to the next element.
while ((i < n-1) && (A[i+1] <= A[i]))
i++;

// If we reached the end, break as no further solution possible
if (i == n-1)
break;

// Store the index of minima
buy[count] = i++;

// Find Local Maxima. Note that the limit is (n-1) as we are
// comparing to previous element
while ((i < n) && (A[i] >= A[i-1]))
i++;

// Store the index of maxima
sell[count] = i-1;

// Increment count of buy/sell pairs
count++;
}

// print solution
if (count == 0)
return 0;
else
{
int ret = 0;
for (int i = 0; i < count; i++) {
ret += A[sell[i]] - A[buy[i]];
//printf(""Buy on day: %d\t Sell on day: %d\n"", sol[i].buy, sol[i].sell);
}
return ret;
}
}"
Best Time to Buy and Sell Stocks III,https://www.interviewbit.com/problems/best-time-to-buy-and-sell-stocks-iii/,"Amazon, Facebook",Dynamic Programming,hard,"Say you have an array, A, for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete at most 2 transactions.

Return the maximum possible profit.

Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).


Problem Constraints
1 <= length(A) <= 7e5
1 <= A[i] <= 1e7


Input Format
The first and only argument is an integer array, A.


Output Format
Return an integer, representing the maximum possible profit.


Example Input
Input 1:
A = [1, 2, 1, 2]
 

Input 2:
A = [7, 2, 4, 8, 7]



Example Output
Output 1:
2
Output 2:
6



Example Explanation
Explanation 1:
Day 0 : Buy
Day 1 : Sell
Day 2 : Buy
Day 3 : Sell
 

Explanation 2:
Day 1 : Buy
Day 3 : Sell","int Solution::maxProfit(const vector<int> &A) {

int FirstBuy=INT_MAX,FirstSell=0,SecondBuy=INT_MAX,SecondSell=0;
for(int i=0;i<A.size();i++)
{
int b1=FirstBuy,s1=FirstSell,b2=SecondBuy,s2=SecondSell;
FirstBuy=min(b1,A[i]);
FirstSell=max(s1,A[i]-b1);
SecondBuy=min(b2,A[i]-s1);
SecondSell=max(s2,A[i]-b2);
}
return max(FirstSell,SecondSell);
}"
Scramble String,https://www.interviewbit.com/problems/scramble-string/,N/A,Dynamic Programming,hard,"Given a string A, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.

Below is one possible representation of A = “great”:


great
/ \
gr eat
/ \ / \
g r e at
/ \
a t


To scramble the string, we may choose any non-leaf node and swap its two children.

For example, if we choose the node “gr” and swap its two children, it produces a scrambled string “rgeat”.

rgeat
/ \
rg eat
/ \ / \
r g e at
/ \
a t

We say that “rgeat” is a scrambled string of “great”.

Similarly, if we continue to swap the children of nodes “eat” and “at”, it produces a scrambled string “rgtae”.

rgtae
/ \
rg tae
/ \ / \
r g ta e
/ \
t a

We say that “rgtae” is a scrambled string of “great”.




Given two strings A and B of the same length, determine if B is a scrambled string of S.




Input Format:

The first argument of input contains a string A.
The second argument of input contains a string B.

Output Format:

Return an integer, 0 or 1:
=> 0 : False
=> 1 : True

Constraints:

1 <= len(A), len(B) <= 50

Examples:

Input 1:
A = ""we""
B = ""we""

Output 1:
1

Input 2:
A = ""phqtrnilf""
B = ""ilthnqrpf""

Output 2:
0","bool isScramble(int a,int b,int c,int d,string s1,string s2)
{
if(b-a != d-c)
return false;
if(a==b && c==d)
{
if(s1[a]==s2[c])
return true;
return false;
}
string temp1=s1.substr(a,b-a+1);
string temp2=s2.substr(c,d-c+1);
sort(temp1.begin(),temp1.end());
sort(temp2.begin(),temp2.end());
if(temp1!=temp2)
return false;

for(int i = 1; i < s1.length(); i++) { // i being the root position
if(isScramble(s1.substring(0,i), s2.substring(0,i)) && isScramble(s1.substring(i), s2.substring(i))) return true;
if(isScramble(s1.substring(0,i), s2.substring(s2.length()-i)) && isScramble(s1.substring(i), s2.substring(0, s2.length()-i))) return true;
}

}
int Solution::isScramble(const string A, const string B) {
}"
Best Time to Buy and Sell Stocks I,https://www.interviewbit.com/problems/best-time-to-buy-and-sell-stocks-i/,"Amazon, Facebook",Dynamic Programming,easy,"Say you have an array, A, for which the ith element is the price of a given stock on day i.
If you were only permitted to complete at most one transaction (i.e, buy one and sell one share of the stock), design an algorithm to find the maximum profit.

Return the maximum possible profit.



Problem Constraints
0 <= len(A) <= 7e5

1 <= A[i] <= 1e7



Input Format
The first and the only argument is an array of integers, A.



Output Format
Return an integer, representing the maximum possible profit.



Example Input
Input 1:

 A = [1, 2]
Input 2:

 A = [1, 4, 5, 2, 4]


Example Output
Output 1:
 1
Output 2:

 4


Example Explanation
Explanation 1:

 Buy the stock on day 0, and sell it on day 1.
Explanation 2:

 Buy the stock on day 0, and sell it on day 2.","int Solution::maxProfit(const vector<int> &arr) {

    int n = arr.size();
    if (n <= 1) {
        return 0;
    }
    int diff[n-1];
    for (int i=0; i < n-1; i++)
        diff[i] = arr[i+1] - arr[i];

    int max_diff = diff[0];
    for (int i=1; i<n-1; i++)
    {
        if (diff[i-1] > 0)
            diff[i] += diff[i-1];
        if (max_diff < diff[i])
            max_diff = diff[i];
    }
    return max_diff > 0 ? max_diff:0;
}"
Max Sum Path in Binary Tree,https://www.interviewbit.com/problems/max-sum-path-in-binary-tree/,"Directi, Amazon",Dynamic Programming,medium,"Given a binary tree T, find the maximum path sum.

The path may start and end at any node in the tree.



Problem Constraints
1 <= Number of Nodes <= 7e4

-1000 <= Value of Node in T <= 1000



Input Format
 The first and the only argument contains a pointer to the root of T, A.



Output Format
Return an integer representing the maximum sum path.



Example Input
Input 1:

    1
   / \
  2   3
Input 2:

       20
      /  \
   -10   20
        /  \
      -10  -50


Example Output
Output 1:

 6
Output 2:

 40


Example Explanation
Explanation 1:

     The path with maximum sum is: 2 -> 1 -> 3
Explanation 2:

     The path with maximum sum is: 20 -> 20","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */ 
int maxPathAndGlobalUpdate(TreeNode *root, int &global_max) {
    if (root == NULL) return 0;
    int l = max(0, maxPathAndGlobalUpdate(root->left, global_max));
    int r = max(0, maxPathAndGlobalUpdate(root->right, global_max));
    global_max = max({ global_max, max(l, r) + root->val, l + r + root->val });
    return root->val + max(l, r);
}
int Solution::maxPathSum(TreeNode* root) {
    int maxAns = INT_MIN;
    maxPathAndGlobalUpdate(root, maxAns);
    return maxAns;
}"
Regular Expression Match,https://www.interviewbit.com/problems/regular-expression-match/,"Uber Technologies Inc, Microsoft, Directi, Facebook",Dynamic Programming,hard,"Problem Description
 
 

Implement wildcard pattern matching with support for '?' and '*' for strings A and B.
'?' : Matches any single character.
'*' : Matches any sequence of characters (including the empty sequence).
The matching should cover the entire input string (not partial).


Problem Constraints
1 <= |A|, |B| <= 9e4


Input Format
The first argument of input contains a string A.
The second argument of input contains a string B.


Output Format
Return 0 or 1:
=> 0 : If the patterns do not match.
=> 1 : If the patterns match.


Example Input
Input 1:
 A = ""aa""
 B = ""a""
Input 2:
 A = ""aa""
 B = ""aa""
Input 3:
 A = ""aaa""
 B = ""aa""
Input 4:
 A = ""aa""
 B = ""*""
Input 5:
 A = ""aa""
 B = ""a*""
Input 6:
 A = ""ab""
 B = ""?*""
Input 7:
 A = ""aab""
 B = ""c*a*b""


Example Output
Output 1:
0
Output 2:
1
Output 3:
0
Output 4:
1
Output 5:
1
Output 6:
1
Output 7:
0","map<pair<int, int>, int> M;
int suffixLen[50001], len1, len2;
bool helper(const string s, const string p, int index1, int index2) {
    // If we are at the end of both pattern and the string, then its obviously a match
    if (index1 == s.size() && p[index2] == 0) return true;
    // If pattern ends, but the string hasn't, then its not a match
    if (index2 == p.size()) return false;
    // If string ends, then the only permissible character is '*' in the pattern array
    if (index1 == s.size() && p[index2] != '*') return false;
    // If remaining non * characters in pattern are more than the total chars in s, there can't be match
    if (len1 - index1 < suffixLen[index2]) return false;
    // memoized result
    if (M.find(make_pair(index1, index2)) != M.end()) return M[make_pair(index1, index2)];
    // s has ended. We know next character in p is '*'. Lets check other following chars in p
    if (s[index1] == 0) return M[make_pair(index1, index2)] = helper(s, p, index1, index2 + 1);
    // characters match when pattern is not '*'
    if (s[index1] == p[index2] || p[index2] == '?') return M[make_pair(index1, index2)] = helper(s, p, index1 + 1, index2 + 1);
    // If pattern is '*', then explore both possibilities
    if (p[index2] == '*') return M[make_pair(index1, index2)] = (helper(s, p, index1 + 1, index2) || helper(s, p, index1, index2 + 1));
    return M[make_pair(index1, index2)] = false;
}

int Solution::isMatch(const string s, const string p) {
    M.clear();
    len1 = s.size();
    len2 = p.size();
    int cnt = 0;
    for (int i = len2 - 1; i >= 0; i--){
        if (p[i] != '*') cnt++;
        suffixLen[i] = cnt;
    }
    return helper(s, p, 0, 0);
}"
Dungeon Princess,https://www.interviewbit.com/problems/dungeon-princess/,N/A,Dynamic Programming,medium,"The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.

The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.

Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0’s) or contain magic orbs that increase the knight’s health (positive integers).

In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.

Write a function to determine the knight’s minimum initial health so that he is able to rescue the princess.

For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path

RIGHT-> RIGHT -> DOWN -> DOWN.

Dungeon Princess: Example 1




Input arguments to function:

Your function will get  an M*N matrix (2-D array) as input which represents the 2D grid as described in the question. Your function should return an integer corresponding to the knight’s minimum initial health required. 




Note:

The knight’s health has no upper bound.
Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.","int Solution::calculateMinimumHP(vector<vector<int> > &A) {
    int m = A.size(), i, j;
    if (m == 0) {
        return 0;
    }
    int n = A[0].size();
    if (n == 0) {
        return 0;
    }
    int dp[m][n];
    dp[m-1][n-1] = std::max(0-A[m-1][n-1],0);
    for (i = m - 2; i >= 0; --i) {
        dp[i][n-1] = std::max(dp[i+1][n-1] - A[i][n-1], 0);
    }
    for (j = n - 2; j >= 0; --j) {
        dp[m-1][j] = std::max(dp[m-1][j+1] - A[m-1][j], 0);
    }
    
    for (i = m - 2; i >= 0; --i) {
        for (j = n - 2; j >= 0; --j) {
            dp[i][j] = std::max(std::min(dp[i][j+1],dp[i+1][j]) - A[i][j], 0);
        }
    }
    
    return dp[0][0]+1;
}"
Palindrome Partitioning II,https://www.interviewbit.com/problems/palindrome-partitioning-ii/,"Amazon, Google",Dynamic Programming,medium,"Problem Description
 
 

Given a string A, partition A such that every substring of the partition is a palindrome.

Return the minimum cuts needed for a palindrome partitioning of A.



Problem Constraints
1 <= length(A) <= 501



Input Format
The first and the only argument contains the string A.



Output Format
Return an integer, representing the minimum cuts needed.



Example Input
Input 1:

 A = ""aba""
Input 2:

 A = ""aab""


Example Output
Output 1:

 0
Output 2:

 1


Example Explanation
Explanation 1:

 ""aba"" is already a palindrome, so no cuts are needed.
Explanation 2:

 Return 1 since the palindrome partitioning [""aa"",""b""] could be produced using 1 cut.","
int Solution::minCut(string A) {
    int n=A.size();
    int dp[n],palin[n][n];
    memset(palin,0,sizeof palin);
    for(int i=1;i<=n;i++)
    {
        for(int j=0;j<n;j++)
        {
            int l=j,r=j+i-1;
            if(i==1) palin[l][l]=1;
            else if(i==2 && j+1<n) palin[l][r]=(A[l]==A[r]);
            else if(r<n)
            {
                if(palin[l+1][r-1] && A[l]==A[r])
                {
                    palin[l][r]=1;
                }
            }
        }
    }
    for(int i=0;i<n;i++) dp[i]=INT_MAX;
    for(int i=0;i<n;i++)
    {
        for(int j=i;j<n;j++)
        {
            if(i==0)
            {
                if(palin[i][j]) dp[j]=0;
            }
            else
            {
                if(palin[i][j])
                {
                    dp[j]=min(dp[j],dp[i-1]+1);
                }
            }
        }
    }
    return dp[n-1];
}"
Min Sum Path in Matrix,https://www.interviewbit.com/problems/min-sum-path-in-matrix/,"Amazon, Flipkart",Dynamic Programming,medium,"Problem Description
 
 

Given a 2D integer array A of size M x N, you need to find a path from top left to bottom right which minimizes the sum of all numbers along its path.

NOTE: You can only move either down or right at any point in time. 



Input Format
First and only argument is an 2D integer array A of size M x N.



Output Format
Return a single integer denoting the minimum sum of a path from cell (1, 1) to cell (M, N).



Example Input
Input 1:

 A = [  [1, 3, 2]
        [4, 3, 1]
        [5, 6, 1]
     ]


Example Output
Output 1:

 8


Example Explanation
Explanation 1:

 The path is 1 -> 3 -> 2 -> 1 -> 1
 So ( 1 + 3 + 2 + 1 + 1) = 8","int Solution::minPathSum(vector<vector<int> > &A) {
    int m,n,i,j;
    m = A.size();
    if (m == 0) {
        return 0;
    }
    n = A[0].size();
    if (n == 0) {
        return 0;
    }
    int tc[m][n];
    tc[0][0] = A[0][0];
    for (i = 1; i < m; ++i) {
        tc[i][0] = tc[i-1][0] + A[i][0];
    }
    for (j = 1; j < n; ++j) {
        tc[0][j] = tc[0][j-1] + A[0][j];
    }
    
    for (i = 1; i < m; ++i) {
        for (j = 1; j < n; ++j) {
            tc[i][j] = std::min(tc[i][j-1],tc[i-1][j])+A[i][j];
        }
    }
    return tc[m-1][n-1];
}"
Min Jumps Array,https://www.interviewbit.com/problems/min-jumps-array/,"Amazon, ebay, Google",Dynamic Programming,medium,"Problem Description
 
 

Given an array of non-negative integers, A, of length N, you are initially positioned at the first index of the array.
Each element in the array represents your maximum jump length at that position.
Return the minimum number of jumps required to reach the last index.
If it is not possible to reach the last index, return -1.


Problem Constraints
1 <= N <= 106
0 <= A[i] <= 50000


Input Format
The first and the only argument contains an integer array, A.


Output Format
Return an integer, representing the answer as described in the problem statement.


Example Input
Input 1:
A = [2, 1, 1]
Input 2:
A = [2, 3, 1, 1, 4]


Example Output
Output 1:
1
Output 1:
2


Example Explanation
Explanation 1:
The shortest way to reach index 2 is
    Index 0 -> Index 2
that requires only 1 jump.
Explanation 2:
The shortest way to reach index 4 is
    Index 0 -> Index 1 -> Index 4
that requires 2 jumps.","int Solution::jump(vector<int> &A) {
        int n=A.size();
        assert(n>=1 && n<=1000000);
        for(int a:A)
            assert(a>=0 && a<=50000);
        if(n <= 1){
            return 0;
        }
        int maxReachPos = A[0];
        int curMaxReachPos = A[0];
        int curStep = 1;
        for(int i = 1; i <= maxReachPos; i++){
            if(i == n - 1){
                return curStep;
            }
            curMaxReachPos = max(curMaxReachPos, i + A[i]);
            if(i == maxReachPos){
                if (curMaxReachPos <= i) return -1;
                maxReachPos = curMaxReachPos;
                curStep++;
            }
        }
        return -1;
}"
Edit Distance,https://www.interviewbit.com/problems/edit-distance/,"Google, Amazon, Flipkart, Microsoft, Linkedin",Dynamic Programming,medium,"Given two strings A and B, find the minimum number of steps required to convert A to B. (each operation is counted as 1 step.)

You have the following 3 operations permitted on a word:

Insert a character
Delete a character
Replace a character


Input Format:

The first argument of input contains a string, A.
The second argument of input contains a string, B.
Output Format:

Return an integer, representing the minimum number of steps required.
Constraints:

1 <= length(A), length(B) <= 450
Examples:

Input 1:
    A = ""abad""
    B = ""abac""

Output 1:
    1

Explanation 1:
    Operation 1: Replace d with c.

Input 2:
    A = ""Anshuman""
    B = ""Antihuman""

Output 2:
    2

Explanation 2:
    => Operation 1: Replace s with t.
    => Operation 2: Insert i.","int Solution::minDistance(string A, string B) {
    int m = A.size(), n = B.size();
    vector< vector<int> > dist(m+1, vector<int>(n+1));
    dist[0][0] = 0;
    for (int i = 1; i <= m; ++i)
        dist[i][0] = i;
    for (int j = 1; j <= n; ++j)
        dist[0][j] = j;
    for (int i = 1; i <= m; ++i)
        for (int j = 1; j <= n; ++j)
            dist[i][j] = min(dist[i-1][j-1] + (A[i-1] != B[j-1]), 1 + min(dist[i][j-1], dist[i-1][j]));
    return dist[m][n];
}"
Unique Binary Search Trees II,https://www.interviewbit.com/problems/unique-binary-search-trees-ii/,"Amazon, Directi",Dynamic Programming,medium,"Given an integer A, how many structurally unique BST’s (binary search trees) exist that can store values 1…A?

Input Format:

The first and the only argument of input contains the integer, A.
Output Format:

Return an integer, representing the answer asked in problem statement.
Constraints:

1 <= A <= 18
Example:

Input 1:
    A = 3

Output 1:
    5

Explanation 1:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3","int Solution::numTrees(int A) {
    int ret[A+1], i, j, sum;
    ret[0] = 1;
    ret[1] = 1;
    for (i = 2; i <= A; ++i) {
        sum = 0;
        for (j = 1; j <= i; ++j) {
            sum += ret[j-1] * ret[i-j];
        }
        ret[i] = sum;
    }
    return ret[A];
}"
Word Break,https://www.interviewbit.com/problems/word-break/,Google,Dynamic Programming,medium,"Problem Description
 
 

Given a string A and a dictionary of words B, determine if A can be segmented into a space-separated sequence of one or more dictionary words.


Problem Constraints
1 <= len(A) <= 6500
1 <= len(B) <= 10000
1 <= len(B[i]) <= 20


Input Format
The first argument is a string, A.
The second argument is an array of strings, B.


Output Format
Return 0 / 1 ( 0 for false, 1 for true ) for this problem.


Example Input
Input 1:
 A = ""myinterviewtrainer"",
B = [""trainer"", ""my"", ""interview""]
Input 2:
A = ""a""
B = [""aaa""]


Example Output
Output 1:
1
Output 2:
0


Example Explanation
Explanation 1:
Return 1 ( corresponding to true ) because ""myinterviewtrainer"" can be segmented as ""my interview trainer"".
Explanation 2:

Return 0 ( corresponding to false ) because ""a"" cannot be segmented as ""aaa"".
","int Solution::wordBreak(string A, vector<string> &B) {
    set<string> dict(B.begin(), B.end());
	vector<bool> reachable(A.size(), false);
	for (int i = 0; i < A.size(); ++i) {
		for (int j = i; j >= 0 && !reachable[i]; --j) {
			if (j == 0 || reachable[j-1]) {
				string word(A.begin() + j, A.begin() + i + 1);
				if (dict.find(word) != dict.end())
					reachable[i] = true;
			}
		}
	}

	return reachable[A.size()-1];
}"
Regular Expression II,https://www.interviewbit.com/problems/regular-expression-ii/,"Facebook, Microsoft, Google",Dynamic Programming,hard,"Problem Description
 
 

Implement regular expression matching with support for '.' and '*'.
'.' Matches any single character. 
'*' Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).

Return 0 / 1 ( 0 for false, 1 for true ) for this problem



Problem Constraints
1 <= |A| <= 5 * 103
1 <= |B| <= 5 * 103


Input Format
The first argument is a string A.
The second argument is a string A.


Output Format
Return an integer, 0 / 1 ( 0 for false, 1 for true ) for this problem


Example Input
isMatch(""aa"",""a"") ? 0
isMatch(""aa"",""aa"") ? 1
isMatch(""aaa"",""aa"") ? 0
isMatch(""aa"", ""a*"") ? 1
isMatch(""aa"", "".*"") ? 1
isMatch(""ab"", "".*"") ? 1
isMatch(""aab"", ""c*a*b"") ? 1","int _isMatch(const string &s, int sStart, int sLen, const string &p, int pStart, int pLen) {
    int i;
    if (pLen == pStart) {
        return sLen == sStart;
    }
    if (pStart == pLen - 1) {
		if (sStart >= sLen) {
			return 0;
		} else if ((p.at(pStart) != s.at(sStart)) && (p.at(pStart) != '.')) {
			return 0;
		} else {
			return _isMatch(s, sStart+1, sLen, p, pStart+1, pLen);
		}
	}
	if (p.at(pStart+1) != '*') {
	    if (sStart >= sLen) {
	        return 0;
	    }
	    if ((p.at(pStart) != s.at(sStart)) && (p.at(pStart) != '.')) {
			return 0;
		} else {
			return _isMatch(s, sStart+1, sLen, p, pStart+1, pLen);
		}
	} else {
		if (_isMatch(s, sStart, sLen, p, pStart+2, pLen)) {
			return 1;
		}
		i = sStart;
		while (i<sLen && (s.at(i)==p.at(pStart) || p.at(pStart)=='.')){
			if (_isMatch(s, i + 1, sLen, p, pStart+2, pLen)) {
				return 1;
			}
			++i;
		}
		return false;
	}
}
int _isMatchDP(const string &s, int m, const string &p, int pLen) {
    int noStars = 0, i=0, j;
    while (i < pLen) {
        if (p.at(i) == '*') {
            ++noStars;
        }
        ++i;
    }
    int n = pLen-noStars;
    int isMatch[m+1][n+1];
    char temp, tempNext;
    for (i = 0; i <= m; ++i) {
        for (j = 0; j <= n; ++j) {
            isMatch[i][j] = 0;
        }
    }
    for (i = 0; i <= m; ++i) {
        for (j = 0; j <= n; ++j) {
            //std::cout << i << "";"" << j << std::endl;
            if (i == 0 && j == 0) {
                isMatch[i][j] = 1;
                continue;
            }
            if (i == 0) {
                if (j > 0 && j < pLen && p.at(j) == '*') {
                    isMatch[i][j] = isMatch[i][j-1];
                    ++j;
                }
            } else if (i > 0 && j == 0) {
                isMatch[i][j] = 0;
            } else if (i > 0 && j > 0) {
                temp = p.at(j-1);
                if (j < pLen) {
                    tempNext = p.at(j);
                    if (tempNext == '?') {
                        isMatch[i][j] = isMatch[i-1][j-1];
                        ++j;
                        continue;
                    } else if (tempNext == '*') {
                        isMatch[i][j] = isMatch[i-1][j] || isMatch[i][j-1];
                        ++j;
                        continue;
                    } else {
                        if (s.at(i-1) == temp) {
                            isMatch[i][j] = isMatch[i-1][j-1];
                        }
                    }
                } else {
                    if (s.at(i-1) == temp) {
                        isMatch[i][j] = isMatch[i-1][j-1];
                    }
                }
            }
        }
    }
    /*for (i = 0; i <= m; ++i) {
        for (j = 0; j <= n; ++j) {
            std::cout << isMatch[i][j] << "";"" ;
        }
        std::cout << std::endl;
    }*/
    return isMatch[m][n];
}
int Solution::isMatch(const string &s, const string &p) {
    int m = s.length(), pLen = p.length();
    return _isMatch(s, 0, m, p, 0, pLen);
    return _isMatchDP(s,m,p,pLen);
}"
Min Sum Path in Triangle,https://www.interviewbit.com/problems/min-sum-path-in-triangle/,N/A,Dynamic Programming,medium,"Problem Description
 
 

Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.

Adjacent numbers for jth number of row i is jth and (j+1)th numbers of row i+1 is  



Problem Constraints
1 <= |A| <= 1000

1 <= A[i] <= 1000

 



Input Format
 First and only argument is the vector of vector A defining the given triangle



Output Format
 Return the minimum sum 



Example Input
Input 1:

 
A = [ 
         [2],
        [3, 4],
       [6, 5, 7],
      [4, 1, 8, 3]
    ]
Input 2:

 A = [ [1] ]


Example Output
Output 1:

 11
Output 2:

 1


Example Explanation
Explanation 1:

 The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).
Explanation 2:

 Only 2 can be collected.
","int Solution::minimumTotal(vector<vector<int> > &triangle) {
    int n = triangle.size();
    vector<int> minlen(triangle.back());
    for (int layer = n-2; layer >= 0; layer--) // For each layer
    {
        for (int i = 0; i <= layer; i++) // Check its every 'node'
        {
            // Find the lesser of its two children, and sum the current value in the triangle with it.
            minlen[i] = min(minlen[i], minlen[i+1]) + triangle[layer][i]; 
        }
    }
    return minlen[0];
}
/*int Solution::minimumTotal(vector<vector<int> > &A) {
    int m = A.size(), i, j;
    vector<vector<int> > costs;
    if (m == 0) {
        return 0;
    }
    vector<int> temp(A[0][0]);
    costs.push_back(temp);
    for (i = 1; i < m; ++i) {
        temp.clear();
        for (j = 0; j < A[i].size(); ++j) {
            if (j == 0) {
                temp.push_back(costs[i-1][j]+A[i][j]);
            } else if (j == A[i].size()-1) {
                temp.push_back(costs[i-1][j-1]+A[i][j]);
            } else {
                temp.push_back(std::min(costs[i-1][j-1], costs[i-1][j]) + A[i][j]);
            }
        }
        costs.push_back(temp);
    }
    return *std::min_element(costs[m-1].begin(),costs[m-1].end());
}*/"
Jump Game Array,https://www.interviewbit.com/problems/jump-game-array/,"Amazon, ebay",Dynamic Programming,medium,"Given an array of non-negative integers, A, you are initially positioned at the 0th index of the array.

Each element in the array represents your maximum jump length at that position.

Determine if you are able to reach the last index.



Input Format:

The first and the only argument of input will be an integer array A.
Output Format:

Return an integer, representing the answer as described in the problem statement.
    => 0 : If you cannot reach the last index.
    => 1 : If you can reach the last index.
Constraints:

    1 <= len(A) <= 106


    0 <= A[i] <= 30

Examples:

Input 1:
    A = [2,3,1,1,4]

Output 1:
    1

Explanation 1:
    Index 0 -> Index 2 -> Index 3 -> Index 4

Input 2:
    A = [3,2,1,0,4]

Output 2:
    0

Explanation 2:
    There is no possible path to reach the last index.","int Solution::canJump(vector<int> &A) {
    int next = A.size() - 1;  
    for (int i=A.size()-2; i>=0; --i) {   
        if (A[i] >= (next - i)) {   
            next = i;   
        }  
    }   
    return (next == 0) ? 1:0;
}"
Interleaving Strings,https://www.interviewbit.com/problems/interleaving-strings/,"Google, Yahoo",Dynamic Programming,hard,"Given A, B, C, find whether C is formed by the interleaving of A and B.

Input Format:*

The first argument of input contains a string, A.
The second argument of input contains a string, B.
The third argument of input contains a string, C.
Output Format:

Return an integer, 0 or 1:
    => 0 : False
    => 1 : True
Constraints:

1 <= length(A), length(B), length(C) <= 150
Examples:

Input 1:
    A = ""aabcc""
    B = ""dbbca""
    C = ""aadbbcbcac""

Output 1:
    1
    
Explanation 1:
    ""aa"" (from A) + ""dbbc"" (from B) + ""bc"" (from A) + ""a"" (from B) + ""c"" (from A)

Input 2:
    A = ""aabcc""
    B = ""dbbca""
    C = ""aadbbbaccc""

Output 2:
    0

Explanation 2:
    It is not possible to get C by interleaving A and B.","int _interLeave(string A, int aStart, int s1Len, 
string B, int bStart, int s2Len, 
string C, int cStart, int s3Len) {
    //std::cout << aStart << "";"" << bStart << "";"" << cStart << std::endl;
    if (aStart == s1Len && bStart == s2Len && cStart == s3Len) {
        return 1;
    } else if (aStart > s1Len || bStart > s2Len || cStart >= s3Len) {
        return 0;
    }
    if ((aStart < s1Len && A.at(aStart) == C.at(cStart)) 
    && (bStart < s2Len && B.at(bStart) == C.at(cStart))) {
        return (_interLeave(A, aStart+1, s1Len, B, bStart, s2Len, C, cStart+1, s3Len) || 
        _interLeave(A, aStart, s1Len, B, bStart+1, s2Len, C, cStart+1, s3Len));
    } else if ((aStart < s1Len && A.at(aStart) == C.at(cStart))) {
        return _interLeave(A, aStart+1, s1Len, B, bStart, s2Len, C, cStart+1, s3Len);
    } else if ((bStart < s2Len && B.at(bStart) == C.at(cStart))) {
        return _interLeave(A, aStart, s1Len, B, bStart+1, s2Len, C, cStart+1, s3Len);
    } else {
        return 0;
    }
}
int _isInterleaveDP(string A, int s1Len, string B, int s2Len,  string C, int s3Len) {
    int isInterleaved[s1Len+1][s2Len+1], i, j;
    for (i = 0; i <= s1Len; ++i) {
        for (j = 0; j <= s2Len; ++j) {
            isInterleaved[i][j] = 0;
        }
    }
    for (i = 0; i <= s1Len; ++i) {
        for (j = 0; j <= s2Len; ++j) {
            //std::cout << i << "";"" << j << std::endl;
            if (i == 0 && j == 0) {
                isInterleaved[i][j] = 1;
            } else if (i == 0 && B.at(j-1) == C.at(j-1)) {
                isInterleaved[i][j] = isInterleaved[i][j-1];
            } else if (j == 0 && A.at(i-1) == C.at(i-1)) {
                isInterleaved[i][j] = isInterleaved[i-1][j];
            } else if (i > 0 && j > 0 && A.at(i-1) == C.at(i+j-1) && B.at(j-1) == C.at(i+j-1)) {
                isInterleaved[i][j] = (isInterleaved[i-1][j] || isInterleaved[i][j-1]);
            } else if (i > 0 && A.at(i-1) == C.at(i+j-1)) {
                isInterleaved[i][j] = isInterleaved[i-1][j];
            } else if (j > 0 && B.at(j-1) == C.at(i+j-1)) {
                isInterleaved[i][j] = isInterleaved[i][j-1];
            }
        }
    }
    return isInterleaved[s1Len][s2Len];
}
int Solution::isInterleave(string A, string B, string C) {
    int s1Len = A.length(), s2Len = B.length(), s3Len = C.length();
    if (s1Len + s2Len != s3Len) {
        return 0;
    }
    if (s1Len == 0) {
        if (B.compare(C) == 0) {
            return 1;
        } else {
            return 0;
        }
    }
    if (s2Len == 0) {
        if (A.compare(C) == 0) {
            return 1;
        } else {
            return 0;
        }
    }
    //Recursive
    //return _interLeave(A,0,s1Len, B,0,s2Len, C,0,s3Len);
    //DP
    return _isInterleaveDP(A,s1Len, B,s2Len, C,s3Len);
}"
Word Break II,https://www.interviewbit.com/problems/word-break-ii/,Google,Dynamic Programming,medium,"Given a string A and a dictionary of words B, add spaces in A to construct a sentence where each word is a valid dictionary word.

Return all such possible sentences.

Note : Make sure the strings are sorted in your result.

Input Format:

The first argument is a string, A.
The second argument is an array of strings, B.
Output Format:

Return a vector of strings representing the answer as described in the problem statement.
Constraints:

1 <= len(A) <= 50
1 <= len(B) <= 25
1 <= len(B[i]) <= 20
Examples:

Input 1:
    A = ""b""
    B = [""aabbb""]

Output 1:
    []

Input 1:
    A = ""catsanddog"",
    B = [""cat"", ""cats"", ""and"", ""sand"", ""dog""]

Output 1:
    [""cat sand dog"", ""cats and dog""]","vector<string> Solution::wordBreak(string A, vector<string> &B) {
    unordered_set<string> dict(B.begin(), B.end());
            vector<vector<string> > words(A.length() + 1, vector<string>(0));

            
            words[A.length()].push_back("""");
            for(int i = A.length() - 1; i >= 0; i--) {
                vector<string> values;
                for(int j = i + 1; j <= A.length(); j++) {
                    if (dict.find(A.substr(i, j - i)) != dict.end()) {
                        for (int k = 0; k < words[j].size(); k++) {
                            values.push_back(A.substr(i, j - i) + (words[j][k].empty() ? """" : "" "") + words[j][k]);
                        }
                    }
                }
                words[i] = values;
            }
            return words[0];
    
}"
Longest valid Parentheses,https://www.interviewbit.com/problems/longest-valid-parentheses/,Google,"
Dynamic Programming",medium,"Given a string A containing just the characters ’(‘ and ’)’.

Find the length of the longest valid (well-formed) parentheses substring.




Input Format:

The only argument given is string A.
Output Format:

Return the length of the longest valid (well-formed) parentheses substring.
Constraints:

1 <= length(A) <= 750000
For Example

Input 1:
    A = ""(()""
Output 1:
    2
    Explanation 1:
        The longest valid parentheses substring is ""()"", which has length = 2.

Input 2:
    A = "")()())""
Output 2:
    4
    Explanation 2:
        The longest valid parentheses substring is ""()()"", which has length = 4.","int Solution::longestValidParentheses(string A) {
    int n = A.length();
    if (n <= 1) {
        return 0;
    }
    int ret = 0, i = 0, j = 0;
    std::vector<int> table(n+1,0);
    for (i = 1; i <= n; ++i) {
        j = i - 2 - table[i-1];
        if (A[i-1] == '(' || j < 0 || A[j] == ')') {
            table[i] = 0;
        } else {
            table[i] = table[i-1]+2+table[j];
            ret = max(ret, table[i]);
        }
    }
    return ret;
}"
Stairs,https://www.interviewbit.com/problems/stairs/,Amazon,Dynamic Programming,easy,"You are climbing a stair case and it takes A steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?



Input Format:

The first and the only argument contains an integer A, the number of steps.
Output Format:

Return an integer, representing the number of ways to reach the top.
Constrains:

1 <= A <= 36
Example :

Input 1:

A = 2 Output 1:

2 Explanation 1:

[1, 1], [2] Input 2:

A = 3 Output 2:

3 Explanation 2: 

[1 1 1], [1 2], [2 1]","int Solution::climbStairs(int n) {
    if (n <= 0) return 0;  
   if (n == 1 || n == 2) return n;  
   return climbStairs(n-1) + climbStairs(n-2);  
}"
Swap List Nodes in pairs,https://www.interviewbit.com/problems/swap-list-nodes-in-pairs/,"Moonfrog Labs, Amazon, Microsoft",Linked Lists,easy,"Problem Description
 
 

Given a linked list A, swap every two adjacent nodes and return its head.

NOTE: Your algorithm should use only constant space. You may not modify the values in the list; only nodes themselves can be changed.



Problem Constraints
 1 <= |A| <= 106 



Input Format
 The first and the only argument of input contains a pointer to the head of the given linked list. 



Output Format
 Return a pointer to the head of the modified linked list. 



Example Input
 Input 1: 

 A = 1 -> 2 -> 3 -> 4
 Input 2: 

 A = 7 -> 2 -> 1


Example Output
 Output 1: 

 2 -> 1 -> 4 -> 3
 Output 2: 

 2 -> 7 -> 1


Example Explanation
Explanation 1:

 In the first example (1, 2) and (3, 4) are the adjacent nodes. Swapping them will result in 2 -> 1 -> 4 -> 3
Explanation 2:

 In the second example, 3rd element i.e. 1 does not have an adjacent node, so it won't be swapped. 
","/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
 
     ListNode* swap1(ListNode* next1, ListNode* next2) {
        next1->next = next2->next;
        next2->next = next1;
        return next2;
}
ListNode* Solution::swapPairs(ListNode *head) {
        ListNode* start = new ListNode(0); //make head no longer a special case
        start->next = head;

        ListNode *cur = start;
        while (cur->next != NULL && cur->next->next != NULL) {
            cur->next = swap1(cur->next, cur->next->next);
            cur = cur->next->next;
        }
        return start->next;
    }"
Rotate List,https://www.interviewbit.com/problems/rotate-list/,Amazon,Linked Lists,medium,"Problem Description
 
 

Given a list, rotate the list to the right by k places, where k is non-negative.


Problem Constraints
1 <= B <= 109


Input Format
The first argument is ListNode A, pointing to the head of the list.
The second argument is an integer B, representing the value of k.


Output Format
Return the rotated list.


Example Input
A = 1->2->3->4->5->NULL
B = 2


Example Output
4->5->1->2->3->NULL


Example Explanation
Given list: A = 1->2->3->4->5->NULL
Given B = 2;
After rotating A once, A = 5->1->2->3->4->NULL
After rotating A again, A = 4->5->1->2->3->NULL
Hence after rotating the given list A, for B = 2, return 4->5->1->2->3->NULL","/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
ListNode* Solution::rotateRight(ListNode* A, int B) {
    ListNode* ret, *curr, *prev;
    int temp, length = 0;
    curr = A;
    prev = A;
    while(curr) {
        ++length;
        curr = curr->next;
    }
    if (length == 0 || B%length == 0) {
        return A;
    }
    curr = A;
    temp = B%length;
    while(temp-- > 0 ) {
        curr = curr->next;
    }
    while (curr->next) {
        curr = curr->next;
        prev = prev->next;
    }
    ret = prev->next;
    prev->next = NULL;
    curr->next = A;
    return ret;
}"
Reorder List,https://www.interviewbit.com/problems/reorder-list/,"Amazon, Microsoft",Linked Lists,hard,"Given a singly linked list

    L: L0 ? L1 ? … ? Ln-1 ? Ln,
reorder it to:

    L0 ? Ln ? L1 ? Ln-1 ? L2 ? Ln-2 ? …
You must do this in-place without altering the nodes’ values.

For example,

Given {1,2,3,4}, reorder it to {1,4,2,3}.","/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
ListNode* Solution::reorderList(ListNode* A) {
    if (!A || !A->next) {
        return A;
    }
    ListNode *slow = A, *fast = A;
    while (fast && fast->next && fast->next->next) {
        slow = slow->next;
        fast = fast->next->next;
    }
    ListNode *secondHalf = slow->next;
    ListNode *firstHalf = A;
    slow->next = NULL;
    ListNode *curr = secondHalf, *prev = NULL, *next, *temp1, *temp2;
    while (curr) {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }
    secondHalf = prev;
    while (secondHalf) {
        temp1 = firstHalf->next;
        temp2 = secondHalf->next;
        firstHalf->next = secondHalf;
        secondHalf->next = temp1;
        firstHalf = temp1;
        secondHalf = temp2;
    }
    return A;
}"
Sort List,https://www.interviewbit.com/problems/sort-list/,"Google, Zenefits",Linked Lists,medium,"Sort a linked list in O(n log n) time using constant space complexity.

Example :

Input : 1 -> 5 -> 4 -> 3

Returned list : 1 -> 3 -> 4 -> 5","/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
 
/* See http://geeksforgeeks.org/?p=3622 for details of this 
   function */
ListNode* SortedMerge(ListNode* a, ListNode* b)
{
  ListNode* result = NULL;
 
  /* Base cases */
  if (a == NULL)
     return(b);
  else if (b==NULL)
     return(a);
 
  /* Pick either a or b, and recur */
  if (a->val <= b->val)
  {
     result = a;
     result->next = SortedMerge(a->next, b);
  }
  else
  {
     result = b;
     result->next = SortedMerge(a, b->next);
  }
  return(result);
}
 
ListNode* Solution::sortList(ListNode* A) {
    if (!A || !A->next) return A;
    
    ListNode *head, *a, *b, *slow, *fast, *ret;
    head = A;
    
    slow = head;
    fast = head->next;
    while (fast) {
        fast = fast->next;
        if (fast) {
            slow = slow->next;
            fast = fast->next;
        }
    }
    a = head;
    b = slow->next;
    slow->next = NULL;
    
    a = sortList(a);
    b = sortList(b);
    
    if (!a) {
        return b;
    }
    if (!b) {
        return a;
    }
    return SortedMerge(a,b);
}"
Remove Duplicates from Sorted List II,https://www.interviewbit.com/problems/remove-duplicates-from-sorted-list-ii/,Microsoft,Linked Lists,medium,"Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.

For example,

Given 1->2->3->3->4->4->5, return 1->2->5.

Given 1->1->1->2->3, return 2->3.","/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
ListNode* Solution::deleteDuplicates(ListNode* A) {
    if (!A && !A->next) {
        return A;
    }
    ListNode *pre = new ListNode(0);
    pre->next = A;
    A = pre;
    ListNode *temp = A, *temp1;
    while (temp->next) {
        temp1 = temp->next;
        while (temp1->next && temp1->val == temp1->next->val) {
            temp1 = temp1->next;
        }
        if (temp1 != temp->next) {
            temp->next = temp1->next;
        } else {
            temp = temp->next;
        }
    }
    return A->next;
}"
Merge Two Sorted Lists,https://www.interviewbit.com/problems/merge-two-sorted-lists/,"Microsoft, Amazon, Yahoo",Linked Lists,easy,"Merge two sorted linked lists and return it as a new list. 

The new list should be made by splicing together the nodes of the first two lists, and should also be sorted.

For example, given following linked lists :

  5 -> 8 -> 20 
  4 -> 11 -> 15
The merged list should be :

4 -> 5 -> 8 -> 11 -> 15 -> 20","/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
ListNode* Solution::mergeTwoLists(ListNode* A, ListNode* B) {
    ListNode *ret, *temp, *rettemp;
    if (!A) {
        return B;
    }
    if (!B) {
        return A;
    }
    if (A->val <= B->val) {
        ret = new ListNode(A->val);
        A = A->next;
    } else {
        ret = new ListNode(B->val);
        B = B->next;
    }
    
    temp = ret;
    while (A&&B) {
        if (A->val <= B->val) {
            temp->next = new ListNode(A->val);
            A = A->next;
        } else {
            temp->next = new ListNode(B->val);
            B = B->next;
        }
        temp = temp->next;
    }
    while (A) {
        temp->next = new ListNode(A->val);
        A = A->next;
        temp = temp->next;
    }
    while (B) {
        temp->next = new ListNode(B->val);
        B = B->next;
        temp = temp->next;
    }
    
    return ret;
}"
Remove Duplicates from Sorted List,https://www.interviewbit.com/problems/remove-duplicates-from-sorted-list/,"Amazon, Microsoft",Linked Lists,easy,"Given a sorted linked list, delete all duplicates such that each element appear only once.

For example,

Given 1->1->2, return 1->2.

Given 1->1->2->3->3, return 1->2->3.","/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
ListNode* Solution::deleteDuplicates(ListNode* A) {
    ListNode *temp = A, *temp1;
    while (temp) {
        temp1 = temp;
        while (temp1->next && temp->val == temp1->next->val) {
            temp1 = temp1->next;
        }
        temp->next = temp1->next;
        temp = temp->next;
    }
    return A;
}"
Add Two Numbers as Lists,https://www.interviewbit.com/problems/add-two-numbers-as-lists/,"Amazon, Microsoft, Facebook",Linked Lists,medium,"You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)

Output: 7 -> 0 -> 8

    342 + 465 = 807
Make sure there are no trailing zeros in the output list

So, 7 -> 0 -> 8 -> 0 is not a valid response even though the value is still 807.","/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
ListNode* Solution::addTwoNumbers(ListNode* A, ListNode* B) {
    int carry = 0, temp;
    ListNode* ret = NULL, *tempNode = NULL, *prev = NULL;
    assert(A!= NULL || B != NULL);
    /*
    if (!A) {
        return B;
    }
    if (!B) {
        return A;
    }
    */
    ListNode *tmp = A;
    tmp = tmp -> next;
    
    while(tmp!= NULL){
        if(tmp->next == NULL)
            assert(tmp->val != 0);
        tmp = tmp -> next;    
    }
    
    tmp = B;
    tmp = tmp -> next;
    
    while(tmp!= NULL){
        if(tmp->next == NULL)
            assert(tmp->val != 0);
        tmp = tmp -> next;    
    }
    
    while(A || B) {
        temp = carry + (A?A->val:0) + (B?B->val:0);
        carry = temp/10;
        temp = temp%10;
        tempNode = new ListNode(temp);
        
        if (ret) {
            prev->next = tempNode;
        } else {
            ret = tempNode;
        }
        prev = tempNode;
        if (A) A = A->next;
        if (B) B = B->next;
    }
    if (carry > 0) {
        tempNode->next = new ListNode(carry);
    }
    return ret;
    
}"
Remove Nth Node from List End,https://www.interviewbit.com/problems/remove-nth-node-from-list-end/,Amazon,Linked Lists,easy,"Problem Description
 
 

Given a linked list A, remove the B-th node from the end of the list and return its head.

For example, Given linked list: 1->2->3->4->5, and B = 2. After removing the second node from the end, the linked list becomes 1->2->3->5.

NOTE: If B is greater than the size of the list, remove the first node of the list.

NOTE: Try doing it using constant additional space.



Problem Constraints
 1 <= |A| <= 106 



Input Format
 The first argument of input contains a pointer to the head of the linked list. 

 The second argument of input contains the integer B. 



Output Format
 Return the head of the linked list after deleting the B-th element from the end. 



Example Input
 Input 1: 

A = [1, 2, 3, 4, 5]
B = 2
 Input 2: 

A = [1]
B = 1


Example Output
 Output 1: 

[1, 2, 3, 5]
 Output 2: 

 [] 


Example Explanation
Explanation 1:

In the first example, 4 is the second last element.
Explanation 2:

In the second example, 1 is the first and the last element.","/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
ListNode* Solution::removeNthFromEnd(ListNode* A, int B) {
    ListNode *curr = A, *prev = A;
    while (B-- > 0 && curr) {
        curr = curr->next;
    }
    if (!curr) {
        return A->next;
    }
    while (curr->next) {
        curr = curr->next;
        prev = prev->next;
    }
    prev->next = prev->next->next;
    return A;
}"
Reverse Linked List,https://www.interviewbit.com/problems/reverse-linked-list/,N/A,Linked Lists,easy,"Reverse a linked list. Do it in-place and in one-pass.

For example:

Given 1->2->3->4->5->NULL,

return 5->4->3->2->1->NULL.

PROBLEM APPROACH :

Complete solution code in the hints","/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
ListNode* Solution::reverseList(ListNode* A) {
    ListNode *revA = NULL, *nextA;
    while (A) {
        nextA = A->next;
        A->next = revA;
        revA = A;
        A = nextA;
    }
    return revA;
}"
Partition List,https://www.interviewbit.com/problems/partition-list/,Microsoft,Linked Lists,medium,"Problem Description
 
 

 Given a linked list A and a value B, partition it such that all nodes less than B come before nodes greater than or equal to B. 

 You should preserve the original relative order of the nodes in each of the two partitions. 



Problem Constraints
 1 <= |A| <= 106 

 1 <= A[i], B <= 109 



Input Format
 The first argument of input contains a pointer to the head to the given linked list. 

 The second argument of input contains an integer, B. 



Output Format
 Return a pointer to the head of the modified linked list. 



Example Input
 Input 1: 

A = [1, 4, 3, 2, 5, 2]
B = 3
 Input 2: 

A = [1, 2, 3, 1, 3]
B = 2


Example Output
 Output 1: 

[1, 2, 2, 4, 3, 5]
 Output 2: 

[1, 1, 2, 3, 3]


Example Explanation
Explanation 1:

 [1, 2, 2] are less than B wheread [4, 3, 5] are greater than or equal to B.
Explanation 2:

 [1, 1] are less than B wheread [2, 3, 3] are greater than or equal to B.
","/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
ListNode* Solution::partition(ListNode* A, int B) {
    if (!A) return A;
    
    ListNode *fake1 = new ListNode(0);
    ListNode *fake2 = new ListNode(0);
    fake1->next = A;
    
    ListNode *p = A, *prev = fake1, *p2 = fake2;
    
    while (p) {
        if (p->val < B) {
            p = p->next;
            prev = prev->next;
        } else {
            p2->next = p;
            prev->next = p->next;
            
            p = prev->next;
            p2 = p2->next;
        }
    }
    p2->next = NULL;
    prev->next = fake2->next;
    
    return fake1->next;
    ListNode *i, *j, *toDelNode;
    int temp;
    i = A, j = A;
    while (i && j && j->next) {
        if (j->next->val < B) {
            toDelNode = j->next;
            j->next = toDelNode->next;
            toDelNode->next = i;
            i->next = toDelNode;
            i = i->next;
        }
        if (j) {
            j = j->next;
        }
    }
    return A;
}"
Insertion Sort List,https://www.interviewbit.com/problems/insertion-sort-list/,"Microsoft, Google",Linked Lists,medium,"Sort a linked list using insertion sort.

We have explained Insertion Sort at Slide 7 of Arrays

Insertion Sort Wiki has some details on Insertion Sort as well.

Example :

Input : 1 -> 3 -> 2

Return 1 -> 2 -> 3","/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
ListNode* Solution::insertionSortList(ListNode* A) {
    if (!A || !A->next) return A;
    
    ListNode *newHead = new ListNode(A->val);
    ListNode *it = A->next;
    ListNode *it_inner, *next, *oldHead, *oldNext;
    while (it) {
        it_inner = newHead;
        next = it->next;
        if (it->val <= newHead->val) {
            oldHead = newHead;
            newHead = it;
            newHead->next = oldHead;
        } else {
            while (it_inner->next) {
                if (it->val > it_inner->val && it->val <= it_inner->next->val) {
                    oldNext = it_inner->next;
                    it_inner->next = it;
                    it->next = oldNext;
                }
                it_inner = it_inner->next;
            }
            if (!it_inner->next && it->val > it_inner->val) {
                it_inner->next = it;
                it->next = NULL;
            }
        }
        it = next;
    }
    return newHead;
}"
List Cycle,https://www.interviewbit.com/problems/list-cycle/,"Amazon, Microsoft",Linked Lists,medium,"Problem Description

Given a linked list, return the node where the cycle begins. If there is no cycle, return null.

Try solving it using constant additional space.

Example:

Input: 


              ______
             |     |
             \/    |
    1 -> 2 -> 3 -> 4


Return the node corresponding to node 3. 

","ListNode* Solution::detectCycle(ListNode* A) {
    ListNode *hare = A, *turtle = A;
    int loopLength = 0;
    
    while (hare && turtle && hare->next) {
        turtle = turtle->next;
        hare = hare->next->next;
        if (hare == turtle) {
            // Found loop
            while (hare->next != turtle) {
                hare = hare->next;
                ++loopLength;
            }
            ++loopLength;
            hare = A;
            while (loopLength > 0) {
                hare = hare->next;
                --loopLength;
            }
            while (A != hare) {
                A = A->next;
                hare = hare->next;
            }
            return A;
        }
    }
    return NULL;
}"
Intersection of Linked Lists,https://www.interviewbit.com/problems/intersection-of-linked-lists/,"Amazon, Microsoft",Linked Lists,easy,"Write a program to find the node at which the intersection of two singly linked lists begins.

For example, the following two linked lists:


A:          a1 ? a2
                   ?
                     c1 ? c2 ? c3
                   ?
B:     b1 ? b2 ? b3

begin to intersect at node c1.

Notes:

If the two linked lists have no intersection at all, return null.
The linked lists must retain their original structure after the function returns.
You may assume there are no cycles anywhere in the entire linked structure.
Your code should preferably run in O(n) time and use only O(1) memory.","/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
ListNode* Solution::getIntersectionNode(ListNode* A, ListNode* B) {
    int lenA = 0, lenB = 0, tempLen, j;
    ListNode *A_temp = A;
    ListNode *B_temp = B;
    ListNode *temp;
    while (A_temp) {
        ++lenA;
        A_temp = A_temp->next;
    }
    while (B_temp) {
        ++lenB;
        B_temp = B_temp->next;
    }
    if (lenA > lenB) {
        tempLen = lenA;
        lenA = lenB;
        lenB = tempLen;
        temp = A;
        A = B;
        B = temp;
    }
    j = 0;
    while (j < lenB - lenA) {
        B = B->next;
        ++j;
    }
    while (A && B) {
        if (A == B) {
            return A;
        } else {
            A = A->next;
            B = B->next;
        }
    }
    return NULL;
}"
Reverse Link List II,https://www.interviewbit.com/problems/reverse-link-list-ii/,"Facebook, Microsoft, Amazon",Linked Lists,medium,"Reverse a linked list from position m to n. Do it in-place and in one-pass.

For example:

Given 1->2->3->4->5->NULL, m = 2 and n = 4,

return 1->4->3->2->5->NULL.

Note:

Given m, n satisfy the following condition:

1 ? m ? n ? length of list.

Note 2:

Usually the version often seen in the interviews is reversing the whole linked list which is obviously an easier version of this question.","/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
ListNode* Solution::reverseBetween(ListNode* A, int m, int n) {
    ListNode* newHead = new ListNode(-1);
    int i;
    newHead->next = A;
    ListNode* prev = newHead;
    for(i = 0 ; i < m-1 ; i++){
        prev = prev->next;
    }
    ListNode* reversedPrev = prev;
    //position m
    prev = prev->next;
    ListNode* cur = prev->next;
    for(i = m ; i < n ; i++){
        prev->next = cur->next;
        cur->next = reversedPrev->next;
        reversedPrev->next = cur;
        cur = prev->next;
    }
    return newHead->next;
            /*
    ListNode *newHead = new ListNode(0);
    newHead->next = A;
    ListNode *mPtr = newHead, *nPtr = newHead;
    ListNode *revA = NULL, *nextA;
    
    while (m-- > 0) {
        mPtr = mPtr->next;
    }
    revA = mPtr;
    mPtr = mPtr->next;
    
    while (n > 0) {
        nPtr = nPtr->next;
        --n;
    }
    //cout << mPtr->val << ""; "" << nPtr->val;

    while (mPtr != nPtr) {
        nextA = mPtr->next;
        mPtr->next = revA;
        revA = mPtr;
        mPtr = nextA;
    }
    return A;
    */
}"
Evaluate Expression,https://www.interviewbit.com/problems/evaluate-expression/,"Yahoo, Google, Facebook",Stacks And Queues,easy,"Problem Description
 
 

An arithmetic expression is given by a string array A of size N. Evaluate the value of an arithmetic expression in Reverse Polish Notation.

Valid operators are +, -, *, /. Each string may be an integer or an operator.



Problem Constraints
1 <= N <= 105



Input Format
The only argument given is string array A.



Output Format
Return the value of arithmetic expression formed using reverse Polish Notation.



Example Input
Input 1:
    A =   [""2"", ""1"", ""+"", ""3"", ""*""]
Input 2:
    A = [""4"", ""13"", ""5"", ""/"", ""+""]


Example Output
Output 1:
    9
Output 2:
    6


Example Explanation
Explaination 1:
    starting from backside:
    * : () * ()
    3 : () * (3)
    + : (() + ()) * (3)
    1 : (() + (1)) * (3)
    2 : ((2) + (1)) * (3)
    ((2) + (1)) * (3) = 9
Explaination 2:
    + : () + ()
    / : () + (() / ())
    5 : () + (() / (5))
    13 : () + ((13) / (5))
    4 : (4) + ((13) / (5))
    (4) + ((13) / (5)) = 6","int Solution::evalRPN(vector<string> &tokens) {
    stack<int> st;
            for(int i = 0; i < tokens.size(); ++i) {
                if(tokens[i] == ""+"" || tokens[i] == ""-"" || tokens[i] == ""*"" || tokens[i] == ""/"") {
                    int v1=st.top();
                    st.pop();
                    int v2=st.top();
                    st.pop();
                    switch(tokens[i][0]) {
                        case '+':
                            st.push(v2 + v1);
                            break;
                        case '-':
                            st.push(v2 - v1);
                            break;
                        case '*':
                            st.push(v2 * v1);
                            break;
                        case '/':
                            st.push(v2 / v1);
                            break;
                    }
                } else {
                    st.push(atoi(tokens[i].c_str()));
                }
            }
            return st.top();
}"
Rain Water Trapped,https://www.interviewbit.com/problems/rain-water-trapped/,"Amazon, Microsoft",Stacks And Queues,hard,"Problem Description

Given an integer array A of non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.



Problem Constraints
1 <= |A| <= 100000



Input Format
The only argument given is integer array A.



Output Format
Return the total water it is able to trap after raining.



Example Input
Input 1:

 A = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]
Input 2:

 A = [1, 2]


Example Output
Output 1:

 6
Output 2:

 0


Example Explanation
Explanation 1:

 
 In this case, 6 units of rain water (blue section) are being trapped.
Explanation 2:

 No water is trapped.","int Solution::trap(const vector<int> &A) {
    int len=A.size();
        int min=0,prev=0,i=0,j=len-1,ans=0;
        while(i<=j){
            min=A[i]<=A[j]?i++:j--;
            if(prev>A[min]){
                ans+=prev-A[min];
            }
            else
                prev=A[min];
        }
        return ans;
}"
Generate all Parentheses,https://www.interviewbit.com/problems/generate-all-parentheses/,Amazon,Stacks And Queues,easy,"Problem Description
 
 

Given a string A, containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
Return 0 / 1 ( 0 for false, 1 for true ) for this problem.
Note:  The brackets must close in the correct order, ""()"" and ""()[]{}"" are all valid but ""(]"" and ""([)]"" are not.


Problem Constraints
1 <= |A| <= 106


Input Format
The first and only argument is a string A.


Output Format
Return an integer, 0 / 1 ( 0 for false, 1 for true )


Example Input
Input 1:
A = ""()[]{}""
Input 2:
A = ""([)]""


Example Output
Output 1:
1
Output 1:
0","int Solution::isValid(string A) {
   stack<char> st;
   for(int i=0;i<A.size();i++){
       if(A[i]=='['|| A[i]=='{'|| A[i]=='(') {st.push(A[i]);}
       else if(A[i]==']'|| A[i]=='}'|| A[i]==')'){
           if(st.empty()) return 0;
           if(A[i]==']' && st.top()!='[') return 0;
           if(A[i]=='}' && st.top()!='{') return 0;
           if(A[i]==')' && st.top()!='(') return 0;
           st.pop();
       }
   }
   return st.empty()?1:0;
}"
Largest Rectangle in Histogram,https://www.interviewbit.com/problems/largest-rectangle-in-histogram/,"Google, Facebook, Amazon",Stacks And Queues,hard,"Problem Description
 
 

Given an array of integers A .

A represents a histogram i.e A[i] denotes height of the ith histogram's bar. Width of each bar is 1.

Find the area of the largest rectangle formed by the histogram.



Problem Constraints
1 <= |A| <= 100000

1 <= A[i] <= 1000000000



Input Format
The only argument given is the integer array A.



Output Format
Return the area of largest rectangle in the histogram.



Example Input
Input 1:

 A = [2, 1, 5, 6, 2, 3]
Input 2:

 A = [2]


Example Output
Output 1:

 10
Output 2:

 2


Example Explanation
Explanation 1:

The largest rectangle has area = 10 unit. Formed by A[3] to A[4].
Explanation 2:

Largest rectangle has area 2.","int Solution::largestRectangleArea(vector<int> &A) {
     stack<int> S;  
       A.push_back(0);  
       int sum = 0;  
       for (int i = 0; i < A.size(); i++) {  
            if (S.empty() || A[i] >= A[S.top()]) S.push(i);  
            else {  
                 int tmp = S.top();  
                 S.pop();  
                 sum = max(sum, A[tmp]*(S.empty()? i : i-S.top()-1));  
                 i--;  
            }  
       }  
       return sum;  
}"
Sliding Window Maximum,https://www.interviewbit.com/problems/sliding-window-maximum/,"Google, Walmart Labs, Amazon, Microsoft",Stacks And Queues,medium,"Given an array of integers A.  There is a sliding window of size B which 

is moving from the very left of the array to the very right. 

You can only see the w numbers in the window. Each time the sliding window moves 

rightwards by one position. You have to find the maximum for each window. 

The following example will give you more clarity.

The array A is [1 3 -1 -3 5 3 6 7], and B is 3.

Window position	Max
———————————-	————————-
[1  3  -1] -3  5  3  6  7	3
1 [3  -1  -3] 5  3  6  7	3
1  3 [-1  -3  5] 3  6  7	5
1  3  -1 [-3  5  3] 6  7	5
1  3  -1  -3 [5  3  6] 7	6
1  3  -1  -3  5 [3  6  7]	7
Return an array C, where C[i] is the maximum value of from A[i] to A[i+B-1].

Note: If B > length of the array, return 1 element with the max of the array.




Input Format

The first argument given is the integer array A.
The second argument given is the integer B.
Output Format

Return an array C, where C[i] is the maximum value of from A[i] to A[i+B-1]
For Example

Input 1:
    A = [1, 3, -1, -3, 5, 3, 6, 7]
    B = 3
Output 1:
    C = [3, 3, 5, 5, 6, 7]","vector<int> Solution::slidingMaximum(const vector<int> &A, int B) {
    vector<int> res;
    vector<int> deq(A.size() + 1);
    int front = 0, back = -1;
    for(int i = 0 ; i < A.size(); ++i){
        while(front <= back && A[i] >= A[deq[back]]) back--;
        deq[++back] = i;
        if(deq[front] + B == i) front++;
        if(i + 1 >= B) res.push_back(A[deq[front]]);
    }
    return res;
}"
Simplify Directory Path,https://www.interviewbit.com/problems/simplify-directory-path/,Microsoft,Stacks And Queues,medium,"Problem Description
 
 

Given a string A representing an absolute path for a file (Unix-style).

Return the string A after simplifying the absolute path.

Note:

In Unix-style file system:
A period '.' refers to the current directory.
A double period '..' refers to the directory up a level.
Any multiple consecutive slashes '//' are treated as a single slash '/'.
In Simplified Absolute path:
The path starts with a single slash '/'.
Any two directories are separated by a single slash '/'.
The path doesn't end with trailing slashes '/'.
The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..')
The path will not have whitespace characters.


Problem Constraints
1 <= |A| <= 106


Input Format
The only argument given is string A.


Output Format
Return a string denoting the simplified absolute path for a file (Unix-style).


Example Input
Input 1:
A = ""/home/""
Input 2:
A = ""/a/./b/../../c/""


Example Output
Output 1:
""/home""
Output 2:
""/c""","string Solution::simplifyPath(string path) {
    vector<string>   nameVect;
    string name;

    path.push_back('/');

    for (int i = 0; i < path.size(); i++) {
        if (path[i] == '/') {
            if (name.size() == 0) continue;
            if (name == "".."") {     //special case 1?double dot?pop dir
                if (nameVect.size() > 0) nameVect.pop_back();
            } else if (name == ""."") {//special case 2:singel dot?don`t push
            } else {          
                nameVect.push_back(name);
            }
            name.clear();
        } else {
            name.push_back(path[i]);//record the name
        }
    }

    string result;
    if (nameVect.empty()) return ""/"";
    for (int i = 0; i < nameVect.size(); i++) {
        result.append(""/"" + nameVect[i]);
    }
    return result;
}"
Min Stack,https://www.interviewbit.com/problems/min-stack/,"Adobe, Yahoo, Microsoft, Amazon",Stacks And Queues,medium,"Problem Description
 
 

Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
push(x) -- Push element x onto stack.
pop() -- Removes the element on top of the stack.
top() -- Get the top element.
getMin() -- Retrieve the minimum element in the stack.
Note that all the operations have to be constant time operations.

Questions to ask the interviewer :

Q: What should getMin() do on empty stack? 
A: In this case, return -1.


Q: What should pop do on empty stack? 
A: In this case, nothing. 



Q: What should top() do on empty stack?
A: In this case, return -1

NOTE : If you are using your own declared global variables, make sure to clear them out in the constructor.","class MinStack:
    # @param x, an integer
    # @return an integer
    def push(self, x):
        

    # @return nothing
    def pop(self):
        

    # @return an integer
    def top(self):
        

    # @return an integer
    def getMin(self):
       "
Reverse String,https://www.interviewbit.com/problems/reverse-string/,N/A,Stacks And Queues,easy,"Given a string S, reverse the string using stack.

Example :

Input : ""abc""
Return ""cba""","class Solution:
    # @param A : string
    # @return a strings
    def reverseString(self, A):
        revA = []
        for a in A:
            revA.insert(0,a)
        return ''.join(revA)"
Kth Row of Pascal's Triangle,https://www.interviewbit.com/problems/kth-row-of-pascals-triangle/,Google,Arrays,easy,"Problem Description

Given an index k, return the kth row of the Pascal's triangle.
Pascal's triangle: To generate A[C] in row R, sum up A'[C] and A'[C-1] from previous row R - 1.

Example:

Input : k = 3


Return : [1,3,3,1]

Note: k is 0 based. k = 0, corresponds to the row [1]. 

Note: Could you optimize your algorithm to use only O(k) extra space?
","vector<int> Solution::getRow(int n) {
    vector <int> ans;
    int c = 1;
    for (int i = 1; i <= n+1; i++) {
        ans.push_back(c);
        c = c*(n+1-i) / i;
    }
    return ans;
}"
Rotate Matrix,https://www.interviewbit.com/problems/rotate-matrix/,"Google, facebook, Amazon",Arrays,medium,"Problem Description
 
 

You are given a N x N 2D matrix A representing an image.

Rotate the image by 90 degrees (clockwise).

You need to do this in place. Update the given matrix A.

Note: If you end up using an additional array, you will only receive a partial score.



Problem Constraints
1 <= N <= 1000



Input Format
First argument is a 2D matrix A of integers



Output Format
Rotate the given 2D matrix A.



Example Input
Input 1:

 [
    [1, 2],
    [3, 4]
 ]
Input 2:

 [
    [1]
 ]


Example Output
Output 1:

 [
    [3, 1],
    [4, 2]
 ]
Output 2:

 [
    [1]
 ]


Example Explanation
Explanation 1:

 After rotating the matrix by 90 degree:
 1 goes to 2, 2 goes to 4
 4 goes to 3, 3 goes to 1
Explanation 2:

 2D array remains the ssame as there is only element.","void Solution::rotate(vector<vector<int> > &matrix) {
   reverse(matrix.begin(), matrix.end());
    for(int i = 0; i<matrix.size(); i++) {
        for(int j = i + 1; j<matrix[i].size(); j++) 
            swap(matrix[i][j], matrix[j][i]);
    }
}"
Max Sum Contiguous Subarray,https://www.interviewbit.com/problems/max-sum-contiguous-subarray/,"Paypal, Yahoo, Facebook, Microsoft, Linkedin, Amazon",Arrays,easy,"Problem Description
 
 

Find the contiguous subarray within an array, A of length N which has the largest sum.


Problem Constraints
1 <= N <= 106
-1000 <= A[i] <= 1000


Input Format
The first and the only argument contains an integer array, A.


Output Format
Return an integer representing the maximum possible sum of the contiguous subarray.


Example Input
Input 1:
A = [1, 2, 3, 4, -10]
Input 2:
A = [-2, 1, -3, 4, -1, 2, 1, -5, 4]


Example Output
Output 1:
10
Output 2:
6


Example Explanation
Explanation 1:
The subarray [1, 2, 3, 4] has the maximum possible sum of 10.
Explanation 2:
The subarray [4,-1,2,1] has the maximum possible sum of 6.","int Solution::maxSubArray(const vector<int> &A) {
    int max_so_far = A[0], max_end_here = A[0], i;
    for (i = 1; i < A.size(); ++i) {
        max_end_here = std::max(A[i],max_end_here+A[i]);
        max_so_far = std::max(max_end_here, max_so_far);
    }
    return max_so_far;
}"
Find Duplicate in Array,https://www.interviewbit.com/problems/find-duplicate-in-array/,"Amazon, Microsoft",Arrays,easy,"Problem Description
 
 

Given a read-only array of n + 1 integers between 1 and n, find one number that repeats in linear time using less than O(n) space and traversing the stream sequentially O(1) times.
If there are multiple possible answers ( like in the sample case ), output any one, if there is no duplicate, output -1



Problem Constraints
1 <= |A| <= 105
1 <= Ai <= |A|


Input Format
The first argument is an integer array A.


Output Format
Return the integer that repeats in array A


Example Input
Input 1:
A = [3, 4, 1, 4, 2]
Input 2:
A = [1, 2, 3]
Input 3:
A = [3, 4, 1, 4, 1]


Example Output
Output 1:
4
Output 2:
-1
Output 3:
1


Example Explanation
Explanation 1:
4 repeats itself in the array [3, 4, 1, 4, 2]
Explanation 2:
No number repeats itself in the array [1, 2, 3]
Explanation 3:
1 and 4 repeats itself in the array [3, 4, 1, 4, 1], we can return 1 or 4","int Solution::repeatedNumber(const vector<int> &V) {
    assert(V.size() >= 1 && V.size() <= 1e6);
    for( auto it: V ) assert(it >= 1 && it <= V.size()); 
    if (V.size() <= 1) return -1;
    int valueRange = V.size() - 1; // 1 to N when the size is N+1.
    int range = sqrt(valueRange);
    if (range * range < valueRange) range++;
    int count[range + 1];
    memset(count, 0, sizeof(count));

    for (int i = 0; i < V.size(); i++) {
    count[(V[i] - 1) / range]++;
    }

    int repeatingRange = -1;
    int numRanges = ((valueRange - 1) / range) + 1;
    for (int i = 0; i < numRanges && repeatingRange == -1; i++) {
        if (i < numRanges - 1 || valueRange % range == 0) {
            if (count[i] > range) repeatingRange = i;
        } else {
            if (count[i] > valueRange % range) repeatingRange = i;
        }
    }
    if (repeatingRange == -1) return -1;
    memset(count, 0, sizeof(count));
    for (int i = 0; i < V.size(); i++) {
        if ((V[i] - 1) / range == repeatingRange) count[(V[i] - 1) % range]++;
    }
    for (int i = 0; i < range; i++) {
        if (count[i] > 1) {
            return repeatingRange * range + i + 1;
        }
    }
    return -1;
}"
Merge Intervals,https://www.interviewbit.com/problems/merge-intervals/,"Google, Amazon",Arrays,medium,"Problem Description
 
 

Given a set of non-overlapping intervals and a new interval.

Insert the new interval into the set of intervals (merge if necessary).

You may assume that the intervals were initially sorted according to their start times.
Note: Make sure the returned intervals are also sorted.



Problem Constraints
0 <= |intervals| <= 106
1 <= intervalsi.start < intervalsi.end <= 109
1 <= newInterval.start < newInteval.end <= 109


Input Format
The First argument is an array of Intervals.
The second argument is the new Interval.


Output Format
Return the array of merged intervals.


Example Input
Input 1:
Intervals = [[1,3],[6,9]]
newInterval = [2,5]
Input 2:
Intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]]
newInterval = [4,9]


Example Output
Output 1:
[[1,5],[6,9]]
Output 2:
[1,2],[3,10],[12,16]


Example Explanation
Explanation 1:
Given intervals [1,3],[6,9] insert and merge [2,5] would result in [1,5],[6,9].
Explanation 2:
Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] would result in [1,2],[3,10],[12,16].
This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].","/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
vector<Interval> Solution::insert(vector<Interval> &intervals, Interval newInterval) { 
    vector<Interval> res;
    for (Interval test : intervals) {
        if (newInterval.start > test.end) res.push_back(test);
        else if(test.start > newInterval.end) {
            res.push_back(newInterval);
            newInterval = test;
        } else if (newInterval.start <= test.end || newInterval.end >= test.start) {
            newInterval = Interval(min(test.start, newInterval.start), max(test.end, newInterval.end));
        }
    } 
    res.push_back(newInterval);
    return res;
}"
Spiral Order Matrix I,https://www.interviewbit.com/problems/spiral-order-matrix-i/,"Adobe, Flipkart, Microsoft, Amazon",Arrays,easy,"Problem Description
 
 

Given a matrix of M * N elements (M rows, N columns), return all elements of the matrix in spiral order.


Problem Constraints
1 <= M, N <= 1000


Input Format
The first argument is a matrix A.


Output Format
Return an array of integers representing all elements of the matrix in spiral order.


Example Input
A = 
    [
        [ 1, 2, 3 ],
        [ 4, 5, 6 ],
        [ 7, 8, 9 ]
    ]


Example Output
[1, 2, 3, 6, 9, 8, 7, 4, 5]","vector<int> Solution::spiralOrder(const vector<vector<int> > &A) {
	vector<int> result;
	int r=A.size(), c=A[0].size();
	int r_beg=0,r_end=r,c_beg=0,c_end=c;
    while(r_beg<r_end && c_beg<c_end){
        for(int i=c_beg;i<c_end;i++)
            result.push_back(A[r_beg][i]);
        for(int i=r_beg+1;i<r_end;i++)
            result.push_back(A[i][c_end-1]);
        for(int i=c_end-2;i>=c_beg && (r_end-1-r_beg)>0;i--)
            result.push_back(A[r_end-1][i]);
        for(int i=r_end-2;i>r_beg && (c_end-1-c_beg)>0;i--)
            result.push_back(A[i][c_beg]);
        r_beg++;r_end--;
        c_beg++;c_end--;
    }
	return result;
}"
Repeat and Missing Number Array,https://www.interviewbit.com/problems/repeat-and-missing-number-array/,Amazon,Arrays,medium,"There are certain problems which are asked in the interview to also check how you take care of overflows in your problem.

This is one of those problems.

Please take extra care to make sure that you are type-casting your ints to long properly and at all places. Try to verify if your solution works if number of elements is as large as 105

Food for thought :

Even though it might not be required in this problem, in some cases, you might be required to order the operations cleverly so that the numbers do not overflow.
For example, if you need to calculate n! / k! where n! is factorial(n), one approach is to calculate factorial(n), factorial(k) and then divide them.
Another approach is to only multiple numbers from k + 1 ... n to calculate the result.
Obviously approach 1 is more susceptible to overflows.
You are given a read only array of n integers from 1 to n.

Each integer appears exactly once except A which appears twice and B which is missing.

Return A and B.

Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?

Note that in your output A should precede B.

Example:

Input:[3 1 2 5 3] 

Output:[3, 4] 

A = 3, B = 4","vector<int> Solution::repeatedNumber(const vector<int> &A) {
    vector<int> ret(2);
    long long sumOfA = 0, sumOfA2 = 0;
    long long temp;
    int retA, retB;
    int n = A.size();
    for (int i = 0; i < n; i++) {
        temp = A[i];
        sumOfA += temp;
        sumOfA2 += temp*temp;
        temp = i + 1;
        sumOfA -= temp;
        sumOfA2 -= temp*temp;
    }
    sumOfA2 = sumOfA2/sumOfA;
    retA = (int)((sumOfA + sumOfA2)/2);
    retB = (int)(sumOfA2-retA);
    ret[0] = retA;
    ret[1] = retB;
    return ret;
}"
Merge Overlapping Intervals,https://www.interviewbit.com/problems/merge-overlapping-intervals/,"Fab, Directi, Amazon, Google",Arrays,medium,"Problem Description
 
 

Given a collection of intervals, merge all overlapping intervals.



Problem Constraints
1 <= Total number of intervals <= 100000.



Input Format
First argument is a list of intervals.



Output Format
Return the sorted list of intervals after merging all the overlapping intervals.



Example Input
Input 1:

[1,3],[2,6],[8,10],[15,18]


Example Output
Output 1:

[1,6],[8,10],[15,18]


Example Explanation
Explanation 1:

Merge intervals [1,3] and [2,6] -> [1,6].
so, the required answer after merging is [1,6],[8,10],[15,18].
No more overlapping intervals present.","/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
vector<Interval> Solution::merge(vector<Interval> &A) {
    sort(A.begin(), A.end(), [](Interval l, Interval r){ return l.start<r.start; });
    vector<Interval> ans;
    ans.push_back(A[0]);
    for(int i=1; i<A.size(); i++){
        if(A[i].start<=ans.back().end) ans.back().end = max(ans.back().end, A[i].end);
        else ans.push_back(A[i]);
    }
    return ans;
}"
Set Matrix Zeros,https://www.interviewbit.com/problems/set-matrix-zeros/,"Amazon, Flipkart, Paytm",Arrays,easy,"Problem Description
 
 

Given a matrix, A of size M x N of 0s and 1s. If an element is 0, set its entire row and column to 0.
Note: This will be evaluated on the extra memory used. Try to minimize the space and time complexity.



Problem Constraints
1 <= N, M <= 1000
0 <= A[i][j] <= 1


Input Format
The first and the only argument of input contains a 2-d integer matrix, A, of size M x N.


Output Format
Return a 2-d matrix that satisfies the given conditions.


Example Input
Input 1:
[   [1, 0, 1],
    [1, 1, 1], 
    [1, 1, 1]   ]
Input 2:
[   [1, 0, 1],
    [1, 1, 1],
    [1, 0, 1]   ]


Example Output
Output 1:
[   [0, 0, 0],
    [1, 0, 1],
    [1, 0, 1]   ]
Output 2:
[   [0, 0, 0],
    [1, 0, 1],
    [0, 0, 0]   ]","void Solution::setZeroes(vector<vector<int> > &matrix) {
    int rownum = matrix.size();
    if (rownum == 0)  return;
    int colnum = matrix[0].size();
    if (colnum == 0)  return;

    bool hasZeroFirstRow = false, hasZeroFirstColumn = false;

    // Does first row have zero?
    for (int j = 0; j < colnum; ++j) {
        if (matrix[0][j] == 0) {
            hasZeroFirstRow = true;
            break;
        }
    }

    // Does first column have zero?
    for (int i = 0; i < rownum; ++i) {
        if (matrix[i][0] == 0) {
            hasZeroFirstColumn = true;
            break;
        }
    }

    // find zeroes and store the info in first row and column
    for (int i = 1; i < rownum; ++i) {
        for (int j = 1; j < colnum; ++j) {
            if (matrix[i][j] == 0) {
                matrix[i][0] = 0;
                matrix[0][j] = 0;
            }
        }
    }

    // set zeroes except the first row and column
    for (int i = 1; i < rownum; ++i) {
        for (int j = 1; j < colnum; ++j) {
            if (matrix[i][0] == 0 || matrix[0][j] == 0)  matrix[i][j] = 0;
        }
    }

    // set zeroes for first row and column if needed
    if (hasZeroFirstRow) {
        for (int j = 0; j < colnum; ++j) {
            matrix[0][j] = 0;
        }
    }
    if (hasZeroFirstColumn) {
        for (int i = 0; i < rownum; ++i) {
            matrix[i][0] = 0;
        }
    }
}"
Spiral Order Matrix II,https://www.interviewbit.com/problems/spiral-order-matrix-ii/,"Microsoft, Amazon",Arrays,easy,"Problem Description
 
 

Given an integer A, generate a square matrix filled with elements from 1 to A2 in spiral order and return the generated square matrix.



Problem Constraints
1 <= A <= 1000 



Input Format
First and only argument is integer A


Output Format
 Return a 2-D matrix which consists of the elements added in spiral order.



Example Input
Input 1:

1
Input 2:

2
Input 3:

5


Example Output
Output 1:

[ [1] ]
Output 2:

[ [1, 2], 
  [4, 3] ]
Output 2:

[ [1, 2, 3, 4, 5], 
  [16, 17, 18, 19, 6], 
  [15, 24, 25, 20, 7], 
  [14, 23, 22, 21, 8], 
  [13, 12, 11, 10, 9] ]


Example Explanation
Explanation 1:

Only 1 is to be arranged.
Explanation 2:

1 --> 2
      |
      |
4<--- 3","vector<vector<int> > Solution::generateMatrix(int A) {
    vector< vector<int> > arr(A, vector<int> (A, 0));
    int start,end,i;
    long long int x;
    x=1;
    for(start=0,end=A-1;start<=end;start++,end--)
    {
        for(i=start;i<=end;i++) { arr[start][i]=x; x++;}
        for(i=start+1;i<=end;i++) { arr[i][end]=x; x++;}
        for(i=end-1;i>=start;i--) { arr[end][i]=x; x++;}
        for(i=end-1;i>=start+1;i--) { arr[i][start]=x; x++;}
    }
    return arr;
}"
Largest Number,https://www.interviewbit.com/problems/largest-number/,"Amazon, Microsoft",Arrays,medium,"Problem Description
 
 

Given a list of non-negative integers, arrange them such that they form the largest number.
Note: The result may be very large, so you need to return a string instead of an integer.


Problem Constraints
1 <= |A| <= 105
0 <= Ai <= 109


Input Format
The first argument is an integer array A.


Output Format
Return a string representing the largest number formed


Example Input
A = [3, 30, 34, 5, 9]


Example Output
9534330


Example Explanation
Largest possible number that can be formed is 9534330","bool compareNum(string a, string b) {
    return a + b > b + a;
}
string Solution::largestNumber(const vector < int > & A) {
    string result;
    vector < string > str;
    assert(A.size() >= 1 && A.size() <= 1e5);
    for (int i = 0; i < A.size(); i++) {
        assert(A[i] >= 0 && A[i] <= 1e9);
        str.push_back(to_string(A[i]));
    }
    sort(str.begin(), str.end(), compareNum);
    for (int i = 0; i < str.size(); i++) {
        result += str[i];
    }

    int pos = 0;
    while (result[pos] == '0' && pos + 1 < result.size()) pos++;
    return result.substr(pos);
}"
First Missing Integer,https://www.interviewbit.com/problems/first-missing-integer/,"Microsoft, Walmart, FreeCharge, Amazon, InMobi",Arrays,medium,"Problem Description
 
 

Given an unsorted integer array, find the first missing positive integer.
Your algorithm should run in O(n) time and use constant space.


Problem Constraints
1 <= |A| <= 106
-106 <= Ai <= 106


Input Format
The first argument is an integer array A.


Output Format
Return an integer equal to the first missing positive integer


Example Input
Input 1:
A = [1,2,0]
Input 2:
A = [3,4,-1,1]
Input 3:
A = [-8,-7,-6]


Example Output
Output 1:
3
Output 2:
2
Output 3:
1


Example Explanation
Explanation 1:
3 is the first positive missing integer.
Explanation 2:
2 is the first positive missing integer.
Explanation 3:
1 is the first positive missing integer.","int Solution::firstMissingPositive(vector<int> &A) {
    int n = A.size();
    for (int i = 0; i < n; i++) {
        if (A[i] > 0 && A[i] <= n) {
            int pos = A[i] - 1;
            if (A[pos] != A[i]) {
                swap(A[pos], A[i]);
                i--;
            }
        }
    }
    for (int i = 0; i < n; i++) {
        if (A[i] != i + 1) return (i + 1);
    }
    return n + 1;
}"
Add One To Number,https://www.interviewbit.com/problems/add-one-to-number/,"Google, Microsoft",Arrays,easy,"Problem Description
 
 

Given a non-negative number represented as an array of digits, add 1 to the number ( increment the number represented by the digits ).

The digits are stored such that the most significant digit is at the head of the list.

NOTE: Certain things are intentionally left unclear in this question which you should practice asking the interviewer. For example: 
for this problem, following are some good questions to ask :

Q : Can the input have 0's before the most significant digit. Or in other words, is 0 1 2 3 a valid input?
A : For the purpose of this question, YES
Q : Can the output have 0's before the most significant digit? Or in other words, is 0 1 2 4 a valid output?
A : For the purpose of this question, NO. Even if the input has zeroes before the most significant digit.


Problem Constraints
1 <= |A| <= 106
0 <= Ai <= 9


Input Format
First argument is an array of digits.



Output Format
Return the array of digits after adding one.



Example Input
Input 1:

[1, 2, 3]


Example Output
Output 1:

[1, 2, 4]


Example Explanation
Explanation 1:

Given vector is [1, 2, 3].
The returned vector should be [1, 2, 4] as 123 + 1 = 124.","vector<int> Solution::plusOne(vector<int> &digits) {
    assert(digits.size() >= 1 && digits.size() <= 1e6);
    reverse(digits.begin(), digits.end());
    vector<int> ans;
    int carry = 1;
    for (int i = 0; i < digits.size(); i++) {
        assert(digits[i] >= 0 && digits[i] < 10);
        int sum = digits[i] + carry;
        ans.push_back(sum%10);
        carry = sum / 10;
    }
    while (carry) {
        ans.push_back(carry%10);
        carry /= 10;
    }
    while (ans[ans.size() - 1] == 0 && ans.size() > 1) {
        ans.pop_back();
    }
    reverse(ans.begin(), ans.end());
    reverse(digits.begin(), digits.end());
    return ans;
}"
N/3 Repeat Number,https://www.interviewbit.com/problems/n3-repeat-number/,Google,Arrays,medium,"Problem Description
 
 

You're given a read-only array of N integers. Find out if any integer occurs more than N/3 times in the array in linear time and constant additional space.
If so, return the integer. If not, return -1.

If there are multiple solutions, return any one.



Problem Constraints
1 <= N <= 7*105
1 <= A[i] <= 109


Input Format
The only argument is an integer array A.


Output Format
Return an integer.


Example Input
[1 2 3 1 1]


Example Output
1


Example Explanation
1 occurs 3 times which is more than 5/3 times.","int Solution::repeatedNumber(const vector<int> &A) {
    if(A.size()<3)
        return A[0];
    vector<int> vec;
    vec=A;
    sort(vec.begin(),vec.end());
    int n=A.size()/3;
    for(int i=0;i<n;i++)
    {
        if(vec[i]==vec[n+i])
            return vec[i];
        if(vec[n+i]==vec[n*2+i])
            return vec[n+i];
        if(vec[vec.size()-1-i]==vec[vec.size()-1-i-n])
            return vec[vec.size()-1-i];
    }
    return -1;
}"
Pascal Triangle,https://www.interviewbit.com/problems/pascal-triangle/,"Google, Amazon",Arrays,easy,"Problem Description
 
 

Given an integer A, equal to numRows, generate the first numRows of Pascal's triangle.
Pascal's triangle: To generate A[C] in row R, sum up A'[C] and A'[C-1] from the previous row R - 1.



Problem Constraints
0 <= A <= 25


Input Format
The first argument is an integer A, equal to the numRows.


Output Format
Return an array of array of integers, equal to pascal triangle.


Example Input
A = 5


Example Output
[
     [1],
     [1,1],
     [1,2,1],
     [1,3,3,1],
     [1,4,6,4,1]
]","vector<vector<int> > Solution::solve(int numRows) {
    assert(numRows >= 0 && numRows <= 25);
    vector< vector<int> > ans;
    if (numRows <= 0) { 
        return ans;
    }
    vector<int> tmp; 
    tmp.push_back(1); 
    ans.push_back(tmp);
    for (int i = 0; i < numRows - 1; i++) {
        vector<int> newRow;
        newRow.push_back(1);
        for (int j = 0; j < ans[i].size() - 1; j++) {
            newRow.push_back(ans[i][j] + ans[i][j + 1]);
        }
        newRow.push_back(1);
        ans.push_back(newRow);
    }
    return ans;
}"
Maximum Consecutive Gap,https://www.interviewbit.com/problems/maximum-consecutive-gap/,N/A,Arrays,medium,"Problem Description
 
 

Given an unsorted array, find the maximum difference between the successive elements in its sorted form.
Return 0 if the array contains less than 2 elements.
You may assume that all the elements in the array are non-negative integers and fit in the 32-bit signed integer range.
You may also assume that the difference will not overflow.
Try to solve it in linear time/space



Problem Constraints
1 <= |A| <= 106
1 <= Ai <= 109


Input Format
The first argument is an integer array A.


Output Format
Return an integer representing maximum difference between the successive elements in array A.


Example Input
A = [1, 10, 5]


Example Output
5


Example Explanation
The maximum difference is between 5 and 10, which is 5.","int Solution::maximumGap(const vector<int> &num) {
    if(num.empty() || num.size() < 2)
        return 0;
    int maxNum = *max_element(num.begin(), num.end());
    int minNum = *min_element(num.begin(), num.end());
    //average gap from minNum to maxNum.
    int gap = (maxNum - minNum - 1) / (num.size() - 1) + 1;

    //number of buckets = num.size() - 1
    vector<int> bucketsMin(num.size() - 1, INT_MAX);
    vector<int> bucketsMax(num.size() - 1, INT_MIN);
    //put into buckets
    for (int i = 0; i < num.size(); i++) {
        if (num[i] != maxNum && num[i] != minNum)
        {
            int buckInd = (num[i] - minNum) / gap;
            bucketsMin[buckInd] = min(bucketsMin[buckInd], num[i]);
            bucketsMax[buckInd] = max(bucketsMax[buckInd], num[i]);
        }
    }
    int maxGap = INT_MIN;
    int previous = minNum;
    for (int i = 0; i < num.size() - 1; i++) {
        if (bucketsMin[i] == INT_MAX && bucketsMax[i] == INT_MIN)
            continue;   //empty
        //i_th gap is minvalue in i+1_th bucket minus maxvalue in i_th bucket 
        maxGap = max(maxGap, bucketsMin[i] - previous);
        previous = bucketsMax[i];
    }
    maxGap = max(maxGap, maxNum - previous);
    return maxGap;
}"
Max Distance,https://www.interviewbit.com/problems/max-distance/,"Google, Amazon, Microsoft",Arrays,medium,"Problem Description
 
 

Given an array A of integers, find the maximum of j - i subjected to the constraint of A[i] <= A[j].



Problem Constraints
1 <= |A| <= 106
-109 <= Ai <= 109


Input Format
First and only argument is an integer array A.



Output Format
Return an integer denoting the maximum value of j - i;



Example Input
Input 1:

 A = [3, 5, 4, 2]


Example Output
Output 1:

 2


Example Explanation
Explanation 1:

 Maximum value occurs for pair (3, 4).","int Solution::maximumGap(const vector<int> &A) {
    int maxdis=-1;
    int i,j;
    int sz=A.size();
    int *lmin= new int[sz];
    int *rmax= new int[sz];
    lmin[0]=A[0];
    for(i=1;i<sz;i++)
        lmin[i]=min(A[i],lmin[i-1]);
    rmax[sz-1]=A[sz-1];
    for(i=sz-2;i>=0;i--)
        rmax[i]=max(A[i],rmax[i+1]);
    
    i=0;j=0;
    while(i<sz && j<sz)
    {
        if(lmin[i]<=rmax[j])
        {
            maxdis=max(maxdis,j-i);
            j++;
        }
        else
            i++;
    }
    return maxdis;
}"
Next Permutation,https://www.interviewbit.com/problems/next-permutation/,"Microsoft, Amazon",Arrays,medium,"Problem Description
 
 

Implement the next permutation, which rearranges numbers into the numerically next greater permutation of numbers for a given array A of size N.

If such an arrangement is not possible, it must be rearranged in the lowest possible order i.e., sorted in ascending order.

Note:
The replacement must be in-place, do not allocate extra memory.
DO NOT USE LIBRARY FUNCTION FOR NEXT PERMUTATION. Use of Library functions will disqualify your submission retroactively and will give you penalty points.


Problem Constraints
1 <= N <= 5e5
1 <= A[i] <= 1e9


Input Format
The first and the only argument of input has an array of integers, A.


Output Format
Return an array of integers, representing the next permutation of the given array.


Example Input
Input 1:
    A = [1, 2, 3]
Input 2:
    A = [3, 2, 1]
Input 3:
    A = [1, 1, 5]
Input 4:
    A = [20, 50, 113]


Example Output
Output 1:
    [1, 3, 2]
Output 2:
    [1, 2, 3]
Output 3:
    [1, 5, 1]
Output 4:
    [20, 113, 50]","void Solution::nextPermutation(vector<int> &A) {
  next_permutation(A.begin(),A.end());
}"
Palindrome Integer,https://www.interviewbit.com/problems/palindrome-integer/,N/A,Math,easy,"Problem Description
 
 

Determine whether an integer is a palindrome. Do this without extra space.

A palindrome integer is an integer x for which reverse(x) = x where reverse(x) is x with its digit reversed. Negative numbers are not palindromic.



Problem Constraints
INT_MIN <= A <= INT_MAX


Input Format
The first argument is an integer A.


Output Format
Return 1 if A is a Palindrome Integer else return 0.


Example Input
Input 1:
A = 12121
Input 2:
A = 123


Example Output
Output 1:
1
Output 2:
0


Example Explanation
Explanation 1:
 12121 when reversed will be 12121, and 12121 = 12121, hence a palindrome number.

Explanation 2:
 123 when reversed will be 321, and 123 != 321, hence not a palindrome number","int Solution::isPalindrome(int A) {
    assert(A >= INT_MIN && A <= INT_MAX);
    string a = to_string(A);
    string b = a;
    reverse(b.begin(), b.end());
    if(a == b) return 1;
    else return 0;
}"
Verify Prime,https://www.interviewbit.com/problems/verify-prime/,N/A,Math,easy,"Given a number N, verify if N is prime or not.

Return 1 if N is prime, else return 0.

Example :

Input : 7
Output : True
Problem Approach:

VIDEO : https://www.youtube.com/watch?v=7VPA-HjjUmU","int Solution::isPrime(int A) {
    if(A==1) return 0;
    for(int i=2 ; i*i<=A ; i++)
        if(A%i==0) return 0;
    return 1;
}"
Excel Column Number,https://www.interviewbit.com/problems/excel-column-number/,Amazon,Math,easy,"Problem Description
 
 

Given a column title A as appears in an Excel sheet, return its corresponding column number.



Problem Constraints
1 <= |A| <= 100



Input Format
First and only argument is string A.



Output Format
Return an integer



Example Input
Input 1:

 ""A""
Input 2:

 ""AB""


Example Output
Output 1:

 1
Output 2:

 28


Example Explanation
Explanation 1:

 A -> 1
Explanation 2:

A  -> 1
B -> 2
C -> 3
...
Z -> 26
AA -> 27
AB -> 28 ","int Solution::titleToNumber(string A) {
int res=0;
for (const auto& c:A) {res =res*26+c +1 - 'A';}return res;
}"
Prime Numbers,https://www.interviewbit.com/problems/prime-numbers/,N/A,Math,easy,"Problem Description
 
 

Given a number A, find all prime numbers up to A (A included).
Make sure the returned array is sorted.


Problem Constraints
1 <= A <= 106


Input Format
The first argument is an integer A.


Output Format
Return array of integers.


Example Input
A = 7


Example Output
[2, 3, 5, 7]


Example Explanation
All primes till 7 are, 2, 3, 5 and 7","vector<int> Solution::sieve(int A) 
{
    int n=A;
    int i,j;
    
    vector<bool>v(n+1);
    vector<int>m;
    for(i=0;i<=n;i++)
        v[i]=true;
    for(i=2;i<=n;i++)
    {
        if(v[i])
        {
            m.push_back(i);
            for(j=2;i*j<=n;j++)
            {
                //if(j!=i)
                    v[i*j]=false;
            }
        }
    }
    //free(v);
    return m;
} "
Grid Unique Paths,https://www.interviewbit.com/problems/grid-unique-paths/,"Google, Amazon, Microsoft, Adobe",Math,medium,"A robot is located at the top-left corner of an A x B grid (marked ‘Start’ in the diagram below).

Path Sum: Example 1

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).

How many possible unique paths are there?

Note: A and B will be such that the resulting answer fits in a 32 bit signed integer.

Example :

Input : A = 2, B = 2
Output : 2

2 possible routes : (0, 0) -> (0, 1) -> (1, 1) 
              OR  : (0, 0) -> (1, 0) -> (1, 1)","int Solution::uniquePaths(int A, int B) {
    long long ans = 1;
        for (int i = B; i < (A + B - 1); i++) {
            ans *= i;
            ans /= (i - B + 1);
        }
        return (int)ans;
}"
Binary Representation,https://www.interviewbit.com/problems/binary-representation/,N/A,Math,easy,"Given a number N >= 0, find its representation in binary.

Example:

if N = 6,

binary form = 110","string Solution::findDigitsInBinary(int A) {
    if(A == 0) return ""0"";
    string sol = """";
    while(A > 0) sol = (char)((A&1)+'0') + sol, A >>= 1;
    return sol;
}"
Trailing Zeros in Factorial,https://www.interviewbit.com/problems/trailing-zeros-in-factorial/,Microsoft,Math,medium,"Problem Description
 
 

Given an integer A, return the number of trailing zeroes in A!.

Note: Your solution should be in logarithmic time complexity.



Problem Constraints
0 <= A <= 10000000



Input Format
First and only argumment is integer A.



Output Format
Return an integer, the answer to the problem.



Example Input
Input 1:

 A = 4
Input 2:

 A = 5


Example Output
Output 1:

 0
Output 2:

 1


Example Explanation
Explanation 1:

 4! = 24
Explanation 2:

 5! = 120","int Solution::trailingZeroes(int A) {
    int n = A;
    return n/5+n/25+n/125+n/625+n/3125+n/15625+n/78125+n/390625+n/1953125+n/9765625+n/48828125+n/244140625+n/1220703125;
}"
All Factors,https://www.interviewbit.com/problems/all-factors/,N/A,Math,easy,"Problem Description
 
 

Given a number A, find all factors of A.


Problem Constraints
1 <= A <= 109


Input Format
The first argument is an integer A.


Output Format
Return an array of all factors of A.


Example Input
A = 6


Example Output
[1, 2, 3, 6]


Example Explanation
For the given A = 6, its factors are 1, 2, 3, and 6, hence returning an array of them.","vector<int> Solution::allFactors(int A) {
     
    vector<int> v;
    
    for(int i=1;i*i<=A;i++) if(A%i==0) {if(i*i!=A){v.push_back(i);v.push_back(A/i);}else{v.push_back(i);}}
    sort(v.begin(),v.end());
    return v;
}"
Monkeys and Doors,https://www.interviewbit.com/problems/monkeys-and-doors/,Amazon,Puzzles,easy,"There are 100 doors, all closed. 

In a nearby cage are 100 monkeys.

The first monkey is let out and runs along the doors opening every one. 

The second monkey is then let out and runs along the doors closing the 2nd, 4th, 6th,…  - all the even-numbered doors. 

The third monkey is let out. He attends only to the 3rd, 6th, 9th,… doors (every third door, in other words), closing any that is open and opening any that is closed, and so on. 

After all 100 monkeys have done their work in this way, what state are the doors in after the last pass?

Answer with the number of open doors.

Answer is an integer.  Just put the number without any decimal places if it’s an integer. If the answer is Infinity, output Infinity.

Feel free to get in touch with us if you have any questions","Consider door number 56. Monkeys will visit it for every divisor it has. So 56 has 1 & 56, 2 & 28, 4 & 14, 7 & 8.
So on pass 1 1st monkey will open the door, pass 2 2nd one will close it, pass 4 open, pass 7 close, pass 8 open, pass 14 close, pass 28 open, pass 56 close. 
For every pair of divisors, the door will end up back in its initial state. But there are cases in which the pair of divisors has the same number, for example, door number 16. 16 has the divisors 1 & 16, 2 & 8, 4&4. 
But 4 is repeated because 16 is a perfect square, so you will only visit door number 16, on passes 1, 2, 4, 8, and 16, leaving it open at the end. So only perfect square doors will be open at the end."
Ten Black and White Socks,https://www.interviewbit.com/problems/ten-black-and-white-socks/,N/A,Puzzles,easy,"There are 10 black socks and 10 white socks in a drawer.Now you have to go out wearing your shoes.

So how many maximum number of times you need to remove the sock from drawer so that you can go out?

You can remove only 1 sock at a time. 

You can’t look at the drawer while removing the socks.

Obviously, you can’t go outside wearing different socks!

Answer is a integer.  Just put the number without any decimal places if its an integer. If the answer is Infinity, output Infinity.

Feel free to get in touch with us if you have any questions","The worst case is when the socks from the first 2 pick do not match. However, in the third pick, since there are only 2 colors, the sock will match one of the socks already with me. 

This is also widely known as the ""Pigeon Hole Principle""."
Daughters' Ages,https://www.interviewbit.com/problems/daughters-ages/,Google,Puzzles,easy,"Two MIT math grads bump into each other at Fairway on the upper west side. They haven’t seen each other in over 20 years.

The first grad says to the second: “how have you been?”
Second: “great! i got married and i have three daughters now”
First: “really? how old are they?”
Second: “well, the product of their ages is 72, and the sum of their ages is the same as the number on that building over there..”
First: “right, ok.. oh wait.. hmm, i still don’t know”
Second: “oh sorry, the oldest one just started to play the piano”
First: “wonderful! my oldest is the same age!”
How old are the daughters?

Respond with daughter ages sorted in ascending order and concatenated together. No spaces.","We know that there are 3 daughters whose ages multiply to 72. Let’s look at the possibilities…Ages:          Sum of ages:

1 1 72            74

1 2 36            39

1 3 24            28

1 4 18            23

1 6 12            19

1 8 9             18

2 2 18            22

2 3 12            17

2 4 9             15

2 6 6             14

3 3 8             14

3 4 6             13

After looking at the building number the second man still can’t figure out what their ages are, so that means that the sum of the ages (or building number) must be 14, since that is the only sum that has more than one possibility. Finally the man discovers that there is an oldest daughter. That rules out the “2 6 6? possibility since the two oldest would be twins. Therefore, the daughters ages must be “3 3 8?."
Breaking Chocolate Bars,https://www.interviewbit.com/problems/breaking-chocolate-bars/,N/A,Puzzles,easy,"You have a bar of chocolate that consists of n x m square blocks.



If you can only break one piece at a time, how many breaks are necessary to break the original n x m piece into n*m 1 x 1 pieces?

How many are sufficient?","since every break creates exactly one new piece, n * m - 1 breaks are both necessary and sufficient to create n * m total pieces."
Jelly Beans Jars,https://www.interviewbit.com/problems/jelly-beans-jars/,Microsoft,Puzzles,easy,"You have three jars that are all mislabeled. One contains peanut butter jelly beans, another grape jelly jelly beans and the third has a mix of both (not necessarily half-half mix).

How many minimum jelly beans would you have to pull out to find out how to fix the labels on the jars?

Labels on jars are as follows

Jar 1 : Peanut butter
Jar 2 : Grape
Jar 3 : P.b. / Grape
Answer is a integer.  Just put the number without any decimal places if its an integer. If the answer is Infinity, output Infinity.

Feel free to get in touch with us if you have any questions","Remember that every jar has a label, and that every label is wrong.

What happens if you check a jellybean from the PB jar? From the grape jar? From the PB/Grape jar?"
Medicine Chest on a Boat,https://www.interviewbit.com/problems/medicine-chest-on-a-boat/,N/A,Puzzles,easy,"Alice and Bob are on separate islands. Bob is sick, and Alice has the medicine. Eve has a boat and a chest that can be locked. She is willing to transport objects between Alice and Bob, but only in the chest, and if the chest is unlocked, she will steal whatever is inside.

If both Alice and Bob have a padlock and a key such that their own key only opens their own lock.  Is it possible for Alice to send the medicine to Bob? If so, how many minimum trips are required? Note that Bob and Alice cannot travel in the boat. The boat going from Alice to Bob or Bob to Alice counts as 1 trip.

Case 1 : Answer is a integer. Just put the number without any decimal places if its an integer. If its not possible for Alice to send the medicine to Bob, output Infinity.
Case 2 : Floating point number. Round it off to 2 decimal places and output it as I.xx where I is the integer part of the answer, and xx are 2 decimal digits after rounding off.
Feel free to get in touch with us if you have any questions","Alice puts medicine in chest, puts her padlock on chest, locks her padlock. Eve sends chest to Bob. Bob puts his padlock on the chest and locks it. Eve sends chest to Alice. Alice unlocks her padlock and keeps it. Eve sends chest to Bob. Bob unlocks his padlock and opens chest."
Cross the Bridge,https://www.interviewbit.com/problems/cross-the-bridge/,"Google, Microsoft",Puzzles,easy,"Four people are on this side of the bridge. Everyone has to get across. 

Problem is that it’s dark and so you can’t cross the bridge without a flashlight and they only have one flashlight. 

Plus the bridge is only big enough for two people to cross at once. 

The four people walk at different speeds:

one fella is so fast it only takes him 1 minute to cross the bridge,
another 2 minutes,
a third 5 minutes,
the last it takes 10 minutes to cross the bridge.
When two people cross the bridge together (sharing the flashlight), they both walk at the slower person’s pace. What is the minimum time required for all 4 to cross the bridge.

Respond with a number which represents the number of minutes.

Answer is a integer.  Just put the number without any decimal places if its an integer. If the answer is Infinity, output Infinity.

Feel free to get in touch with us if you have any questions","1 minutePerson B : 2 minutes

Person C : 5 minutes

Person D : 10 minutes

Let F represents Flashlight.

Person C and D are the slowest guys, if they don’t walk together that it self will make it 15 minutes, In this case (the best way to save time is) :

A,D,F —-Bridge—-> = 10 min

<—-Bridge—-A,F = 1 min (returning with flash light) A,C,F —-Bridge—-> = 5 min

<—-Bridge—-A,F = 1 min A,B,F —-Bridge—-> = 2 min

That makes a total of 19 minutes, but thats not what we want.

It means they both should walk together, in this case if they both are walking together, then there should be another person(because if one of them will bring it will take 5 minutes) to bring the flashlight back. So here is the solution…A,B,F —-Bridge—-> = 2 min

<—-Bridge—-A,F = 1 min C,D,F —-Bridge—-> = 10 min

<—-Bridge—-B,F = 2 min A,B,F —-Bridge—-> = 2 min

Total time = 17 minutes."
Spinning Disc's Direction,https://www.interviewbit.com/problems/spinning-discs-direction/,N/A,Puzzles,easy,"Raw Problem


 <div id=raw_problem_description_markdown_content_value style=”background-color: #f9f9f9; padding: 5px 10px; “>Raw Problem

A spinning disc is painted black on one half and white on the other (i.e., the line forming the border between the black and white regions of the disc is a diameter of the disc). The disk is spinning on a turntable in an unknown direction at an unknown speed. You have special video cameras that can observe the color of a single point on the disc. How many cameras do you need to determine the direction the disc is spinning?

NOTE : You can also move the camera freely.

Answer is a integer. Just put the number without any decimal places if its an integer. 
If determining the direction is not possible, output Infinity. 
Feel free to get in touch with us if you have any questions.</div></div>","If you fix the two cameras on two points on the disc right next to each other (but at the same distance from the center of the disc), then as the disc spins, one camera will observe the color changing just before the other. From this you can easily deduce which direction the disc is spinning.

But, you really only need one camera:

Start by fixing the camera on any point on the disc. As the disc spins, the camera will observe the color alternating between black and white. Now, move the camera around to allow the point the camera is observing to move clockwise with respect to the center of the disc, and note the rate the color changes. Move the camera in the other direction, and again note the rate the color changes. The slower rate indicates the direction the disc is spinning."
Wizards and Drawves,https://www.interviewbit.com/problems/wizards-and-drawves/,N/A,Puzzles,easy,"There is a village of wizards and a village of N dwarves.

Once a year, the wizards go over to the village of dwarves and line all the dwarves up in increasing height order, such that each dwarf can only see the dwarves shorter than himself.

The wizards have an infinite supply of white and black hats. They place either a white or black hat on the head of each dwarf. Then, starting with the tallest dwarf (in the back of the line), they ask each what color hat he is wearing. If the dwarf answers incorrectly, the wizards kill him (the other dwarves can hear his answer, but can’t tell if he was killed or not). What is the most number of dwarves that will be killed using this optimal strategy?

Do note that the dwarves already know that the wizards will do as stated above. So, they can get together and devise an optimal strategy to minimize the people that get killed.

Case 1 : Answer is a function of N. Output it with N with multipliers or divisor numbers following N. For example, N * 2, N / 2, N * 3 / 4.
Case 2 : Answer is a integer. Just put the number without any decimal places if its an integer. If the answer is Infinity, output Infinity.
Case 3 : Floating point number. Round it off to 2 decimal places and output it as I.xx where I is the integer part of the answer, and xx are 2 decimal digits after rounding off.
Feel free to get in touch with us if you have any questions","The dwarves have a strategy that will cost the life of at most one dwarf.

Let black hats signify 1’s and white hats signify 0’s. Each dwarf calculates the parity (sum modulo 2) of the hats in front of him. The first (tallest) dwarf announces the color corresponding to the parity he calculated. He may or may not be killed (depending on his luck… of course the Wizards can always engineer it so he dies, because they know this is the optimal strategy).

The next dwarf compares the parity he calculated and the parity the first dwarf announced. If the two parities are the same, that means his hat is white, otherwise it is black. He announces this color, and lives.

Each successive dwarf, armed with the original parity of all but the first dwarf and the colors of the hats of all the preceding dwarves (but the first), can easily calculate the color of his own hat. An inductive proof of correctness is pretty easy.

Thus only the first (and tallest) dwarf dies… which I guess explains why dwarves are so short."
Genie and Hats,https://www.interviewbit.com/problems/genie-and-hats/,N/A,Puzzles,easy,"A bunch of men are on an island.

A genie comes down and gathers everyone together and places a magical hat on some people’s heads (i e , at least one person has a hat).

The hat is magical: it can be seen by other people, but not by the wearer of the hat himself. To remove the hat, those (and only those who have a hat) must dunk themselves underwater at exactly midnight. If there are n people and c hats, how long does it take the men to remove the hats? 

The men cannot tell each other (in any way) that they have a hat.

Note: Genie does not tell how many hats she has put.

All the men are perfect logicians and know that each other are perfect logicians","Lets take some simple cases firstc = 1: in this case person who has hat on his head can see that no one else has hat on their head, so he will understand that he is the one with hat.

c = 2: in this case person with hat will see one other person with hat, rest all will see two hats. Now had there been only 1 hat, this case would have been solved on very first day, but in this case no one will go on first night, so the guy who see one hat will understand that there must be one hat on his head, so both of them will go underwater on second night.

c = 3: in this case person with hat will see two hats and rest all will see three hats, now had there been 1 or 2 hats some guys would have gone on first or second night, thus on third day guys who see 2 hats will understand that they have hats on their head and they will all go underwater on third night.

Similarly we can see that it will take c days to remove all hats."
Color of the last ball,https://www.interviewbit.com/problems/color-of-the-last-ball/,N/A,Puzzles,easy,"You have 20 blue balls and 14 red balls in a bag. 

You put your hand in and remove 2 at a time.

If they’re of the same color, you add a blue ball to the bag.
If they’re of different colors, you add a red ball to the bag.
( Assume you have a big supply of blue & red balls for this purpose).

Note: When you take the two balls out, you don’t put them back in, so the number of balls in the bag keeps decreasing.

What will be the color of the last ball left in the bag?","There are three possible cases of removing the two balls.
a) If we take off 1 RED and 1 BLUE, we actually will take off 1 BLUE.
b)If we take off 2 RED, we actually will take off 2 RED (and add 1 BLUE).
c) If we take off 2 BLUE, we actually will take off 1 BLUE.
So In the case of (a) or (c), we are only removing one blue ball, but we always take off red balls two by two.

If there are 14 (even) red balls, we can not have one red ball left in the bag so that the last ball will be blue."
Arrange Cubes,https://www.interviewbit.com/problems/arrange-cubes/,N/A,Puzzles,easy,"A man has two cubes on his desk. 

Every day he arranges both cubes so that the front faces show the current day of the month. 

What numbers are on the faces of the cubes to allow this?

Sort the digits on cube 1 and sort the digits on cube 2 and append them to give the answer.

For example, if the first cube had digits 1 2 3 4 5 6 and second had digits 3 1 9 8 2 4, 

the sorted digits become :

First cube : 1 2 3 4 5 6
Second cube : 1 2 3 4 8 9
So, the answer would be “123456123489”","We have two cubes, that means 12 faces or 12 numbers one on each face. The all possible dates are 1 to 31, that includes 11 and 22. So 1 and 2 should be there on both cubes. It means we need 12 digits (0-9 and 1, 2). Now if we see the distribution of numbers on each faces, we have 1 and 2 on both cubes. For 30 we need 0 and 3 on different cubes. So lets say, first cube has 1, 2, 3, 4, 5, 6 and other one has 0, 1, 2, 7, 8, 9. It looks fine, but we we notice, the man uses both the cubes for each day, so how do we show 07, 08, 09 ???So that means we need to have 0 on both the cubes, but that makes it 13, but there are only 12 faces. Thats the trick in this question, we can place cubes upside down too, now which is the number we can use both the ways, yes its 6, it can be used as 9 and then we can have all the possible dates.

so first cube : 0, 1, 2, 3, 4, 5

second cube : 0, 1, 2, 6, 7, 8"
Equilateral Triangles using Toothpicks,https://www.interviewbit.com/problems/equilateral-triangles-using-toothpicks/,N/A,Puzzles,easy,"Create an equilateral triangle using three toothpicks.



Now you have to add three more equilateral triangles of the same size as the original. 

What is the minimum number of toothpicks required?

Answer is a integer.  Just put the number without any decimal places if its an integer. If the answer is Infinity, output Infinity.

Feel free to get in touch with us if you have any questions","The problem basically asks you to create four equilateral triangles of the same size with six toothpicks. A bit of analysis will tell us that four triangles require twelve toothpicks, and since we only have six to work with, that means each toothpick must appear in two triangles. So every triangle has to border three other triangles (one on each side).Think outside of the plane. It’s a tetrahedron (a three-sided pyramid)."
The Tribe,https://www.interviewbit.com/problems/the-tribe/,Amazon,Puzzles,easy,"There are two tribes in Mars, Lie tribe and Truth Tribe.

Lie tribe always speaks lie, True tribe always speaks truth.

You meet three mars people and ask from the first Person:

Q: What tribe do you belong to?
He replies something in his language which you don’t understand.

Second person tells you that he is saying that he belongs to Lie Tribe.

Third person says that second person is lying.

What tribe does the third person belong to?","Lets assume that first person is from Truth tribe, then he will claim that he is from the truth tribe, in which case the second person is lying.Now assume that first person is from Lie tribe. Even then, he will say that he belongs to the truth tribe (as he is a liar), so second person is lying again in this case as well.

Thus third person is correct in both the scenarios, hence he belongs to Truth Tribe."
Measure Time by Burning Ropes,https://www.interviewbit.com/problems/measure-time-by-burning-ropes/,N/A,Puzzles,easy,"You have two ropes and a box of matches. Each rope takes exactly one hour to burn, but they may not necessarily burn evenly – i.e., the first half might burn in the first 10 minutes and the second in the remaining 50). What durations of time can you measure using the 2 ropes? Times do not have to start when the first rope is lit.

Note that this is a multiple choice question. Mark all the times which are measurable.","Burining a single rope lets you measure 1 hour. Burning 2 ends of it at the same time let you measure 30 minutes.

Start by lighting both ends of one rope and only one end of the second rope. When the first rope is finished burning (i.e., after a half an hour), light the other end of the second rope. At this point, the second rope is halfway burned, so it will take another 15 minutes to burn the second half with both ends lit. When the second rope is done burning, 45 minutes has elapsed. 

15 minutes has elapsed after first rope is completely burnt."
Dinner Hand Shakes,https://www.interviewbit.com/problems/dinner-hand-shakes/,N/A,Puzzles,easy,"A couple invites n - 1 other couples to dinner. 

Once everyone arrives, each person shakes hands with everyone he doesn’t know. 

Then, the host asks everyone how many hands they shook, and each person replies with a different number. Assuming that everyone knows his or her own spouse, how many hands did the hostess shake?

NOTE: It might seem that the question is incomplete or has certain data missing. We assure you that its not the case. The question has sufficient information for you to arrive at a solution.","The possible numbers of handshakes range from 0 to 2N-2. (2N-1 would require that a person shook hands with every other person at the party, but nobody shook hands with his/her spouse.)

This is 2N-1 different numbers, and the host got 2N-1 different answers, so every number is represented.

One person (0) shook no hands, and another (2N-2) shook hands with everybody from all the other couples. This is only possible if these two are a married couple, because otherwise 2N-2 would have had to have shaken 0’s hand.

One person (1) shook only 2N-2’s hand, and another (2N-3) shook hands with everybody from all the other couples except 0. Again, these two must be married, or else 2N-3 would have had to have shaken 1’s hand, a contradiction.

. . .

Continuing this logic, eventually you pair up all the couples besides the hosts, each one pairing a shook-no-hands-not-already-mentioned person with a shook-all-hands-not-already-mentioned person, the last having shaken N-2 and N hands respectively.

This tells us that the hostess must have shaken N-1 hands, by process of elimination, though we don’t have to use the elimination – since we have N-1 shook-no-other-hands people and N-1 shook-all-other-hands people, we know that both the host and hostess shook hands with exactly one member of each couple – the same ones – and thus each shook N-1 people’s hands"
Helium Balloon,https://www.interviewbit.com/problems/helium-balloon/,N/A,Puzzles,easy,"You’re in a car with a helium balloon on a string that is tied to the floor. The windows are closed. When you step on the accelerator, what happens to the balloon—does it move forward, move backward, or stay put?","The near-universal intuition is that the balloon leans backward as you accelerate. Well, the intuition is wrong. Your job is to deduce how the balloon does move and to explain it to the interviewer. One good response is to draw an analogy to a spirit level. For the not so handy, a spirit level is the little gizmo carpenters use to make sure a surface is horizontal. It contains a narrow glass tube of colored liquid with a bubble in it. Whenever the spirit level rests on a perfectly horizontal surface, the bubble hovers in the middle of the tube. When the surface isn’t so level, the bubble migrates to the higher end of the tube. The takeaway here is that the bubble is simply a “hole” in the liquid. When the surface isn’t level, gravity pulls the liquid toward the lower end. This pushes the bubble wherever the liquid isn’t— toward the opposite end.

Untie the helium balloon and let it hit the moonroof. It becomes a spirit level. The balloon is a “bubble” of lower-density helium in higher-density air, all sealed in a container (the car).

Gravity pulls the heavy air downward, forcing the light balloon against the moonroof.

When the car accelerates, the air is pushed backward, just as your body is. This sends a lighter-than-air balloon forward. When the car brakes suddenly, the air piles up in front of the windshield. This sends the balloon backward. Centrifugal force pushes the air away from the turn and sends the balloon toward the center of the turn. Of course, the same applies when the balloon is tied to something; it’s just less free to move. The short answer to this question is that the balloon nods in the direction of any acceleration."
Divide the Cake,https://www.interviewbit.com/problems/divide-the-cake/,Google,Puzzles,easy,Consider a rectangular cake with a rectangular section (of any size or orientation) removed from it. Is it possible to divide the cake exactly in half with only one cut?,"Every line that cuts a rectangle in half passes through the center of the rectangle. There are infinite such lines for every rectangle. However, there is exactly one line that passes through the centers of both rectangles, the cake and the hole in it – that is, of course, unless they share a common center. This line divides both rectangles exactly in half, and this is the line along which you make the cut. Hence, its always possible."
Color of the last ball II,https://www.interviewbit.com/problems/color-of-the-last-ball-ii/,N/A,Puzzles,easy,"You have 20 blue balls and 13 red balls in a bag. 

You put your hand in and remove two at a time.

If they’re of the same color, you add a blue ball to the bag.
If they’re of different colors, you add a red ball to the bag.
Assume you have an enormous supply of blue & red balls for this purpose.

Note: When you take the two balls out, you don’t put them back in, so the number of balls in the bag keeps decreasing.

What will be the color of the last ball left in the bag?","There are three possible cases of removing the two balls.
a) If we take off 1 RED and 1 BLUE, we actually will take off 1 BLUE.
b)If we take off 2 RED, we actually will take off 2 RED (and add 1 BLUE).
c) If we take off 2 BLUE, we actually will take off 1 BLUE.
So In case of (a) or (c), we are only removing one blue ball, but we always take off red balls two by two.

Now as the no. of red balls is odd, there will be one single red ball in the bag with other blue balls, and whenever we remove 1 red and 1 blue ball, we end up taking off only the blue ball. So the red ball will be the last ball in the bag."
Measure Time by Hourglass,https://www.interviewbit.com/problems/measure-time-by-hourglass/,N/A,Puzzles,easy,"Using only a four-minute hourglass and a seven-minute hourglass, what time can be measured with the process not taking longer than the time we are trying to measure.

NOTE: This is a multiple choice question. Check all the times which are measurable.8 minutes
11 minutes
6 minutes
9 minutes","For 8 mins, use the 4 min hourglass twice.         For 11 mins, use 4 min hourglass followed by 7 min hourglass.

        For 9 mins, start both hourglasses at 0 minutes. Flip over the four-minute glass when it runs out (at 4:00); ditto for the seven-minute glass (at 7:00). When the four-minute glass runs out the second time (at 8:00), the seven-minute glass will then have one minute of sand in its lower bulb. Flip the seven-minute glass over again and let the minute of sand run back. When the last grain falls, that will be nine minutes."
Make a Statement,https://www.interviewbit.com/problems/make-a-statement/,N/A,Puzzles,easy,"Which offer is better?

1) You are to make a statement. If the statement is true, you get exactly $10. If the statement is false, you get either less than or more than $10 but not exactly $10.
2) You are to make a statement. Regardless of whether the statement is true or false, you get more than $10.","You should take offer #1, because you can guarantee yourself an arbitrarily large amount of money, simply by using the following as your statement:

“I will receive neither $10 nor $1000.”

If we assume the statement is true, this leads to a contradiction because you would receive $10, by the rules.

If we assume the statement is false, then to satisfy the falsity of the statement, you must receive either $10 or $1000. But since you cannot receive $10 if the statement is false, you must receive $1000.

Of course you can use any amount in place of “$1000.”"
Two Pills each day,https://www.interviewbit.com/problems/two-pills-each-day/,N/A,Puzzles,easy,"You are on a strict medical regimen that requires you to take two types of pills each day. You must take exactly one A pill and exactly one B pill at the same time. The pills are very expensive, and you don’t want to waste any. So you open the bottle of A pills, and tap one out into your hand. Then you open the bottle of B pills and do the same thing – but you make a mistake, and two B pills come out into your hand with the A pill. But the pills are all exactly identical. There is no way to tell A pills apart from B pills. Is it possible to satisfy your regimen and take exactly one of each pill at the same time, without wasting any pills?","Cut each pill in half and divide them into two piles. Then, take another A pill from the bottle, cut it in half, and put each half in one of the piles. Now, each pile contains two halves from each type of pill, so you just take one of the piles (and the other the next day)."
Find the Defective Ball,https://www.interviewbit.com/problems/find-the-defective-ball/,Microsoft,Puzzles,easy,"You have 12 balls all look identical (in shape, color etc.). 

All of them have same weight except one defective ball. 

You don’t know that the defective one is heavier or lighter than other balls. You can use a two sided balance system (not the electronic one).

Find the minimum no. of measures required to separate the defective ball.

Answer is a integer.  Just put the number without any decimal places if its an integer. If the answer is Infinity, output Infinity.

Feel free to get in touch with us if you have any questions","Divide the balls into 3 groups of 4 balls.

First weigh :

Weigh 2 groups, one on each side.

There will be two cases :

The weight on both side is equal i. e. these two groups don’t have the defective ball.
One side has less weight than the other side.
Case 1 : You know 8 balls are of equal weight and one of the remaining 4 balls have a defective one. Name these four as B1, B2, B3, B4.

** Second weigh :**

Take B1, B2 and weight them.

If they are unequal then either B1 is defective or B2. Compare B1 with one of eight balls. If B1 is equal to that then B2 is defective otherwise B1.
Total measurements in this case : 1 (first weigh) + 1 (second weigh) + 1 (B1 with other ball) = 3
If B1 and B2 are equal then either B3 is defective or B4. Compare B3 with one of eight balls. If B3 is equal to that then B4 is defective otherwise B3.
Total measurements in this case : 1 (first weigh) + 1 (second weigh) + 1 (B3 with other ball) = 3
Case 2 : Mark the balls in the side with less weight as L and with more weight as M. We get 4L and 4M.

Second weigh :

Take 2L and 1M in One side say A and take 2L and 1M in Other side say B of balance system. 1M and 1L are reserved for now.

If side A is down and next side goes up then it has two possibilities.
One of 2L in A has less weight than other 7 balls
The 1M in B has more weight
If side B is down then it also has two possibilities.
One of 2L in A has less weight than other 7 balls
One of 1M in B has more weight than other 7 balls
Both sides are balanced
Third weigh :

In cases (i) or (ii) we will get 3 balls (2L and 1M) after the second weigh.

For case (i) and (ii)of (b) :

Weigh two L balls with each other, if they are equal then the 1M is heavier and if they are not then the ball with less weight is defective.

For case (iii) of (b) :

In this case one of the two reserved balls is defective. We have 2M balls. Weigh them, the one which is heavier is defectives."
Bee Travel,https://www.interviewbit.com/problems/bee-travel/,N/A,Puzzles,easy,"Two trains enter a tunnel 200 miles long, traveling at 100 mph at the same time from opposite directions. 

As soon as they enter the tunnel a supersonic bee flying at 1000 mph starts from one train and heads toward the other one. 

As soon as it reaches the other one it turns around and heads back toward the first, going back and forth between the trains until the trains collide in a fiery explosion in the middle of the tunnel. 

How far did the bee travel?

Respond with a number which represents the number of miles.

Answer is a integer.  Just put the number without any decimal places if its an integer. If the answer is Infinity, output Infinity.

Feel free to get in touch with us if you have any questions","This puzzle is a little tricky one. One’s thinking about solving this problem goes like this “ok, so i just need to sum up the distances that the bee travels…” but then you quickly realize that its a difficult (not impossible) summation.The tunnel is 200 miles long. The trains meet in the middle traveling at 100 mph, so it takes them an hour to reach the middle. The bee is traveling 1000 mph for an hour (since its flying the whole time the trains are racing toward one another) – so basically the bee goes 1000 miles."
Six Colored Cubes,https://www.interviewbit.com/problems/six-colored-cubes/,N/A,Puzzles,easy,"You have a normal six sided cube. 

I give you six different colors that you can paint each side of the cube with ( one color to each side ). 

How many different cubes can you make?

NOTE: Different means that the cubes can not be rotated so that they look the same. This is important! If you give me two cubes and I can rotate them so that they appear identical in color, they are the same cube.

Answer is a integer.  Just put the number without any decimal places if its an integer. If the answer is Infinity, output Infinity.

Feel free to get in touch with us if you have any questions","Let X be the number of “different” cubes (using the same definition as in the problem). Let Y be the number of ways you can “align” a given cube in space such that one face is pointed north, one is east, one is south, one is west, one is up, and one is down. (We’re on the equator.) Then the total number of possibilities is X * Y. Each of these possibilities “looks” different, because if you could take a cube painted one way, and align it a certain way to make it look the same as a differently painted cube aligned a certain way, then those would not really be different cubes. Also note that if you start with an aligned cube and paint it however you want, you will always arrive at one of those X * Y possibilities.

How many ways can you paint a cube that is already “aligned” (as defined above)? You have six options for the north side, five options for the east side, etc. So the total number is 6! (that’s six factorial, or 6 * 5 * 4 * 3 * 2 * 1). Note that each way you do it makes the cube “look” different (in the same way the word is used above). So 6! = X * Y.

How many ways can you align a given cube? Choose one face, and point it north; you have six options here. Now choose one to point east. There are only four sides that can point east, because the side opposite the one you chose to point north is already pointing south. There are no further options for alignment, so the total number of ways you can align the cube is 6 * 4.

Remember, Y is defined as the number of ways you can align the cube, so Y = 6 * 4. This gives us 6! = X * 6 * 4, so X = 5 * 3 * 2 * 1 = 30."
Prisoners and Poison,https://www.interviewbit.com/problems/prisoners-and-poison/,Amazon,Puzzles,easy,"A bad king has a cellar of 1000 bottles of delightful and very expensive wine.

A neighboring queen plots to kill the bad king and sends a servant to poison the wine. 

Fortunately (or say unfortunately) the bad king’s guards catch the servant after he has only poisoned one bottle. 

Alas, the guards don’t know which bottle but know that the poison is so strong that even if diluted 100,000 times it would still kill the king.

Furthermore, it takes one month to have an effect. The bad king decides he will get some of the prisoners in his vast dungeons to drink the wine. Being a clever bad king he knows he needs to murder as less prisoners as possible – believing he can fob off such a low death rate – and will still be able to drink the rest of the wine (999 bottles) at his anniversary party in 5 weeks time.

In the worst case, what is the minimum number of prisoner he would have to kill in order to find out the poisoned bottle? Do note that the king wants to minimize the number of prisoners involved in the experiment. He might decide to kill every prisoner involved in the experiment if he feels that they may tell the world about his evil plans.

Answer is a integer.  Just put the number without any decimal places if its an integer. If the answer is Infinity, output Infinity.

Feel free to get in touch with us if you have any questions","Number the bottles 1 to 1000 and write the number in binary format.

bottle 1 = 0000000001 (10 digit binary)
bottle 2 = 0000000010
bottle 500 = 0111110100
bottle 1000 = 1111101000
Now take 10 prisoners and number them 1 to 10, now let prisoner 1 take a sip from every bottle that has a 1 in its least significant bit. Let prisoner 10 take a sip from every bottle with a 1 in its most significant bit. etc.

prisoner =  10 9 8 7 6 5 4 3 2 1
bottle 924 = 1 1 1 0 0 1 1 1 0 0
For instance, bottle no. 924 would be sipped by 10, 9, 8, 5, 4 and 3. 

That way if bottle no. 924 was the poisoned one, only those prisoners would die.

After four weeks, line the prisoners up in their bit order and read each living prisoner as a 0 bit and each dead prisoner as a 1 bit. The number that you get is the bottle of wine that was poisoned.

1000 is less than 1024 (2^10). If there were 1024 or more bottles of wine it would take more than 10 prisoners to do the experiment.

Now, lets look at the number of prisoners that will die in the worst case. Thats equal to the maximum number of 1 bits in numbers from 0 - 999. Number 511 has 9 1 bits. The first number with 10 set bits is 2^10 - 1 = 1023. Since, thats outside our range, the maximum number of prisoners that will die in the experiment is 9."
World Trips,https://www.interviewbit.com/problems/world-trips/,Microsoft,Puzzles,easy,"Consider three identical airplanes starting at the same airport. Each plane has a fuel tank that holds just enough fuel to allow the plane to travel half the distance around the world. These airplanes possess the special ability to transfer fuel between their tanks in mid-flight. 

What are the maximum around the world trips that airplane1 can make?

Case 1 : Answer is a integer. Just put the number without any decimal places if its an integer. If the answer is Infinity, output Infinity.
Case 2 : Floating point number. Round it off to 2 decimal places and output it as I.xx where I is the integer part of the answer, and xx are 2 decimal digits after rounding off.
Feel free to get in touch with us if you have any questions","Planes 1 and 2 take off eastbound, and travel a quarter of the way around the world. At this point, both their tanks are half empty, so 2 transfers all of its fuel to plane 1 and lands. Now plane 1 has a full tank.Once plane 1 is halfway around the world, plane 3 takes off westbound and meets plane 1 when plane 1 is three quarters of the way around the world. At this point, plane 1’s tank is empty and plane 3’s is half empty. Plane 3 then transfers all its fuel to plane 1, who is thus able to finish the last quarter of the journey."
Color of the Bear,https://www.interviewbit.com/problems/color-of-the-bear/,Microsoft,Puzzles,easy,"A Bear has fallen from a height of 10m from ground. It reached ground in sqrt(2) seconds. Luckily it didn’t get hurt. What color is the bear?

Just output the color. For example, following are acceptable answers.

White
Black
Pink
Brown
Yellow
Red
Blue
Green","Calculating g, it comes as 10, which means the bear is found where there is more gravity. 

The gravity is increased at the poles. and the South pole doesn’t have bears ( http://sciencequestionswithchris.wordpress.com/2014/01/07/do-i-weigh-less-on-the-equator-than-at-the-north-pole/ ).

So the bear being referred to comes from North Pole. Hence, its white."
Two Numbers,https://www.interviewbit.com/problems/two-numbers/,N/A,Puzzles,easy,"Ben has 2 integers. He tells sum of the integers to the person S and product of those numbers to P.Now there is this conversation between S and P.


S: I don’t know what the numbers are

P: Neither do I

S: Now, I know what the numbers are.

P: Hey, me too. 

Assuming S and P to be very wise and good in mathematics, What are those two integers?

If the integers are x and y, Output 5*x + y.

Note :

Numbers are greater than 0.
S and P are always truthful.
If the numbers are x and y, whats 5 * x + y.","Numbers are 2 and 2.

S would have got 4, which means 1 + 3 or 2 + 2. so that’s why he was not sure of the numbers.

P would have also got 4, possibilities 14 and 22.

Now, had the numbers be 1 and 3, P would have got 3 and he would have been sure of the numbers, but that was not the case, So S became sure that numbers are 2 and 2.

Now, P knows that numbers cant be 1 and 4, because there are two possibilities of getting the sum as 5, 1+4, 2+3, and in both these cases S cant guess the number depending on P’s earlier answer, as for both product 4 and 6 there are more than 1 possibilities.

Thus P also knows that the numbers are 2 and 2."
Next Number,https://www.interviewbit.com/problems/next-number/,N/A,Puzzles,easy,"What’s the next number in this sequence:

10, 9, 60, 90, 70, 66, 96, 94, 98, ... ?
Answer is a integer.  Just put the number without any decimal places if its an integer. If the answer is Infinity, output Infinity.i

Feel free to get in touch with us if you have any questions","Ten
Nine
Sixty
Ninety
Seventy
Sixty-six
Ninety-six
Ninety-four
Ninety-eight
They are in ascending order, based on the number of letters in the spelled-out numbers. A correct response will have twelve letters: 73,77 and 78 for instance."
One Mile on the Globe,https://www.interviewbit.com/problems/one-mile-on-the-globe/,Microsoft,Puzzles,easy,"How many points are there on the globe where by walking one mile south, one mile east and one mile north you reach the place where you started?

Case 1 : Answer is a function of N. Output it with N with multipliers or divisor numbers following N. For example, N * 2, N / 2, N * 3 / 4.
Case 2 : Answer is a integer. Just put the number without any decimal places if its an integer. If the answer is Infinity, output Infinity.
Case 3 : Floating point number. Round it off to 2 decimal places and output it as I.xx where I is the integer part of the answer, and xx are 2 decimal digits after rounding off.
Feel free to get in touch with us if you have any questions

Spaces do not matter.","The north pole is one such place.

However, consider the points 1 + 1/(2*pi) miles away from the south pole. Call point A any of these (infinite number of) points. Go a mile south to point B. When you go a mile east, you end up back at point B (you travelled once through every line of longitude). A mile north then brings you back to point A.

There are points still closer to the south pole such that going a mile east brings you through each line of longitude exactly twice, three times, or as many times as you want. Thus we have an infinite number of concentric rings of infinite numbers of points, and we can start a mile north of any of them."
Marbles in Jar,https://www.interviewbit.com/problems/marbles-in-jar/,N/A,Puzzles,easy,"You have two jars, 50 red marbles and 50 blue marbles. You need to place all the marbles into the jars such that when you blindly pick one marble out of one jar, you maximize the chances that it will be red. When picking, you’ll first randomly pick a jar, and then randomly pick a marble out of that jar. You can arrange the marbles however you like, but each marble must be in a jar. What is the maximum probability?

Answer in decimal rounded off to 2 decimal places. For example, if the answer is 2/3, the response should be 0.67","jar A : (1/2)1 = 1/2 (selecting the jar A = 1/2, red marble from jar A = 50/50)

jar B : (1/2)0 = 0 (selecting the jar B = 1/2, red marble from jar B = o/50)

So probability of getting red marble is 1/2 . Now as we need to maximize the P(getting a red marble), we have to increase the prob of getting a red marble in jar B. If we select jar A, then getting a red marble is guaranteed, but it will also be guaranteed if there is only one red marble in that jar, then also the probability of getting a red marble from jar A is 1/1=1. So now we can place remaining 49 red marbles in jar B, so it increases the prob of getting red marbles in jar B.

So the maximum probability will be :

jar A : (1/2)1 = 1/2 (selecting the jar A = 1/2, red marble from jar A = 1/1)

jar B : (1/2)(49/99)  (selecting the jar B = 1/2, red marble from jar B = 49/99)"
Divide Gold Bar,https://www.interviewbit.com/problems/divide-gold-bar/,"Microsoft, Ebay",Puzzles,easy,"You’ve got someone working for you for seven days and a gold bar to pay him. The gold bar is segmented into seven connected pieces.



You must give them a piece of gold at the end of every day. What are the fewest number of cuts to the bar of gold that will allow you to pay him 1/7th each day?

Answer is a integer.  Just put the number without any decimal places if its an integer. If the answer is Infinity, output Infinity.

Feel free to get in touch with us if you have any questions","Lets split the chain as,



Day 1:  Give A (+1)

Day 2:  Get back A, give B (-1, +2)

Day 3: Give A (+1)

Day 4: Get back A and B, give C (-2,-1,+4)

Day 5: Give A (+1)

Day 6: Get back A, give B  (-1,+2)

Day 7: Give A (+1)

Hence, we need to make 2 cuts. Cut 1, so that the bar is divided into 1 and 6 pieces. And second on the 6 piece bar, so that it is divided into 2 and 4 pieces."
Min Elevator Trips,https://www.interviewbit.com/problems/min-elevator-trips/,N/A,Puzzles,easy,"You are at the bottom of the elevator shaft of a 100 story building. 

You see 21 wires labelled 1 2 3 ... 21. 

The wires go up to the 100th floor where the ends are labelled A B C ... U, but you don’t know how they correspond to the ends at the bottom. 

You have a battery, a light bulb, and many small wires. 

What is the minimum number of trips required to find out the pairing between the letters and the numbers?

Note that connecting the small wires to form a wire 21 floor long is not an option.

Case 1 : Answer is a integer. Just put the number without any decimal places if its an integer. If the answer is Infinity, output Infinity.
Case 2 : Floating point number. Round it off to 2 decimal places and output it as I.xx where I is the integer part of the answer, and xx are 2 decimal digits after rounding off.
Feel free to get in touch with us if you have any questions","Note that your battery, light bulb and small wires are basically a connection tester, and that “connected” is an equivalence relation.

At the bottom, leave 1 unconnected, connect 2 and 3 to each other, connect 4-6 to each other, 7-10, etc, so that we have “equivalence classes” of connectedness of sizes 1, 2, 3, 4, 5 and 6.

Now make a trip to the top, and figure out which letters are connected to nothing else, to one other letter, to two others, etc, until you have figured out the equivalence classes.

Now connect the first letters from each equivalence class (there are 6 of them) in a new equivalence class, the second from each (5 of them) in another, etc. Go to the bottom, remove the original connections, and figure out the new equivalence classes in a similar manner.

We now know from the first set of classes what groups of n letters (for n=1 to 6) at the top correspond to what groups of n numbers at the bottom. From the second set of classes we now know which letters and numbers were the “first” in their original classes, which were the “second,” etc, so we have the complete pairing.

This solution works cleanly for any triangular number of wires, but can be easily adapted to work for all natural numbers greater than 2."
100 People in a Circle,https://www.interviewbit.com/problems/100-people-in-a-circle/,N/A,Puzzles,easy,"One hundred people are standing in a circle in an order 1 to 100.

No.1 has a sword. 

He kills the next person (i.e., no. 2) and gives the sword to the next (i.e., no. 3). 

All person does the same until only one survives.

Which number survives at last?

Answer is an integer.  Just put the number without any decimal places if it’s an integer. If the answer is Infinity, output Infinity.

Feel free to get in touch with us if you have any questions","Round 1 : 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99
Round 2: 1, 5, 9, 13, 17, 21, 25, 29, 33, 37, 41, 45, 49, 53, 57, 61, 65, 69, 73, 77, 81, 85, 89, 93, 97
Round 3: 1, 9, 17, 25, 33, 41, 49, 57, 65, 73, 81, 89, 97
Round 4: 9, 25, 41, 57, 73, 89
Round 5: 9, 41, 73
Round 6: 9, 73
Round 7: 73"
Gates of Heaven,https://www.interviewbit.com/problems/gates-of-heaven/,N/A,Puzzles,easy,"Amanda dies and reaches at the gate of heaven.

She has three doors in front of her out of which only one of them leads to heaven. 

Out of the other two gates, one leads to hell for one day and then back to the gate and one leads to hell for two days and then back to the gate.

If she chooses one of these two gates, the gates are shuffled when she returns back.

How long is Amanda expected to take to reach heaven?

Output the number of days.

Answer is a integer.  Just put the number without any decimal places if its an integer. If the answer is Infinity, output Infinity.

Feel free to get in touch with us if you have any questions","Let us simplify the question and then it will lead us to the answer easily. There are three possibilities. Thus the probability of choosing any door is 1/3rd. 1/3 of the time the door to heaven will be chosen by Amanda and thus 1/3 of the time it will take her zero days. 1/3 of the time, the day which leads to hell for one day will be chosen and of those the right door will be chosen the next day. So 1/9 trips take one day. In the similar manner, 1/9 will take to the door which takes to 2 days hell.

When that happens, the cases will be split again and again. Thus on average, it will take three days for Amanda to reach Heaven by choosing the right gate."
Fastest Horses,https://www.interviewbit.com/problems/fastest-horses/,N/A,Puzzles,easy,"There are 25 horses. We have to find out the fastest 3 horses. In one race maximum 5 horses can run. How many such races are required in minimum to get the result?

Answer is a integer.  Just put the number without any decimal places if its an integer. If the answer is Infinity, output Infinity.

Feel free to get in touch with us if you have any questions","We can first do 5 races by taking 5-5 horses and get top horse in each raceLets say it looks like this

	O1, O2, O3, O4, O5
	T1, T2, T3, T4, T5
	TH1, TH2, TH3, TH4, TH5
	F1, F2, F3, F4, F5
	FV1, FV2, FV3, FV4, FV5
Here O1 > O2 > O3 > O4 > O5 same way for others.

Now lets take fastest horse in each race and then have one race between them,  so have race in O1,  T1,  TH1,  F1 and FV1.

Lets say O1,  TH1 and F1 comes in top three(and O1 > TH1 > F1),  then there are no chances that horses slower than T1 and FV1 can come in top 3 and we can also say that O1 is fastest horse and also F2-F5 horses are not among top 3.

Now we need to find second and third fastest horses

they can be from O2, O3, TH1, TH2 and F1,  So we will have once more race among them to determine second and third position.

Thus a total of minimum 7 races are needed to find top 3 horses from 25 horses."
Train Station,https://www.interviewbit.com/problems/train-station/,N/A,Puzzles,easy,"Every day, Joe arrives at the train station from work at 6pm. 

His wife leaves home in her car and meets him there at exactly 6pm, and drives him home. One day, Joe gets to the station an hour early, and starts walking home, until his wife meets him on the road. They get home 20 minutes earlier than usual. 

How long was he walking? 

Distances are unspecified. Speeds are unspecified, but constant. 

Output a number which represents the answer in minutes.

Case 1 : Answer is a integer. Just put the number without any decimal places if its an integer. If the answer is Infinity, output Infinity.
Case 2 : Floating point number. Round it off to 2 decimal places and output it as I.xx where I is the integer part of the answer, and xx are 2 decimal digits after rounding off.
Feel free to get in touch with us if you have any questions","00, he must have been walking for 50 minutes.

Here’s another way to look at it: notice that we didn’t specify any of the distances, including how far away Joe’s house is from the train station. So let’s try examining a degenerate case, say, where Joe lives at the train station. But this doesn’t make much sense, because his wife’s round trip can’t decrease by 20 minutes if it is already zero. So the real degenerate case is when Joe’s wife normally has to drive 10 minutes to get to the train station, and thus her round trip is 20 minutes less, i.e., zero minutes in the case. This means that John meets her at home just as she is about to leave. What time does she normally leave? At 5:50, so she can get to the train station at 6:00. Thus Joe must have been walking for 50 minutes to arrive home at 5:50."
Cats and a Square,https://www.interviewbit.com/problems/cats-and-a-square/,N/A,Puzzles,easy,"Suppose that there is a unit square. There are four cats sitting at the four different corners of the square. Each of those cats start chasing the other cat in the clockwise direction. The speed of the cats are same and constant and they continuously change their direction in a manner that they are always heading straight to the other cat. How long will it take for the cats to catch each other?

Assume that each cat is running at 1 unit speed.","Let us denote the cats with A, B, C and D in a fashion that A is chasing B, B is chasing C, C is chasing D and D is chasing A. The cats are moving in symmetry and thus the only logical answer is that they will meet at the center of the square. 

At any point of time, the Cat A is perpendicular to cat B and Cat B is perpendicular to Cat C and so on. Cat A runs for Cat B but Cat B does not run towards or away from Cat A for it is moving in a perpendicular direction to Cat A. Thus the distance that need to be covered by Cat A to grab Cat B will be exactly same as the original distance between them which in this case is one unit (as it is a unit square).

Thus the speed of each cat towards the cat it is chasing will be [1 + cos (x)] where x denotes the angle on each corner.

Thus speed of the cat = 1 + cos (90) = 1 + 0 = 1

The time needed = Distance / Speed = 1/1 = 1 unit"
Good Processor,https://www.interviewbit.com/problems/good-processor/,N/A,Puzzles,easy,"You are on a spaceship that has a computer with n processors. 

Suddenly, the spaceship gets hit with an alien laser beam, and some of the processors are damaged. 

However, you know that more than half of the processors are still good.

You can ask one processor whether it thinks another processor is good or bad. A good processor will always tell the truth, but a bad one will always lie.

A ‘step’ consists of asking one processor if it thinks another processor is good or bad. Find minimum number of steps required to find at least one good processor.

Answer is a integer.  Just put the number without any decimal places if its an integer. If the answer is Infinity, output Infinity.

Feel free to get in touch with us if you have any questions","Let the processors be numbered 1…n. Begin by asking processor 1 if processor 2 is good. If the answer is “no”, remove these two processors from the list and start over. Note that you removed one good processor and one bad processor from the list, so more than half of the remaining processors are still good.If processor 1 says processor 2 is good, continue by asking processor 2 about processor 3, 3 about 4, etc., until you get a “no” answer. Suppose it is processor j that says processor j+1 is bad. Remove both processors j and j+1 from the list (as before, more than half of the remaining processors are still good, since one of the two you removed was good and one was bad), and continue by asking processor j-1 about processor j (the processor that was after j+1 before you removed it and the original processor j).

You are creating a “chain” of processors who each think the next processor in the chain is good. So these processors are either all good or all bad. Once this chain comprises more than half of the processors in the remaining list, you know that all these processors are good. Or, if you’ve removed so many processors that only one or two remain, you know that that one or those two are good.

To show that this involves at most n-2 steps, note that every processor is asked about at most once, and the first processor is never asked about. Also, the last processor is never asked about either, since you stop once the chain is longer than half the list."
Quarters on a Table,https://www.interviewbit.com/problems/quarters-on-a-table/,Microsoft,Puzzles,easy,"Consider a two-player game played on a circular table of unspecified diameter.



Each player has an infinite supply of coins, and take turns placing a coin on the table such that it is completely on the table and does not overlap with any other coins already played.

A player wins if he makes the last legal move.

Which player (if any) has a strategy that will guarantee a win? Assume that the diameter of the table is greater than the diameter of the coin.","Player 1 has a strategy to win. His first move is to put a quarter in the exact center of the table. 

Player 2 then places a quarter anywhere on the table (but not in the center, of course). Now convince yourself that Player 1 always has a legal move: by playing a quarter diametrically opposite from the quarter Player 2 just put down (i.e., Player 1's first quarter is the midpoint of the line between Player 2's last quarter and Player 1's last quarter). We continue until we fill up the table, but since Player 1 always has a legal move, it is only Player 2 that will be faced with no legal move. Then Player 1 wins.

Note that this strategy works even in the degenerate case when the table is the size of a quarter."
Blindfolded Coin Toss,https://www.interviewbit.com/problems/blindfolded-coin-toss/,N/A,Puzzles,easy,"You are blindfolded and 10 coins are place in front of you on table. 

You are allowed to touch the coins, but can’t tell which way up they are by feel.

You are told that there are 5 coins head up, and 5 coins tails up but not which ones are which.

Can you make two piles of coins each with the same number of heads up? 

You can flip the coins any number of times.","Make 2 piles with equal number of coins. Now, flip all the coins in one of the pile.How this will work? lets take an example.
So initially there are 5 heads, so suppose you divide it in 2 piles.

Case:
P1 : H H T T T
P2 : H H H T T
Now when P1 will be flipped
P1 : T T H H H
P1(Heads) = P2(Heads)

Another case:
P1 : H T T T T
P2 : H H H H T
Now when P1 will be flipped
P1 : H H H H T
P1(Heads) = P2(Heads)"
Measure Milk by Cans,https://www.interviewbit.com/problems/measure-milk-by-cans/,N/A,Puzzles,easy,"There is a drum full of milk. 

People come for buying milk in the range of 1-40 litres. 

You can have only 4 cans to draw milk out of drum. Tell me what should be the measurement of these four cans so that you can measure any amount of milk in the range of 1-40 litres.

Note that the cans cannot be used more than once to refill from the drum.

Output the numbers in ascending order space separated.","1 = 1
	3 - 1 = 2
	3 = 3
	3 + 1 = 4
	9 - 3 - 1 = 5
	9 - 3 = 6
	9 - 3 + 1 = 7
	9 - 1 = 8
	9 = 9
	9 + 1 = 10
	9 + 3 - 1 = 11
	9 + 3 = 12
	9 + 3 + 1 = 13
	27 - 9 - 3 - 1 = 14
	27 - 9 - 3 = 15
	27 - 9 - 3 + 1 = 16
	27 - 9 - 1 = 17
	27 - 9 = 18
	27 - 9 + 1 = 19
	27 - 9 + 3 - 1 = 20
	27 - 9 + 3 = 21
	27 - 9 + 3 + 1 = 22
	27 - 3 - 1 = 23
	27 - 3 = 24
	27 - 3 + 1 = 25
	27 - 1 = 26
	27 = 27
	27 + 1 = 28
	27 + 3 - 1 = 29
	27 + 3 = 30
	27 + 3 + 1 = 31
	27 + 9 - 3 - 1 = 32
	27 + 9 - 3 = 33
	27 + 9 - 3 + 1 = 34
	27 + 9 - 1 = 35
	27 + 9 = 36
	27 + 9 + 1 = 37
	27 + 9 + 3 - 1 = 38
	27 + 9 + 3 = 39
	27 + 9 + 3 + 1 = 40
The right way to think about the solution is that when you have x cans which let you measure all volumes from 1 to N, you now want to include 2*N + 1 as your next can. That way, all weights from N + 1 to 2*N can be measured by subtracting N to 1 ( which we already know how to form using the x cans that we have ) from 2*N + 1. Also, all weights from 2*N + 2 to 3*N + 1 can be formed by adding 1 to N ( which we already know how to form using the x cans that we have ) to 2*N + 1 can."
Light Switches in the Cellar,https://www.interviewbit.com/problems/light-switches-in-the-cellar/,Amazon,Puzzles,easy,"In your cellar there are three light switches in the OFF position. Each switch controls one of three light bulbs on floor above. 

You may move any of the switches but you may only go upstairs to inspect the bulbs. 

When upstairs, you cannot access the switches. What is the minimum number of times you need to go upstairs to determine the switch for each bulb?

Since your answer is a integer, just put the number without any decimal places if its an integer. If the answer is Infinity, output Infinity.","Turn light switch 1 to the ON position for a few minutes, then turn it off. Then turn on switch 2, and go upstairs. The light bulb that is off and hot is attached to switch 1. The one that is on is attached to switch 2, and the one that is off and cold is attached to switch 3."
Cross the Bridge II,https://www.interviewbit.com/problems/cross-the-bridge-ii/,N/A,Puzzles,easy,"A farmer is returning from market, where he bought a she-goat, a wolf and cabbage. 

On the way home he must cross a river.

His boat is little, allowing him to take only one of the three things. 

He can’t keep the she-goat and the cabbage together (because the she-goat would eat it), nor the she-goat with the wolf (because the she-goat would be eaten).

How many minimum trips for the farmer to get everything on the other side (without any harm)? 

Crossing the river counts as one trip.

Answer is a integer.  Just put the number without any decimal places if its an integer. If the answer is Infinity, output Infinity.

Feel free to get in touch with us if you have any questions","farmer crosses with goat
farmer returns alone
farmer crosses with cabbage or wolf
farmer returns with goat
farmer crosses with whichever (cabbage or wolf) he didn’t take the first time
farmer returns alone
farmer crosses with goat
they are all on the other side"
Last Palindromic Date,https://www.interviewbit.com/problems/last-palindromic-date/,N/A,Puzzles,easy,"In year 2001 on October 2, 2001, the date in MMDDYYYY format was a palindrome (same forwards as backwards).

10/02/2001 -> ""10022001""
When was the last date before 2001 that this occurred on?

Respond in MMDDYYYY format ( No space or ‘/’ )","One year can have only one palindrome as the year fixes the month and date too, so the year has to be less than 2001 since we already have the palindrome for 10/02. It can’t be any year in 1900 because that would result in a day of 91, same for 1800 down to 1400. it could be a year in 1300 because that would be the 31st day. 

So whats the latest year in 1300 that would make a month? 

When you first look at it, 12th month comes to mind as we have to find the latest date, so it seems it would be 1321. But we have to keep in mind that we want the maximum year in 1300 century with a valid date, so lets think about 1390 that will give the date as 09/31, is this a valid date… ? No, because September has only 30 days, so last will be the 31st August. Which means the correct date would be 08/31/1380."
Fake Note,https://www.interviewbit.com/problems/fake-note/,N/A,Puzzles,easy,"A man (M) bought a product worth Rs 200 from the Shopkeeper (X). 

He paid him through a 1000 Rs Note. 

Realizing that he did not have change, the shopkeeper X got change for that note from another shopkeeper (Y) and paid Rs 800 to the man.

After a few days, Y realized that the note is fake, And this railed at X and took 1000 Rs back from him.

So in this whole process how much money did X loose in the end?

Answer is a integer.  Just put the number without any decimal places if its an integer. If the answer is Infinity, output Infinity.

Feel free to get in touch with us if you have any questions","This question might seem to be confusing. But here’s the trick. The total loss must be equal to total profit. Here the loser is X and the gainers are M and Y. But actually Y doesn’t gain anything because he just got his money back. So, loss of X = gain of M = 200(for product) + 800(cash) = Rs.1000"
Find the Defective Ball II,https://www.interviewbit.com/problems/find-the-defective-ball-ii/,N/A,Puzzles,easy,"You have 8 balls all look identical (in shape, color etc.). All of them have same weight except one defective ball which is heavier than others. You can use a two sided balance system (not the electronic one). Find the minimum no. of measures required to separate the defective ball and the way you separate it.

Answer is a integer.  Just put the number without any decimal places if its an integer. If the answer is Infinity, output Infinity.

Feel free to get in touch with us if you have any questions","Divide 8 balls into groups of 3, 3 and 2.

Weigh the two groups of 3 ball, now there are two possibilities

a) They are balanced (all 6 balls are of equal weight)

b) One side is heavier than the other.

case (a) :

The group of 2 has the defective ball. Weigh them with one on each side of balancing machine. The side which has more weigh has the heavier/defective ball.

case (b) :

We got the three balls of the side which is heavier. Now take any two balls and weigh them, then again there are two cases.

(i) They both are of equal weight.

(ii) One is heavier than the other.

for case (b)(i) :

The third ball is heavier/defective than all other balls

for case (b)(ii) :

The heavier ball is defective."
Reverse integer,https://www.interviewbit.com/problems/reverse-integer/,N/A,Math,easy,"Problem Description

You are given an integer N and the task is to reverse the digits of the given integer. Return 0 if the result overflows and does not fit in a 32 bit signed integer


Look at the example for clarification.



Problem Constraints
N belongs to the Integer limits.



Input Format
Input an Integer.



Output Format
Return a single integer denoting the reverse of the given integer.



Example Input
Input 1:

 x = 123


Input 2:

 x = -123


Example Output
Output 1:

 321


Ouput 2:

 -321


Example Explanation
 If the given integer is negative like -123 the output is also negative -321.","int Solution::reverse(int A) {
    long long int ans = 0;
    while (A != 0) {
        ans = ans*10 + A%10;
        A = A/10;
    }
    if (ans > INT_MAX || ans < INT_MIN) return 0;
    else return ans;
}"
Excel Column Title,https://www.interviewbit.com/problems/excel-column-title/,Amazon,Math,easy,"Problem Description

Given a positive integer A, return its corresponding column title as appear in an Excel sheet.



Problem Constraints
1 <= A <= 1000000000



Input Format
First and only argument is integer A.



Output Format
Return a string, the answer to the problem.



Example Input
Input 1:

 A = 1
Input 2:

 A = 28


Example Output
Output 1:

 ""A""
Output 2:

 ""AB""


Example Explanation
Explanation 1:

 1 -> A
Explanation 2:

1 -> A
2 -> B
3 -> C
...
26 -> Z
27 -> AA
28 -> AB ","string Solution::convertToTitle(int A) {
    string s="""";
    while(A>0)
    {
        s=(char)('A'+(A-1)%26)+s;
        A=(A-1)/26;
    }return s;
}"
Next Number II,https://www.interviewbit.com/problems/next-number-ii/,Amazon,Puzzles,easy,"Identify the next number in the sequence

31, 28, 31, 30, __?
Answer is a integer.  Just put the number without any decimal places if its an integer. If the answer is Infinity, output Infinity.

Feel free to get in touch with us if you have any questions","Did you consider the fact that we could be talking months here?January - 31 days

February - 28 days

March - 31 days

April - 30 days

May - 31 days

Thus the next number in the sequence will be 31."
Eggs and Building,https://www.interviewbit.com/problems/eggs-and-building/,Google,Puzzles,easy,"There is a building of 100 floors

If an egg drops from the Nth floor or above it will break. If it’s dropped from any floor below, it will not break. You’re given 2 eggs. Find N, while minimizing the number of drops for the worst case.

These are very strong eggs, because they can be dropped multiple times without breaking as long as they are dropped from floors below their “threshold” floor, floor N. But once an egg is dropped from a floor above it’s threshold floor, it will break.

Output the minimum number of drops required to figure out N.

Answer is a integer.  Just put the number without any decimal places if its an integer. If the answer is Infinity, output Infinity.

Feel free to get in touch with us if you have any questions","First thought which comes to our mind is to use binary search, we first drop Egg#1 from 50th floor, if it does not break, then try the middle of second half, if breaks then we have to try each floor in first half. But this will give worst case number of drops as 50(if it brakes on 50th floor, then we have to try from 1 to 49 floors sequentially).

Second thought is to try xth floor then 2xth floor till 100th, in this case worst case time will be (100/x)+(x-1). worst case will be when Egg #1 breaks at 100th floor then we have to try Egg #2 from (100-x)th to 99th floors. In (100/x) + (x-1) equation, with increase in x, 100/x decreases while (x-1) increases, thus we can minimize it when 100/x = (x-1), this gives x ~10, which gives worst case number as 19 drops.

But increasing the floor every time by x is not a very nice idea, as with each new increase in Egg #1 drop, we should decrease Egg #2 drops to minimize worst case number. so if we drop Egg #1 from xth floor initially, then in next turn we should try x + (x-1)th floor(to keep the worst case number same).

Thus we can say X + (x-1) + (x-2)…1 = 100

X(X+1)/2 = 100 => X=14.

So we should drop Egg #1 from 14th, then 27th, then 39th and so on."
Celebrity Problem,https://www.interviewbit.com/problems/celebrity-problem/,N/A,Puzzles,easy,"There are ( N+1 ) people in a party, they might or might not know each others names. 

There is one celebrity in the group (total N + 1 people), celebrity does not know any of N peoples by name and all N people know celebrity by name.

You are given the list of people’s names (N + 1),

You can ask only one question from the people.

	Do you know this name?
How many maximum number of questions you need to ask to know the celebrity name?

Note: assume all names are unique. and you know the persons by name (but don’t know if he is celebrity )","Let’s say you ask from A that Do you know B?If A knows B => A can not be a celebrity.

If A does not know B then B can not be a celebrity.

So you strike out one name from your list, so on each question you can reject one name.

When there are only two people left in the list, then you will ask first person, “Do you know the second person ?”. If he says yes then second person is the celebrity and if he says no then the first person is the celebrity.

Thus you need to ask a maximum of n questions to correctly figure out celebrity name."
Ants on a Triangle,https://www.interviewbit.com/problems/ants-on-a-triangle/,Microsoft,Puzzles,easy,"There are three ants on a triangle, one at each corner. 

At a given moment in time, they all set off for a corner at random. 

What is the probability that they don’t collide?

Answer is a floating point number. Round it off to 2 decimal places and output it as I.xx where I is the integer part of the answer, and xx are 2 decimal digits after rounding off.

For example, if the answer is 2/3, the response should be 0.67","Let the three ants are a, b, c.

There are two cases when they will not collide, the one is when they all move clockwise and the other is when they all move anticlockwise.

They will collide if any two ants move towards each other, at the same time the third ant can move in clockwise or in anticlockwise. so for each pair there are 2 such cases. And there are 3 pairs possible (a,b), (b,c) and (c,a). So total 3*2 = 6 cases when they will collide.

So probability that they will not collide is 2/(2+6) i.e. 1/4"
All Unique Permutations,https://www.interviewbit.com/problems/all-unique-permutations/,"Microsoft, Facebook, Google",Backtracking,medium,"Problem Description

Given an array A of size N denoting collection of numbers that might contain duplicates, return all possible unique permutations.

NOTE: No 2 entries in the permutation sequence should be the same.



Input Format
Only argument is an integer array A of size N.


Output Format
Return a 2-D array denoting all possible unique permutation of the array.


Example Input
Input 1: 
A = [1, 1, 2]
Input 2: 
A = [1, 2]


Example Output
Output 1: 
[ [1, 1, 2]
  [1, 2, 1]
  [2, 1, 1] ]
Output 2: 
[ [1, 2]
  [2, 1] ]


Example Explanation
Explanation 1: 
All the possible unique permutation of array [1, 1, 2].
Explanation 2: 
All the possible unique permutation of array [1, 2].","void generator(vector<int> curr, vector<vector<int>> &result, int i, vector<int> A, map<vector<int>,int> &hash){
    if(curr.size()==A.size()){
        if(hash.find(curr)==hash.end()){
            result.push_back(curr);
            hash[curr]=1;
        }
        return;
    }
    else{
        for(int j=i;j<A.size();j++){
            curr.push_back(A[j]);
            swap(A[i],A[j]);
            generator(curr,result,i+1,A,hash);
            curr.pop_back();
        }
    }
}
vector<vector<int> > Solution::permute(vector<int> &A) {
    // Do not write main() function.
    // Do not read input, instead use the arguments to the function.
    // Do not print the output, instead return values as specified
    // Still have a doubt. Checkout www.interviewbit.com/pages/sample_codes/ for more details

    vector<int> curr;
    vector<vector<int>> result;
    map<vector<int>,int> hash;
    generator(curr,result,0,A,hash);
    sort(result.begin(),result.end());
    return result;
}"
Kth Permutation Sequence,https://www.interviewbit.com/problems/kth-permutation-sequence/,Amazon,Backtracking,medium,"The set [1,2,3,…,n] contains a total of n! unique permutations.

By listing and labeling all of the permutations in order,

We get the following sequence (ie, for n = 3 ) :

1. ""123""
2. ""132""
3. ""213""
4. ""231""
5. ""312""
6. ""321""
Given n and k, return the kth permutation sequence.

For example, given n = 3, k = 4, ans = ""231""

Good questions to ask the interviewer :

What if n is greater than 10. How should multiple digit numbers be represented in string?
In this case, just concatenate the number to the answer.

 so if n = 11, k = 1, ans = ""1234567891011""

Whats the maximum value of n and k?
In this case, k will be a positive integer thats less than INT_MAX.

n is reasonable enough to make sure the answer does not bloat up a lot.","int factorial(int n) {
    if (n > 12) {
        // this overflows in int. So, its definitely greater than k
        // which is all we care about. So, we return INT_MAX which
        // is also greater than k.
        return INT_MAX;
    }
    // Can also store these values. But this is just < 12 iteration, so meh!
    int fact = 1;
    for (int i = 2; i <= n; i++) fact *= i;
    return fact;
}

string getPermutation1(int k, vector<int> &candidateSet) {
    int n = candidateSet.size();
    if (n == 0) {
    return """";
    }
    if (k > factorial(n)) return """"; // invalid. Should never reach here.

    int f = factorial(n - 1);
    int pos = k / f;
    k %= f;
    string ch = to_string(candidateSet[pos]);
    // now remove the character ch from candidateSet. 
    candidateSet.erase(candidateSet.begin() + pos);
    return ch + getPermutation1(k, candidateSet);
}

string Solution::getPermutation(int n, int k) { 
    assert(n >= 1 && n <= 100); 
    vector<int> candidateSet; 
    for (int i = 1; i <= n; i++) candidateSet.push_back(i);
    return getPermutation1(k - 1, candidateSet);
} "
Combination Sum,https://www.interviewbit.com/problems/combination-sum/,"Facebook, Amazon, Adobe",Backtracking,medium,"Problem Description
 
 

Given an array of candidate numbers A and a target number B, find all unique combinations in A where the candidate numbers sums to B.

The same repeated number may be chosen from A unlimited number of times.

Note:

1) All numbers (including target) will be positive integers.

2) Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ? a2 ? … ? ak).

3) The combinations themselves must be sorted in ascending order.

4) CombinationA > CombinationB iff (a1 > b1) OR (a1 = b1 AND a2 > b2) OR ... (a1 = b1 AND a2 = b2 AND ... ai = bi AND ai+1 > bi+1)

5) The solution set must not contain duplicate combinations.

 



Problem Constraints
1 <= |A| <= 20 

1 <= A[i] <= 50

1 <= B <= 500



Input Format
The first argument is an integer array A.

The second argument is integer B.



Output Format
 Return a vector of all combinations that sum up to B.



Example Input
Input 1:

A = [2, 3]
B = 2
Input 2:

A = [2, 3, 6, 7]
B = 7


Example Output
Output 1:

[ [2] ]
Output 2:

[ [2, 2, 3] , [7] ]


Example Explanation
Explanation 1:

All possible combinations are listed.
Explanation 2:

All possible combinations are listed.","void generate(vector<vector<int> > &result, vector<int> &temp, int sum, int left, int B, vector<int> &A) {
    if(sum > B) return;
    if(sum == B) {
        result.push_back(temp);
        return;
    }
    for(int i=left; i<A.size();i++) {
        temp.push_back(A[i]);
        generate(result, temp, sum+A[i], i, B, A);
        temp.pop_back();
    }
}
vector<vector<int> > Solution::combinationSum(vector<int> &A, int B) {
    sort(A.begin(), A.end());
    vector<int>::iterator itr = unique(A.begin(), A.end());
    A.resize(distance(A.begin(), itr));
    vector<vector<int> > result;
    vector<int> temp;
    generate(result, temp, 0, 0, B, A);
    return result;
}"
Reverse Link List Recursion,https://www.interviewbit.com/problems/reverse-link-list-recursion/,N/A,Backtracking,easy,"Reverse a linked list using recursion.

Example :
 Given 1->2->3->4->5->NULL,

return 5->4->3->2->1->NULL.

Constraints:

The number of nodes in the list is the range [0, 5000].

-5000 <= Node.val <= 5000","/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
ListNode* Solution::reverseList(ListNode* A) {
    if (!A) {
        return A;
    }
    ListNode *first, *rest;
    first = A;
    rest = first->next;
    if (!rest) {
        return A;
    }
    rest = reverseList(rest);
    first->next->next = first;
    first->next = NULL;
    return rest;
}"
Permutations,https://www.interviewbit.com/problems/permutations/,"Google, Microsoft, Adobe",Backtracking,medium,"Given a collection of numbers, return all possible permutations.

Example:

[1,2,3] will have the following permutations:

[1,2,3]
[1,3,2]
[2,1,3] 
[2,3,1] 
[3,1,2] 
[3,2,1]
NOTE

No two entries in the permutation sequence should be the same.
For the purpose of this problem, assume that all the numbers in the collection are unique.
Warning : DO NOT USE LIBRARY FUNCTION FOR GENERATING PERMUTATIONS.

Example : next_permutations in C++ / itertools.permutations in python.

If you do, we will disqualify your submission retroactively and give you penalty points.","#include<vector>
using namespace std;
void generateAllPermutations(vector<int>& toBePermuted, unsigned int nextIndex,vector<vector<int> >& my_vec);
 
void swap(int &a,int &b)
{
    int temp=a;
    a=b;
    b=temp;
}
 
 
void generateAllPermutations(vector<int>& toBePermuted, unsigned int nextIndex,vector<vector<int> >& my_vec)
{ 
    
    if (nextIndex==toBePermuted.size()-1)  
    
    { 
        my_vec.push_back(toBePermuted); 
        return;
    
    }
  for (unsigned int i=nextIndex; i<toBePermuted.size(); i++)
  {
      swap(toBePermuted[i], toBePermuted[nextIndex]);
      generateAllPermutations(toBePermuted, nextIndex+1,my_vec);
      swap(toBePermuted[i], toBePermuted[nextIndex]);
  }
  
}
 
vector<vector<int> > Solution::permute(vector<int> &A)
 
 {
    // Do not write main() function.
    // Do not read input, instead use the arguments to the function.
    // Do not print the output, instead return values as specified
    // Still have a doubt. Checkout www.interviewbit.com/pages/sample_codes/ for more details
    
    vector<vector<int> > result;
    if(A.size()==0)
    return result;
    
    sort(A.begin(),A.end());
    generateAllPermutations(A,0,result);
    
    return result;
 
    
    
}"
Generate all Parentheses II,https://www.interviewbit.com/problems/generate-all-parentheses-ii/,"Facebook, Microsoft",Backtracking,medium,"Problem Description
 
 

Given an integer A pairs of parentheses, write a function to generate all combinations of well-formed parentheses of length 2*A.



Problem Constraints
1 <= A <= 10



Input Format
First and only argument is integer A.



Output Format
Return a sorted list of all possible parenthesis.



Example Input
Input 1:

A = 3
Input 2:

A = 1


Example Output
Output 1:

[ ""((()))"", ""(()())"", ""(())()"", ""()(())"", ""()()()"" ]
Output 2:

[ ""()"" ]


Example Explanation
Explanation 1:

 All paranthesis are given in the output list.
Explanation 2:

 All paranthesis are given in the output list.","#define pb push_back
void compute( string str, int low, int high, int n, vector <string> &ans ){
    if( low > n ) return;
    if( low == n && high == n ) ans.pb(str);
    else{
        compute( str + ""("", low + 1, high, n, ans );
        if( low > high ) compute( str + "")"", low, high + 1, n, ans );
    }
}

vector<string> Solution::generateParenthesis(int n) {
    vector <string> ans;
    compute( """", 0, 0, n, ans );
    return ans;
}"
Combination Sum II,https://www.interviewbit.com/problems/combination-sum-ii/,"Microsoft, Amazon",Backtracking,medium,"Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.

Each number in C may only be used once in the combination.

Note:

All numbers (including target) will be positive integers.
Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ? a2 ? … ? ak).
The solution set must not contain duplicate combinations.
Example :

Given candidate set 10,1,2,7,6,1,5 and target 8,

A solution set is:

[1, 7]
[1, 2, 5]
[2, 6]
[1, 1, 6]
Warning : DO NOT USE LIBRARY FUNCTION FOR GENERATING COMBINATIONS.

Example : itertools.combinations in python.

If you do, we will disqualify your submission retroactively and give you penalty points.","void gen_comb2(set<vector<int> > &ans, vector<int> curr, int start, int sum, vector<int> inp, int target){
	if(start == inp.size()){
		if(sum == target)
			ans.insert(curr);
		return;
	}
	gen_comb2(ans, curr, start+1, sum, inp, target);
	curr.push_back(inp[start]);
	gen_comb2(ans, curr, start+1, sum+inp[start], inp, target);
}

vector<vector<int> > Solution::combinationSum(vector<int> &inp, int target) {
	set<vector<int> > ans;
	vector<int> curr;
	sort(inp.begin(), inp.end());
	gen_comb2(ans, curr, 0, 0, inp, target);
	vector<vector<int> > sol(ans.begin(), ans.end());
	return sol;
}"
Nqueens,https://www.interviewbit.com/problems/nqueens/,"Google, Amazon",Backtracking,hard,"The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.

N Queens: Example 1

Given an integer n, return all distinct solutions to the n-queens puzzle.

Each solution contains a distinct board configuration of the n-queens’ placement, where 'Q' and '.' both indicate a queen and an empty space respectively.

For example,

There exist two distinct solutions to the 4-queens puzzle:

[
 ["".Q.."",  // Solution 1
  ""...Q"",
  ""Q..."",
  ""..Q.""],

 [""..Q."",  // Solution 2
  ""Q..."",
  ""...Q"",
  "".Q..""]
]","class Solution {
public:
    vector<vector<string> > solveNQueens(int n) {
        vector<vector<string> > solution;
        vector<int> arr(n);
        solveNQueensImpl(0, arr, solution);
        return solutions;
    }
    
    void solveNQueensImpl(int col, vector<int> &arr, vector<vector<string> > &solution) {
        int n = solution.size();
        if (col == n) {
            solution.push_back(solToStrings(arr));
            return;
        }
        // For each row...
        for (int row = 0; row < n; ++row) {
            // Skip if there is another queen in this column or diagonals
            if (isAvailable(arr, col, row)) {
                solution[col] = j;
                solveNQueensImpl(col + 1, arr, solution);
            }
        }
    }

    bool isAvailable(const vector<int> &arr, int col, int row) {
        for (int prev_col = 0; prev_col < col; ++prev_col) {
            if (row == arr[prev_col] ||  col + row == prev_col + arr[prev_col] || col - row == prev_col - arr[prev_col]) return false;
        }
        return true;
    }

    vector<string> solToStrings(const vector<int>& sol) {
        int n = sol.size();
        vector<string> sol_strings(n);
        for (int i = 0; i < n; ++i) {
            sol_strings[i] = string(n, '.');
            sol_strings[i][sol[i]] = 'Q';
        }
        return sol_strings;
    }
};"
Combinations,https://www.interviewbit.com/problems/combinations/,"Amazon, Adobe",Backtracking,medium,"Given two integers n and k, return all possible combinations of k numbers out of 1 2 3 ... n.

Make sure the combinations are sorted.

To elaborate,

Within every entry, elements should be sorted. [1, 4] is a valid entry while [4, 1] is not.
Entries should be sorted within themselves.
Example :

If n = 4 and k = 2, a solution is:

[
  [1,2],
  [1,3],
  [1,4],
  [2,3],
  [2,4],
  [3,4],
]
Warning : DO NOT USE LIBRARY FUNCTION FOR GENERATING COMBINATIONS.

Example : itertools.combinations in python.

If you do, we will disqualify your submission retroactively and give you penalty points.","void dfs(vector<vector<int> >& ret, vector<int>& tmp, int n, int left, int k) {
    if (k == 0) {
        ret.push_back(tmp);
        return;
    }
    for (int i = left; i <= n; ++i) {
        tmp.push_back(i);
        dfs(ret, tmp, n, i + 1, k - 1);
        tmp.pop_back();
    }
}

vector<vector<int> > Solution::combine(int n, int k) {
    vector< vector<int> > ret;
    vector<int> tmp;
    dfs(ret, tmp, n, 1, k);
    return ret;
}"
Sudoku,https://www.interviewbit.com/problems/sudoku/,"Microsoft, Uber",Backtracking,hard,"Write a program to solve a Sudoku puzzle by filling the empty cells.

Empty cells are indicated by the character '.' 

You may assume that there will be only one unique solution.



A sudoku puzzle,



and its solution numbers marked in red.

Note: You must update the input argument A (partially completed grid of Sudoku) to submit your solved Sudoko grid.

Example :

For the above given diagrams, the corresponding input to your program will be

[[53..7....], [6..195...], [.98....6.], [8...6...3], [4..8.3..1], [7...2...6], [.6....28.], [...419..5], [....8..79]]
and we would expect your program to modify the above array of array of characters to

[[534678912], [672195348], [198342567], [859761423], [426853791], [713924856], [961537284], [287419635], [345286179]]","int rowhash[9][9], colhash[9][9], blockhash[3][3][9];
bool solvesudoku(vector<vector<char> > &board, int position) {
    if (position >= 9*9) {
        return true;
    }
    int row = position / 9, col = position % 9;
    if (board[row][col] != '.') {
        return solvesudoku(board, position + 1);
    }
    for (int num = 0; num < 9; num++) {
        if (rowhash[row][num] != 1 && colhash[col][num] != 1 && blockhash[row / 3][col / 3][num] != 1) {
            // Include num in the solution 
            board[row][col] = '1' + num;
            rowhash[row][num] = 1;
            colhash[col][num] = 1;
            blockhash[row / 3][col / 3][num] = 1;
            if (solvesudoku(board, position + 1)) return true;
            // Reset
            board[row][col] = '.';
            rowhash[row][num] = 0;
            colhash[col][num] = 0;
            blockhash[row / 3][col / 3][num] = 0;
        }
    }
    return false;
}

void Solution::solveSudoku(vector<vector<char> > &board) {
    memset(rowhash, 0, sizeof(rowhash));
    memset(colhash, 0, sizeof(colhash));
    memset(blockhash, 0, sizeof(blockhash));
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            if (board[i][j] != '.') {
                int num = board[i][j] - '1';
                rowhash[i][num] = 1;
                colhash[j][num] = 1;
                blockhash[i / 3][j / 3][num] = 1;
            }
        }
    } 
    solvesudoku(board, 0);
        
}"
Modular Expression,https://www.interviewbit.com/problems/modular-expression/,N/A,Backtracking,easy,"Problem Description
 
 

Implement pow(A, B) % C.
In other words, given A, B and C, find (AB)%C. 



Problem Constraints
-106 <= A <= 109
0 <= B <= 109
0 <= C <= 109


Input Format
The first argument is an integer A.
The second argument is an integer B.
The third argument is an integer C.


Output Format
Return an integer equal to (AB) % C


Example Input
A = 2, B = 3, C = 3


Example Output
2


Example Explanation
2^3 % 3 = 8 % 3 = 2
","int Solution::Mod(int A, int B, int C) {
    A=(A%C+C)%C;
    if(B==0) return 1%C;
    if(B%2)
    return ((long long int)(A%C)*Mod(((long long int)A*A)%C,B/2,C)%C)%C;
    //even
    return Mod(((long long int)A*A)%C,B/2,C)%C;
}"
Gray Code,https://www.interviewbit.com/problems/gray-code/,Microsoft,Backtracking,medium,"Problem Description
 
 

The gray code is a binary numeral system where two successive values differ in only one bit.

Given a non-negative integer A representing the total number of bits in the code, print the sequence of gray code.

 A gray code sequence must begin with 0.



Problem Constraints
1 <= A <= 16



Input Format
The first argument is an integer A.



Output Format
Return an array of integers representing the gray code sequence.



Example Input
Input 1:

A = 2
Input 1:

A = 1


Example Output
output 1:

[0, 1, 3, 2]
output 2:

[0, 1]


Example Explanation
Explanation 1:

for A = 2 the gray code sequence is:
    00 - 0
    01 - 1
    11 - 3
    10 - 2
So, return [0,1,3,2].
Explanation 1:

for A = 1 the gray code sequence is:
    00 - 0
    01 - 1
So, return [0, 1].","vector<int> Solution::grayCode(int A) {
    vector<int> result(1, 0);        
            for (int i = 0; i < n; i++) {
                int curSize = result.size();
                // push back all element in result in reverse order
                for (int j = curSize - 1; j >= 0; j--) {
                    result.push_back(result[j] + (1 << i));
                } 
            }
            return result;
}"
Subsets II,https://www.interviewbit.com/problems/subsets-ii/,"Amazon, Microsoft",Backtracking,medium,"Given a collection of integers that might contain duplicates, S, return all possible subsets.

Note:

Elements in a subset must be in non-descending order.
The solution set must not contain duplicate subsets.
The subsets must be sorted lexicographically.
Example :

If S = [1,2,2], the solution is:

[
[],
[1],
[1,2],
[1,2,2],
[2],
[2, 2]
]","vector<vector<int> > Solution::subsetsWithDup(vector<int> &S) {
    vector<vector<int>> res;
    for(int i = 0 ; i < (1 << S.size()); ++i){
        vector<int> current;
        for(int j = 0 ; j < S.size(); ++j){
            if( (i & (1 << j)) != 0 )
                current.push_back(S[j]);
        }
        sort(current.begin(), current.end());
        res.push_back(current);
    }
    sort(res.begin(), res.end());
    auto last = std::unique(res.begin(), res.end());
    res.erase(last, res.end());
    return res;
}"
Letter Phone,https://www.interviewbit.com/problems/letter-phone/,Facebook,Backtracking,medium,"Given a digit string, return all possible letter combinations that the number could represent.

A mapping of digit to letters (just like on the telephone buttons) is given below.



The digit 0 maps to 0 itself.

The digit 1 maps to 1 itself.

Input: Digit string ""23""
Output: [""ad"", ""ae"", ""af"", ""bd"", ""be"", ""bf"", ""cd"", ""ce"", ""cf""].
Make sure the returned strings are lexicographically sorted.","void recur(string A,int x,string s, vector<string>& res);

vector<string> Solution::letterCombinations(string A) {
    vector<string> res;
    string s;
    recur(A,0,s,res);
    sort(res.begin(),res.end());
    for (int i = 0; i < res.size(); ++i) {
        res[i].pop_back();
    }
    return res;
}
void recur(string A,int x,string s, vector<string>& res){
    string s1;
    if(x>A.size()){
        res.push_back(s);
        return ;
    }
    switch(A[x]-48){
        case 0 :
            s1=""0"";
            break;
        case 1 :
            s1=""1"";
            break;
        case 2 :
            s1=""abc"";
            break;
        case 3 :
            s1=""def"";
            break;
        case 4 : 
            s1=""ghi"";
            break;
        case 5 :
            s1=""jkl"";
            break;
        case 6 : 
            s1=""mno"";
            break;
        case 7 :
            s1=""pqrs"";
            break;
        case 8 :
            s1=""tuv"";
            break;
        case 9 :
            s1=""wxyz"";
            break;
    }
//    cout<<s1;
    s.push_back(s1[0]);
    recur(A,x+1,s,res);
    s.pop_back();
    if(s1.length()>1){
        s.push_back(s1[1]);
        recur(A,x+1,s,res);
        s.pop_back();;
        s.push_back(s1[2]);
        recur(A,x+1,s,res);
        s.pop_back();
    }
    if(s1.length()==4){
        s.push_back(s1[3]);
        recur(A,x+1,s,res);
        s.pop_back();
    }
}"
Subset,https://www.interviewbit.com/problems/subset/,"Amazon, Microsoft",Backtracking,medium,"Problem Description
 
 

Given a set of distinct integers, A, return all possible subsets.

Note:
Elements in a subset must be in non-descending order.
The solution set must not contain duplicate subsets.
Also, the subsets should be sorted in ascending ( lexicographic ) order.
The list is not necessarily sorted.


Problem Constraints
0 <= |A| <= 20


Input Format
The first argument is an integer array A.


Output Format
Return array of all different possible subsets


Example Input
A = [1, 2, 3]


Example Output
[
 [],
 [1],
 [1, 2],
 [1, 2, 3],
 [1, 3],
 [2],
 [2, 3],
 [3],
]","void generateSubsets(vector<int> &S, int index, vector<int> &current, vector<vector<int> > &result) {
    if (index >= S.size()) {
        result.push_back(current);
        return;
    }
    // Ignore the current index.
    generateSubsets(S, index + 1, current, result);

    // Include the current index. 
    current.push_back(S[index]);
    generateSubsets(S, index + 1, current, result);
    current.pop_back();
}

vector<vector<int> > Solution::subsets(vector<int> &S) {  
    vector<vector<int> > result; 
    vector<int> current;
    sort(S.begin(), S.end());
    generateSubsets(S, 0, current, result);
    sort(result.begin(), result.end());
    return result;
} "
Palindrome Partitioning,https://www.interviewbit.com/problems/palindrome-partitioning/,"Amazon, Google",Backtracking,medium,"Given a string s, partition s such that every string of the partition is a palindrome.

Return all possible palindrome partitioning of s.

For example, given s = ""aab"",

Return

  [
    [""a"",""a"",""b""]
    [""aa"",""b""],
  ]
Ordering the results in the answer :

Entry i will come before Entry j if :

len(Entryi[0]) < len(Entryj[0]) OR
(len(Entryi[0]) == len(Entryj[0]) AND len(Entryi[1]) < len(Entryj[1])) OR
*
*
*
(len(Entryi[0]) == len(Entryj[0]) AND … len(Entryi[k] < len(Entryj[k]))
In the given example,

   [""a"", ""a"", ""b""] comes before [""aa"", ""b""] because len(""a"") < len(""aa"")","void get(string A,int index,vector<string> &temp,vector<vector<string> > &res){
    if(index==A.size()){res.push_back(temp);return;}
    for(int i=index;i<A.size();i++){
        string st=A.substr(index,i-index+1);
        string st2=st;reverse(st2.begin(),st2.end());
        if(st==st2){
            temp.push_back(st);
            get(A,i+1,temp,res);
            temp.pop_back();
        }
    }
}

vector<vector<string> > Solution::partition(string A) {
   vector<vector<string> > res;
   vector<string> temp;
   get(A,0,temp,res);
   return res;
}"
Substring Concatenation,https://www.interviewbit.com/problems/substring-concatenation/,Facebook,Hashing,hard,"You are given a string, S, and a list of words, L, that are all of the same length.

Find all starting indices of substring(s) in S that is a concatenation of each word in L exactly once and without any intervening characters.

Example :

S: ""barfoothefoobarman""
L: [""foo"", ""bar""]
You should return the indices: [0,9].

(order does not matter).","unsigned int myhash(const string &s) {
    unsigned int ret = 0;
    for (int i = 0; i < s.length(); i++) {
        ret = (ret * 100 + s[i]) % 9999997;
    }
    return ret;
}

bool checkSubstring(const string &S, int j, unordered_multiset<string> L) {
    int lsize = L.size(), wsize = L.begin()->size();
    for (int i = 0; i < lsize; i++) {
        if (L.find(S.substr(j + i * wsize, wsize)) == L.end()) return false;
        L.erase(L.find(S.substr(j + i * wsize, wsize)));
    }
    return true;
}

vector<int> Solution::findSubstring(string S, const vector<string> &L) {
    vector<int> ret;
    if (L.empty()) return ret;
    unsigned int hashsum = 0;
    for (int i = 0; i < L.size(); i++) 
        hashsum += myhash(L[i]);

    int wsize = L[0].size(), lsize = L.size();
    for (int i = 0; i < wsize; i++) {
        // In this loop, we will consider all starting positions in S where start % wsize = i.
        vector<unsigned int> hashes;
        int hashsum2 = 0;
        // Calculate the hash of wordsize for all start positions we are considering ( start % wsize = i ) 
        for (int j = i; j < S.size(); j += wsize) {
            hashes.push_back(myhash(S.substr(j, wsize)));
        }
        if (hashes.size() < lsize) continue;
        // Calculare the hashsum of string size lsize * wsize from index i. 
        for (int j = 0; j < lsize; j++) hashsum2 += hashes[j];
        // If hashes are same, very high probability that this is part of our solution. 
        if (hashsum == hashsum2) ret.push_back(i);

        for (int j = lsize; j < hashes.size(); j++) {
            // pop out [i, i + wsize] prefix  and include [j, j+wsize] suffix in our string. 
            // In other words, adding new wsize chars. 
            hashsum2  = hashsum2 - hashes[j - lsize] + hashes[j];
            if (hashsum == hashsum2) ret.push_back(i + (j - lsize + 1) * wsize);
        }
    }

    // check the final result
    unordered_multiset<string> Lset(L.begin(), L.end());
    vector<int> ret2;
    for (int i = 0; i < ret.size(); i++) {
        if (checkSubstring(S, ret[i], Lset)) 
            ret2.push_back(ret[i]);
    }

    return ret2;
}"
Window String,https://www.interviewbit.com/problems/window-string/,"Zenefits, Flipkart, Google, Directi",Hashing,medium,"Problem Description
 
 

Given a string A and a string B, find the window with minimum length in A, which will contain all the characters in B in linear time complexity.
 Note that when the count of a character c in B is x, then the count of c in the minimum window in A should be at least x.

Note:

If there is no such window in A that covers all characters in B, return the empty string.
If there are multiple such windows, return the first occurring minimum window ( with minimum start index and length )
 



Problem Constraints
1 <= size(A), size(B) <= 106



Input Format
The first argument is a string A.
The second argument is a string B.



Output Format
Return a string denoting the minimum window.



Example Input
Input 1:

 A = ""ADOBECODEBANC""
 B = ""ABC""
Input 2:

 A = ""Aa91b""
 B = ""ab""
 



Example Output
Output 1:

 ""BANC""
Output 2:

 ""a91b""


Example Explanation
Explanation 1:

 ""BANC"" is a substring of A which contains all characters of B.
Explanation 2:

 ""a91b"" is the substring of A which contains all characters of B.","class Solution:
    # @param S : string
    # @param T : string
    # @return a string
    def minWindow(self, S, T):
        counts = {c:0 for c in T}
        target_counts = {}
        for c in T:
            if c in target_counts:
                target_counts[c] += 1
                
            else:
                target_counts[c] = 1
                
        cover = 0
        shortest = None
        start, end = 0, 0
        while end < len(S) or cover == len(counts):
            if cover < len(counts):
                end += 1
                if S[end-1] in counts:
                    if counts[S[end-1]] == target_counts[S[end-1]] - 1:
                        cover += 1
                    counts[S[end-1]] += 1
            else:
                if S[start] in counts:
                    counts[S[start]] -= 1
                    if counts[S[start]] == target_counts[S[start]] - 1:
                        cover -= 1
                start += 1
            if cover == len(counts):
                if shortest is None or end-start < shortest[0]:
                    shortest = [end-start, start, end]
        if shortest is None:
            return """"
        return S[shortest[1]:shortest[2]]"
Longest Consecutive Sequence,https://www.interviewbit.com/problems/longest-consecutive-sequence/,"Amazon, Google, Directi, Flipkart, Uber",Hashing,easy,"Given an unsorted array of integers, find the length of the longest consecutive elements sequence.

Example: 

Given [100, 4, 200, 1, 3, 2],

The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.

Your algorithm should run in O(n) complexity.

Note:You only need to implement the given function. Do not read input, instead use the arguments to the function. Do not print the output, instead return values as specified. Still have a question? Checkout Sample Codes for more details.",N/A
4 Sum,https://www.interviewbit.com/problems/4-sum/,"Amazon, Google",Hashing,medium,"Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.

Note:

Elements in a quadruplet (a,b,c,d) must be in non-descending order. (ie, a ? b ? c ? d)
The solution set must not contain duplicate quadruplets.
Example : 

Given array S = {1 0 -1 0 -2 2}, and target = 0

A solution set is:

    (-2, -1, 1, 2)
    (-2,  0, 0, 2)
    (-1,  0, 0, 1)
Also make sure that the solution set is lexicographically sorted.

Solution[i] < Solution[j] iff Solution[i][0] < Solution[j][0] OR (Solution[i][0] == Solution[j][0] AND ... Solution[i][k] < Solution[j][k])","vector<vector<int> > Solution::fourSum(vector<int> &num, int target) {

        sort(num.begin(), num.end());
        unordered_map<int, set<pair<int, int>>> hash;
        set<vector<int>> ans;
        int n = num.size();
        for (int i = 0; i < n; i ++) {
            for (int j = i + 1; j < n; j ++) {
                int a = num[i] + num[j];
                if (hash.count(target - a)) {
                    for (auto &p: hash[target - a]) {
                        vector<int> b = {p.first, p.second, num[i], num[j]};
                        ans.insert(b);
                    }
                }
            }
            for (int j = 0; j < i; j ++) {
                int a = num[j], b = num[i];
                hash[a + b].insert(make_pair(a, b));
            }
        }
        return vector<vector<int>>(ans.begin(), ans.end());
    }"
Anagrams,https://www.interviewbit.com/problems/anagrams/,"Amazon, Microsoft",Hashing,medium,"Problem Description
 
 

Given an array A of N strings, return all groups of strings that are anagrams.

Represent a group by a list of integers representing the index(1-based) in the original list. Look at the sample case for clarification.

NOTE: Anagram is a word, phrase, or name formed by rearranging the letters, such as 'spar', formed from 'rasp'.



Problem Constraints
1 <= N <= 104

1 <= |A[i]| <= 104

Each string consists only of lowercase characters.

The sum of the length of all the strings doesn't exceed 107



Input Format
The first and only argument is an integer array A.



Output Format
Return a two-dimensional array where each row describes a group.

Note:

Ordering of the result :
 You should not change the relative ordering of the strings within the group suppose within a group containing A[i] and A[j], A[i] comes before A[j] if i < j.



Example Input
Input 1:

 A = [cat, dog, god, tca]
Input 2:

 A = [rat, tar, art]


Example Output
Output 1:

 [ [1, 4],
   [2, 3] ]
Output 2:

 [ [1, 2, 3] ]


Example Explanation
Explanation 1:

 ""cat"" and ""tca"" are anagrams which correspond to index 1 and 4 and ""dog"" and ""god"" are another set of anagrams which correspond to index 2 and 3.
 The indices are 1 based ( the first element has index 1 instead of index 0).
Explanation 2:

 All three strings are anagrams.","vector<vector<int> > Solution::anagrams(const vector<string> &A) {
    map<string,vector<int> > mp;
    vector<vector<int> > res;
    vector<int> temp;
    vector<string> sortedStrings(A.size());
    for (int i=0;i<A.size();i++){
        string ss = A[i];
        sort(ss.begin(),ss.end());
        sortedStrings[i] = ss;
        if (mp.find(ss) != mp.end()){
            temp = mp[ss];
            temp.push_back(i+1);
            mp[ss] = temp;
        }else{
            temp = vector<int>(1,i+1);
            mp[ss] = temp;
        }
    }
    for (int i=0;i<A.size();i++){
        if (mp.find(sortedStrings[i]) != mp.end()){
            res.push_back(mp[sortedStrings[i]]);
            mp.erase(sortedStrings[i]);
        }
    }
    return res;
}"
Fraction,https://www.interviewbit.com/problems/fraction/,"Amazon, Microsoft",Hashing,medium,"Problem Description
 
 

Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.

If the fractional part is repeating, enclose the repeating part in parentheses.


Problem Constraints
INTMIN <= A, B <= INTMAX


Input Format
The first integer A represents the numerator.
The second integer B represents the denominator.


Output Format
Return a string


Example Input
Input 1:
A = 1
B = 2
Input 2:
A = 2
B = 1
Input 3:
A = 2
B = 3


Example Output
Output 1:
""0.5""
Output 2:
""2""
Output 3:
""0.(6)""


Example Explanation
Explanation 1:
Given numerator = 1, denominator = 2, return ""0.5""
Explanation 1:
Given numerator = 2, denominator = 1, return ""2""
Explanation 1:
Given numerator = 2, denominator = 3, return ""0.(6)""","string Solution::fractionToDecimal(int numerator, int denominator) {
    if (numerator == 0) {
        return ""0"";
    }
    if (denominator == 0) {
        return """";
    }
    string result = """";
    //std::cout << numerator << "" "" << denominator << endl;
    if ((numerator < 0) ^ (denominator < 0)) {
        //std::cout << ""True"" << endl;
        result += ""-"";
    }
    //numerator = abs(numerator);
    //denominator = abs(denominator);
    long num = numerator, den = denominator;
    num = abs(num);
    den = abs(den);
    long res = num/den;
    result += to_string(res);
    
    long rem = (num%den)*10;
    if (rem == 0) {
        return result;
    }
    
    std::map<long, int> mp;
    result += ""."";
    while (rem != 0) {
        if (mp.find(rem) != mp.end()) {
            int beg = mp[rem];
            string part1 = result.substr(0,beg);
            string part2 = result.substr(beg, result.length()-beg);
            result = part1 + ""(""+part2+"")"";
            return result;
        }
        mp[rem] = result.length();
        res = rem/den;
        result += to_string(res);
        rem = (rem%den) *10;
    }
    return result;
}"
Points on the Straight Line,https://www.interviewbit.com/problems/points-on-the-straight-line/,"InMobi, Google, Amazon",Hashing,medium,"Problem Description
 
 

Given N points on a 2D plane, find the maximum number of points that lie on the same straight line.
You will be given 2 arrays A and B. Each point is represented by (A[i], B[i])


Problem Constraints
1 <= |A| <= 500
|A| == |B|
-109 <= Ai, Bi <= 109


Input Format
The first argument is an integer array A.
The second argument is an integer array B.


Output Format
Return an integer.


Example Input
A = [1, 2]
B = [1, 2]


Example Output
2


Example Explanation
The points on the 2D plane are (1, 1) and (2, 2). A line with the slope (m = 1) passes through both the points.","int Solution::maxPoints(vector<int> &X, vector<int> &Y) {
    
    map<double,int> mp;
    int n=X.size();
    if(n<=2)return n;
    int mx=0;
    for(int i=0;i<n;i++){
        map<double,int>cach;
        for(int j=0;j<n;j++){
            if(i==j)continue;
            double slope=1000000000;
            if(X[j]-X[i]!=0){
                slope=double(Y[i]-Y[j])/double(X[i]-X[j]);
            }
            cach[slope]++;
            mx=max(mx,cach[slope]+1);
            
        }
    }
    return mx;
}"
2 Sum,https://www.interviewbit.com/problems/2-sum/,"Facebook, Amazon, Google, Microsoft",Hashing,easy,"Problem Description
 
 

Given an array of integers, find two numbers such that they add up to a specific target number.

 

The function twoSum should return indices of the two numbers such that they add up to the target, where index1 < index2. Please note that your returned answers (both index1 and index2 ) are not zero-based. Put both these numbers in order in an array and return the array from your function ( Looking at the function signature will make things clearer ). Note that, if no pair exists, return an empty list.

If multiple solutions exist, output the one where index2 is minimum. If there are multiple solutions with the minimum index2, choose the one with minimum index1 out of them.



Problem Constraints
1 <= |A| <= 105
-108 <= Ai <= 108
-108 <= B <= 108


Input Format
The first argument is an integer array A.
The second argument is an integer B.


Output Format
Return an array of integer, representing the answer


Example Input
A: [2, 7, 11, 15]
B: 9


Example Output
[1, 2]


Example Explanation
The elements present at index 1 and index 2 add up to 9. i.e. A[1] + A[2] = 9 (1-based indexing)","vector<int> Solution::twoSum(const vector<int> &A, int B) {
    map<int,int>mymap;
    
    for(int i=0;i<A.size();i++)
    {
        if(mymap.find(B-A[i])!=mymap.end())return{mymap[B-A[i]],i+1};
        if(mymap.find(A[i])==mymap.end())mymap[A[i]]=i+1;
    }
    return {};
}"
Valid Sudoku,https://www.interviewbit.com/problems/valid-sudoku/,"Google, Amazon",Hashing,medium,"Determine if a Sudoku is valid, according to: http://sudoku.com.au/TheRules.aspx

The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’.



The input corresponding to the above configuration :

[""53..7...."", ""6..195..."", "".98....6."", ""8...6...3"", ""4..8.3..1"", ""7...2...6"", "".6....28."", ""...419..5"", ""....8..79""]
A partially filled sudoku which is valid.

Note:

A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.
Return 0 / 1 ( 0 for false, 1 for true ) for this problem","int Solution::isValidSudoku(const vector<string> &A) {
    int row[9][9]={0},col[9][9]={0},box[9][9]={0};
    
    for(int i=0;i<9;i++)
    for(int j=0;j<9;j++)
    {
        if(A[i][j]=='.')continue;
        int ind =int(A[i][j])-49;
        int bx=i-i%3+j/3;
        if(row[i][ind]||col[j][ind]||box[bx][ind]){ return 0; }
        box[bx][ind]=row[i][ind]=col[j][ind]=1;
    }
    return 1;
}"
Copy List,https://www.interviewbit.com/problems/copy-list/,"Amazon, Microsoft",Hashing,medium,"A linked list is given such that each node contains an additional random pointer which could point to any node in the list or NULL.

Return a deep copy of the list.

Example

Given list

   1 -> 2 -> 3
with random pointers going from

  1 -> 3
  2 -> 1
  3 -> 1
You should return a deep copy of the list. The returned answer should not contain the same node as the original list, but a copy of them. The pointers in the returned list should not link to any node in the original input list.","RandomListNode* Solution::copyRandomList(RandomListNode *head) {
    if(head == NULL){
        return NULL;
    }

    // Step 1: create a new node for each existing node and join them together 
    // eg: A->B->C will be A->A'->B->B'->C->C'
    RandomListNode* node = head;
    while (node != NULL) {
        RandomListNode* copyNode = new RandomListNode(node->label);
        RandomListNode* nextNode = node->next;
        node->next = copyNode;
        copyNode->next = nextNode;
        node = nextNode;
    }

    // Step2: copy the random links: for each new node n', 
    // n'.random = n.random.next
    node = head;
    while(node != NULL) {
        RandomListNode* copyNode = node->next;
        if(node->random != NULL)
            copyNode->random = node->random->next;
        else
            copyNode->random = NULL;
        node = copyNode->next;
    }

    // Step3: detach the list: 
    // basically n.next = n.next.next; n'.next = n'.next.next
    node = head;
    RandomListNode* copyNode = node->next;
    RandomListNode* copyHead = head->next;
    while(copyNode != NULL && node != NULL) {
        node->next = node->next->next;
        if (copyNode->next == NULL) {
            break;
        }
        copyNode->next = copyNode->next->next;

        copyNode = copyNode->next;
        node = node->next;
    }

    return copyHead;
}"
Diffk II,https://www.interviewbit.com/problems/diffk-ii/,Facebook,Hashing,medium,"Problem Description
 
 

Given an array A of integers and another non negative integer B .

Find if there exists 2 indices i and j such that A[i] - A[j] = B and i != j.



Problem Constraints
1 <= |A| <= 106

0 <= A[i] <= 109

0 <= B <= 109



Input Format
First argument A is an array of integer

Second argument B is an integer



Output Format
Return 1 if two such indexes are found and 0 otherwise


Example Input
Input 1:
A = [1, 5, 3]
B = 2
Input 2:
A = [2, 4, 3]
B = 3


Example Output
Output 1:
1
Output 2:
0


Example Explanation
For Input 1:
The given value of A[1] = 1 and A[3] = 3.
The value of A[3] - A[1] = 2.
For Input 2:
There are no pairs such that difference is B.","int Solution::diffPossible(const vector<int> &A, int B) {
    for (int i = 0; i < A.size(); i++) {
        for (int j = i + 1; j < A.size(); j++) {
            if (abs(A[i]-A[j]) == B) return true;
        }
    }
    return false;
}"
Longest Substring Without Repeat,https://www.interviewbit.com/problems/longest-substring-without-repeat/,Amazon,Hashing,easy,"Problem Description
 
 

Given a string A, find the length of the longest substring without repeating characters.

Note: Users are expected to solve in O(N) time complexity.



Problem Constraints
1 <= size(A) <= 106

 String consists of lowerCase,upperCase characters and digits are also present in the string A.



Input Format
Single Argument representing string A.



Output Format
Return an integer denoting the maximum possible length of substring without repeating characters.



Example Input
Input 1:

 A = ""abcabcbb""
Input 2:

 A = ""AaaA""


Example Output
Output 1:

 3
Output 2:

 2


Example Explanation
Explanation 1:

 Substring ""abc"" is the longest substring without repeating characters in string A.
Explanation 2:

 Substring ""Aa"" or ""aA"" is the longest substring without repeating characters in string A.","int Solution::lengthOfLongestSubstring(string s) {
    int start = 0, end = 0; 
    int longest = 0;

    // Hash which tracks the count of each character in the current window. 
    // We need to make sure that for a solution, none of the 
    // character count / hash value exceeds 1. 
    int hash[260]; 
    memset(hash, 0, sizeof(hash));

    while(start <= end && end < s.length()) {
        hash[s[end]]++;
        if (hash[s[end]] > 1) {
            // pop stuff out of hash till the count becomes 1.  
            while (start <= end && hash[s[end]] > 1) {
                hash[s[start]]--;
                start++;
            }
        } 
        end++;
        longest = max(longest, end - start);
    }
    return longest; 
}"
Diffk,https://www.interviewbit.com/problems/diffk/,Facebook,Two Pointers,medium,"Problem Description
 
 

Given an array 'A' of sorted integers and another non-negative integer B, find if there exist 2 indices i and j such that A[i] - A[j] = k, i != j.
Return 0 / 1 ( 0 for false, 1 for true ) for this problem
Try doing this in less than linear space complexity.


Problem Constraints
1 <= |A| <= 106
0 <= B <= 109


Input Format
The first argument is an integer array A.
The second argument is an integer B.


Output Format
Return an integer, 0 / 1 ( 0 for false, 1 for true ) for this problem


Example Input
 A : [1 3 5] 
 B : 4


Example Output
1


Example Explanation
For the given, 
 A : [1 3 5] 
 B : 4
Output : YES
as 5 - 1 = 4","int Solution::diffPossible(vector<int> &A, int B) {
    
    for(int i=0;i<A.size();i++)
    {
        for(int j=i+1;j<A.size();j++)
        {
            if(abs(A[i] - A[j]) == B) return 1; 
        }
    }
    
    return 0;
}"
Intersection Of Sorted Arrays,https://www.interviewbit.com/problems/intersection-of-sorted-arrays/,"Facebook, Google",Two Pointers,easy,"Problem Description
 
 

Find the intersection of two sorted arrays OR in other words, given 2 sorted arrays, find all the elements which occur in both arrays.

NOTE: For the purpose of this problem ( as also conveyed by the sample case ), assume that elements that appear more than once in both arrays should be included multiple times in the final output.



Problem Constraints
1 <= |A| <= 106
1 <= |B| <= 106


Input Format
The first argument is an integer array A.
The second argument is an integer array B.


Output Format
Return an array of intersection of the two arrays.


Example Input
Input 1:
A: [1 2 3 3 4 5 6]
B: [3 3 5]

Input 2:
A: [1 2 3 3 4 5 6]
B: [3 5]


Example Output
Output 1: [3 3 5]

Output 2: [3 5]


Example Explanation
Explanation 1:
3, 3, 5 occurs in both the arrays A and B
Explanation 2:
Only 3 and 5 occurs in both the arrays A and B","vector<int> Solution::intersect(const vector<int> &A, const vector<int> &B) {
    vector <int> ans;
    set_intersection(A.begin(),A.end(),B.begin(),B.end(),back_inserter(ans));
    return ans;
}"
Merge Two Sorted Lists II,https://www.interviewbit.com/problems/merge-two-sorted-lists-ii/,"Adobe, Expedia, Microsoft, Amazon",Two Pointers,medium,"Problem Description
 
 

Given two sorted integer arrays A and B, merge B into A as one sorted array.

Note: You have to modify the array A to contain the merge of A and B. Do not output anything in your code.
TIP: C users, please malloc the result into a new array and return the result.

If the number of elements initialized in A and B is m and n respectively, the resulting size of array A after your code is executed should be m + n


Problem Constraints
1 <= |A|, |B| <= 105


Input Format
The first argument is an integer array A.
The second argument is an integer array B.


Output Format
Update the array A.


Example Input
A : [1 5 8]
B : [6 9]


Example Output
Modified A : [1 5 6 8 9]","void Solution::merge(vector<int> &A, vector<int> &B) {
    int m = A.size();
    int n = B.size();
    int temp[m+n+2];
    int indexA = 0, indexB = 0;
    for (int i = 0; i < m+n; i++){
        if (indexB == n || (indexA < m && A[indexA] < B[indexB])) {
            temp[i] = A[indexA];
            indexA++;
        } else {
            temp[i] = B[indexB];
            indexB++;
        }
    }
    A.resize(m + n);
    for (int i = 0; i < m+n; i++) {
        A[i] = temp[i];
    }
    return;
}"
3 Sum,https://www.interviewbit.com/problems/3-sum/,"Facebook, Amazon, Microsoft",Two Pointers,medium,"Problem Description
 
 

Given an array A of N integers, find three integers in A such that the sum is closest to a given number B. Return the sum of those three integers.

Assume that there will only be one solution.



Problem Constraints
-3 * 108 <= B <= 3 * 108
1 <= N <= 104
-108 <= A[i] <= 108


Input Format
First argument is an integer array A of size N.

Second argument is an integer B denoting the sum you need to get close to.



Output Format
Return a single integer denoting the sum of three integers which is closest to B.



Example Input
Input 1:

A = [-1, 2, 1, -4]
B = 1
Input 2:

 
A = [1, 2, 3]
B = 6


Example Output
Output 1:

2
Output 2:

6


Example Explanation
Explanation 1:

 The sum that is closest to the target is 2. (-1 + 2 + 1 = 2)
Explanation 2:

 Take all elements to get exactly 6.","int Solution:: threeSumClosest(vector<int> &num, int target) {
    sort(num.begin(), num.end());
    long long bestSum = 1000000000, sum = 0;
    // Fix the smallest number in the three integers
    for (int i = 0; i < num.size() - 2; i++) {
        // Now num[i] is the smallest number in the three integers in the solution
        int ptr1 = i + 1, ptr2 = num.size() - 1;
        while (ptr1 < ptr2) {
            sum = num[i] + num[ptr1] + num[ptr2];
            if (abs(target - sum) < abs(target - bestSum)) {
                bestSum = sum;
            }
            if (sum > target) {
                ptr2--;
            } else {
                ptr1++;
            }
        }
    }
    return bestSum;
}"
Remove Duplicates from Sorted Array,https://www.interviewbit.com/problems/remove-duplicates-from-sorted-array/,"Amazon, Google, Microsoft, Expedia",Two Pointers,easy,"Problem Description
 
 

Given a sorted array A consisting of duplicate elements.

Your task is to remove all the duplicates and return the length of the sorted array of distinct elements consisting of all distinct elements present in A.

Note: You need to update the elements of array A by removing all the duplicates

 



Problem Constraints
1 <= |A| <= 106
1 <= Ai <= 2 * 109


Input Format
First and only argurment containing the integer array A.



Output Format
Return a single integer, as per the problem given.


Example Input
Input 1:

A = [1, 1, 2]
Input 2:

A = [1, 2, 2, 3, 3]


Example Output
Output 1:

2
Output 2:

3


Example Explanation
Explanation 1:

Updated Array: [1, 2, X] after rearranging. Note that there could be any number in place of x since we dont need it.
We return 2 here.
Explanation 2:

Updated Array: [1, 2, 3, X, X] after rearranging duplicates of 2 and 3.
We return 3 from here.","int Solution::removeDuplicates(vector<int> &A) {
    assert(A.size() >= 1 && A.size() <= 1e6);
    int count = 0, n = A.size();
	for (int i = 0; i < n; i++) { 
	    assert(A[i] >= 0 && A[i] <= 2e9);
		if (i < n - 1 && A[i] == A[i+1]) continue;
		else {
			A[count] = A[i];
			count++;
		}
	}
	return count;
}"
Sort by Color,https://www.interviewbit.com/problems/sort-by-color/,"Facebook, Microsoft",Two Pointers,medium,"Problem Description
 
 

Given an array with N objects colored red, white, or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white, and blue.

We will use the integers 0, 1, and 2 to represent red, white, and blue, respectively.

Note: Using the library sort function is not allowed.



Problem Constraints
1 <= N <= 1000000
0 <= A[i] <= 2


Input Format
First and only argument of input contains an integer array A.


Output Format
Return an integer array in asked order


Example Input
Input 1 :
    A = [0 1 2 0 1 2]
Input 2:

    A = [0]


Example Output
Output 1:
    [0 0 1 1 2 2]
Output 2:

    [0]


Example Explanation
Explanation 1:
    [0 0 1 1 2 2] is the required order.","class Solution:
    # @param A : list of integers
    # @return A after the sort
    def sortColors(self, A):
        n = len(A)
        i = 0
        j = n - 1
        k = n - 1
        while i < k:
            if A[i] == 0:
                i += 1
            elif A[i] == 1:
                if i < j:
                    A[i],A[j] = A[j],A[i]
                    j-=1
                else:
                    i+= 1
            else:
                A[i],A[k] = A[k],A[i]
                k -= 1
                if j > k:
                    j = k
        return A"
Array 3 Pointers,https://www.interviewbit.com/problems/array-3-pointers/,"Google, Microsoft, Yahoo, Facebook",Two Pointers,medium,"You are given 3 arrays A, B and C. All 3 of the arrays are sorted.

Find i, j, k such that :

max(abs(A[i] - B[j]), abs(B[j] - C[k]), abs(C[k] - A[i])) is minimized.

Return the minimum max(abs(A[i] - B[j]), abs(B[j] - C[k]), abs(C[k] - A[i]))

**abs(x) is absolute value of x and is implemented in the following manner : **

      if (x < 0) return -x;
      else return x;
Example :

Input : 
        A : [1, 4, 10]
        B : [2, 15, 20]
        C : [10, 12]

Output : 5 
         With 10 from A, 15 from B and 10 from C. ","int Solution::minimize(const vector<int> &A, const vector<int> &B, const vector<int> &C) {
    int ans = INT_MAX;
    int i = 0, j = 0, k = 0;
    while(i<A.size() && j<B.size() && k<C.size()) {
        int high_no = max(A[i], max(B[j], C[k]));
        int low_no = min(A[i], min(B[j], C[k]));
        (A[i] == low_no)?i++:(B[j] == low_no)?j++:k++;
        ans = min(ans, high_no-low_no);
    }
    return ans;
}"
Container With Most Water,https://www.interviewbit.com/problems/container-with-most-water/,"Facebook, Google, Amazon, Adobe",Two Pointers,medium,"Given n non-negative integers a1, a2, ..., an,

where each represents a point at coordinate (i, ai).

'n' vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0).

Find two lines, which together with x-axis forms a container, such that the container contains the most water.

Your program should return an integer which corresponds to the maximum area of water that can be contained ( Yes, we know maximum area instead of maximum volume sounds weird. But this is 2D plane we are working with for simplicity ).

Note: You may not slant the container.

Example :

Input : [1, 5, 4, 3]
Output : 6

Explanation : 5 and 3 are distance 2 apart. So size of the base = 2. Height of container = min(5, 3) = 3. 
So total area = 3 * 2 = 6","int Solution::maxArea(vector<int> &A) {
    int end = A.size() - 1, start = 0;
            int maxVol = 0;

            while(start < end)
            {
                maxVol = max(maxVol, (end - start) * min(A[start], A[end]));

                if (A[start] < A[end]) {
                    start++;
                } else {
                    end--;
                }
            }
            return maxVol;
}"
Remove Duplicates from Sorted Array II,https://www.interviewbit.com/problems/remove-duplicates-from-sorted-array-ii/,"Expedia, Microsoft",Two Pointers,medium,"Problem Description
 
 

Remove Duplicates from the Sorted Array
Given a sorted array, remove the duplicates in place such that each element can appear atmost twice and return the new length.
Do not allocate extra space for another array, you must do this in place with constant memory.
Note that even though we want you to return the new length, make sure to change the original array as well in place


Problem Constraints
1 <= |A| <= 106
1 <= Ai <= 2 * 109


Input Format
The first argument is an integer array A.


Output Format
Update the array and return the length of the updated array


Example Input
A = [1,1,1,2]


Example Output
3


Example Explanation
For example, Given input array A = [1,1,1,2],
Your function should return length = 3, and A is now [1,1,2].","int Solution::removeDuplicates(vector<int> &A) { 
    int count = 0, n = A.size();
    for (int i = 0; i < n; i++) { 
        if (i < n - 2 && A[i] == A[i+1] && A[i] == A[i+2]) continue;
        else {
            A[count] = A[i];
            count++;
        }
    }
    return count;
}"
Remove Element from Array,https://www.interviewbit.com/problems/remove-element-from-array/,Amazon,Two Pointers,medium,"Problem Description
 
 

Given an array A and a value B, remove all the instances of that value in the array.
Also, return the number of elements left in the array after the operation. It does not matter what is left beyond the expected length.
Try to do it in less than linear additional space complexity.


Problem Constraints
1 <= |A| <= 106
0 <= Ai , B <= 2 * 109


Input Format
The first argument is an integer array A.
The second argument is an integer B.


Output Format
Return an integer denoting the number of elements left in the array after the operation, also update the given array A.


Example Input
A = [4, 1, 1, 2, 1, 3]
B = 1


Example Output
Length  : 3 
Array A : [4, 2, 3] 



Example Explanation
If array A is [4, 1, 1, 2, 1, 3]
and the value element is 1,
then the new length is 3, and A is now [4, 2, 3]","int Solution::removeElement(vector<int> &A, int B) {
    int count = 0;
    for (int i = 0; i < A.size(); i++) { 
        if (A[i] == B) continue;
        else {
            A[count] = A[i];
            count++;
        }
    }
    return count;
}"
Implement StrStr,https://www.interviewbit.com/problems/implement-strstr/,"Facebook, Amazon, Microsoft",Strings,medium,"Another question which belongs to the category of questions which are intentionally stated vaguely. 

Expectation is that you will ask for correct clarification or you will state your assumptions before you start coding.

Problem Description
 
 

Another question which belongs to the category of questions which are intentionally stated vaguely.

Expectation is that you will ask for correct clarification or you will state your assumptions before you start coding.

Implement strStr().

strstr - locate a substring ( needle ) in a string ( haystack ).

Try not to use standard library string functions for this question.

Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

NOTE: String A is haystack, B is needle.

Good clarification questions:

What should be the return value if the needle is empty?
What if both haystack and needle are empty?
For the purpose of this problem, assume that the return value should be -1 in both cases.


Problem Constraints
1 <= |haystack| <= 104
1 <= |needle| <= 103


Input Format
The first argument is a string A (haystack)
The second argument is a string B (needle)


Output Format
Return an integer, the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.


Example Input
Input 1:
A = ""strstr""
B = ""str""
Input 2:
A = ""bighit""
B = ""bit""


Example Output
Output 1:
0
Output 1:
-1


Example Explanation
Explanation 1:
""str"" occurs at index 0 and 3.
The first occurrence is at index 0, so we return 0.
Explanation 2:
""bit"" did not occur in ""bighit"", so we return -1.","int Solution::strStr(const string haystack, const string needle) {
    assert(haystack.size() >= 1 && haystack.size() <= 9e3); 
    assert(needle.size() >= 1 && needle.size() <= 5e3);
    if (needle[0] == '\0') return 0;
    for (int i = 0; haystack[i] != '\0'; i++) {
        bool isMatched = true; 
        for (int j = 0; needle[j] != '\0'; j++) {
            // If remaining haystack length is less than needle's length, 
            // we know needle is not present in haystack.
            if (haystack[i + j] == 0) return -1;
            if (haystack[i + j] != needle[j]) {
                isMatched = false;
                break;
            }
        }
        if (isMatched) return i; // Match found
    }
    return -1;
}"
Integer To Roman,https://www.interviewbit.com/problems/integer-to-roman/,"Amazon, Facebook, Microsoft",Strings,medium,"Another question which belongs to the category of questions which are intentionally stated vaguely. 

Expectation is that you will ask for correct clarification or you will state your assumptions before you start coding.

Given an integer A, convert it to a roman numeral, and return a string corresponding to its roman numeral version

Note : This question has a lot of scope of clarification from the interviewer. Please take a moment to think of all the needed clarifications and see the expected response using “See Expected Output”

For the purpose of this question, https://projecteuler.net/about=roman_numerals has very detailed explanations.




Input Format

The only argument given is integer A.
Output Format

Return a string denoting roman numeral version of A.
Constraints

1 <= A <= 3999
For Example

Input 1:
    A = 5
Output 1:
    ""V""

Input 2:
    A = 14
Output 2:
    ""XIV""","string Solution::intToRoman(int A) {
    string M[] = {"""", ""M"", ""MM"", ""MMM""};
        // 100, 200, 300, .. 900
        string C[] = {"""", ""C"", ""CC"", ""CCC"", ""CD"", ""D"", ""DC"", ""DCC"", ""DCCC"", ""CM""};
        // 10, 20, ... 90
        string X[] = {"""", ""X"", ""XX"", ""XXX"", ""XL"", ""L"", ""LX"", ""LXX"", ""LXXX"", ""XC""};
        // 1, 2, ... 9
        string I[] = {"""", ""I"", ""II"", ""III"", ""IV"", ""V"", ""VI"", ""VII"", ""VIII"", ""IX""};
        return M[A/1000] + C[(A%1000)/100] + X[(A%100)/10] + I[A%10];
}"
Palindrome String,https://www.interviewbit.com/problems/palindrome-string/,N/A,Strings,easy,"Problem Description
 
 

Given a string, determine if it is a palindrome. While checking for a palindrome, you have to ignore spaces, case, and all special characters; i.e. consider only alphanumeric characters.

Check the sample test case for reference.
Return 0 / 1 ( 0 for false, 1 for true ) for this problem


Problem Constraints
1 <= |A| <= 106


Input Format
The first argument is a string A.


Output Format
Return 0 / 1 ( 0 for false, 1 for true ) for this problem


Example Input
Input 1:
""A man, a plan, a canal: Panama""
Input 2:
""race a car""


Example Output
Output 1:
1
Output 2:
0


Example Explanation
Explanation 1:
The input string after ignoring spaces, and all special characters is ""AmanaplanacanalPanama"" 
which is a palindrome after ignoring the case.
Explanation 2:
The input string after ignoring spaces, and all special characters is ""raceacar"" which is not a palindrome","int Solution::isPalindrome(string A) {
    int i = 0, j = (int)A.size() - 1;
    while(i < j)
    {
        while(i < j && !isalnum(A[i])) i++;
        while(i < j && !isalnum(A[j])) j--;
        if (toupper(A[i]) != toupper(A[j])) return false; 
        i++;
        j--;
    }
    return true;
}"
Longest Common Prefix,https://www.interviewbit.com/problems/longest-common-prefix/,Google,Strings,easy,"Problem Description
 
 

Given the array of strings A, you need to find the longest string S which is the prefix of ALL the strings in the array.

Longest common prefix for a pair of strings S1 and S2 is the longest string S which is the prefix of both S1 and S2.

For Example: longest common prefix of ""abcdefgh"" and ""abcefgh"" is ""abc"".



Problem Constraints
0 <= sum of length of all strings <= 1000000



Input Format
The only argument given is an array of strings A.



Output Format
Return the longest common prefix of all strings in A.



Example Input
Input 1:

A = [""abcdefgh"", ""aefghijk"", ""abcefgh""]
Input 2:

A = [""abab"", ""ab"", ""abcd""];


Example Output
Output 1:

""a""
Output 2:

""ab""


Example Explanation
Explanation 1:

Longest common prefix of all the strings is ""a"".
Explanation 2:

Longest common prefix of all the strings is ""ab"".","string Solution::longestCommonPrefix(vector<string> &A) {
    string preFix = """";
    int preCount = 0;
    bool loopAgain = true;
    bool thisCharIsOK = false;
    
    //this will break as soon as a difference in prefix is found
    while(loopAgain)
    {
    	if(preCount >= A[0].length())
    	break;
        char a = A[0][preCount];
        thisCharIsOK = true;
        
        for(int i=1;i<A.size();i++)
        {
            if(preCount > A[i].length())
            {
                thisCharIsOK = false;
                break;
            }
            if(A[i][preCount]!=a)
            {
                thisCharIsOK = false;
                break;
            }
        }
        
        if(thisCharIsOK == false)
        {
            break;
        }
        else
        {
            preFix += a;
            preCount++;
        }
    }
    //cout << preFix.size() << endl;
    return preFix;
}

/*string Solution::longestCommonPrefix(vector<string> &A) {
    int n, retLen, i, j, tempLen;
    n = A.size();
    string ret = """";
    if (n < 1) {
        return """";
    }
    ret = A[0];
    retLen = ret.length();
    for (i = 1; i < n; i++) {
        j = 0;
        tempLen = retLen < A[i].length() ? retLen : A[i].length();
        while (j < tempLen) {
            if (ret[j] != A[i][j]) {
                break;
            }
            ++j;
        }
        if (j < retLen) {
            ret = ret.substr(0,j);
            retLen = j;
        }
    }
    return ret;
}*/"
Roman To Integer,https://www.interviewbit.com/problems/roman-to-integer/,"Amazon, Facebook, Microsoft",Strings,medium,"Given a string A representing a roman numeral.

Convert A into integer.

A is guaranteed to be within the range from 1 to 3999.

NOTE: Read more 

details about roman numerals at Roman Numeric System




Input Format

The only argument given is string A.
Output Format

Return an integer which is the integer verison of roman numeral string.
For Example

Input 1:
    A = ""XIV""
Output 1:
    14

Input 2:
    A = ""XX""
Output 2:
    20","int Solution::romanToInt(string A) {
     string s=A;
     if (s.empty()) { return 0; }
        unordered_map<char, int> mp { {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000} };
        int sum = mp[s.back()];
        for (int i = s.size() - 2; i >= 0; --i) {
            sum += mp[s[i]] >= mp[s[i + 1]] ? mp[s[i]] : -mp[s[i]];
        }
        return sum;
}"
Length of Last Word,https://www.interviewbit.com/problems/length-of-last-word/,Amazon,Strings,easy,"Problem Description
 
 

Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string.

If the last word does not exist, return 0.

Note: A word is defined as a character sequence consists of non-space characters only.

Please make sure you try to solve this problem without using library functions. Make sure you only traverse the string once.



Problem Constraints
1 <= |A| <= 106


Input Format
The first argument is a string A


Output Format
Return an integer denoting the length of the last word in the string.


Example Input
Input 1:
A = "" hello world ""
Input 2:
A = ""InterviewBit""


Example Output
Output 1:
5
Output 2:
12


Example Explanation
Explanation 1:
""world"" is the last word of size 5
Explanation 2:
""InterviewBit"" is the last word of size 12","int Solution::lengthOfLastWord(const string A) {
    assert(A.size() >= 0 && A.size() <= 1e6);
    int i = A.length() - 1, j = 0;
    while(A[i] == ' ' ) i--;
    while(A[i] != ' ' && i >= 0) i--,j++;
    return j;
}"
Multiply Strings,https://www.interviewbit.com/problems/multiply-strings/,"Microsoft, Google",Strings,medium,"Problem Description
 
 

Given two numbers represented as strings, return the multiplication of the numbers as a string.
Note: 
The numbers can be arbitrarily large and are non-negative.
Your answer should not have leading zeroes. For example, 00 is not a valid answer.
DO NOT USE BIG INTEGER LIBRARIES ( WHICH ARE AVAILABLE IN JAVA / PYTHON ). We will retroactively disqualify such submissions and the submissions will incur penalties.


Problem Constraints
1 <= |A|, |B| <= 104
1 <= |A| * |B| <= 106


Input Format
The first argument is a string A, representing the first number.
The second argument is a string B, representing the second number.


Output Format
Return a string, equal to the product of A and B.


Example Input
A = ""10""
B = ""12""


Example Output
""120""


Example Explanation
A = 10 and B = 12, A * B is 120, return it in the string without leading zeroes.","string Solution::multiply(string A, string B) {
    int m = A.size(), n = B.size();
    string product;
    product.resize(m + n, '0');
    for (int i = m-1; i >= 0; --i) {
        int carry = 0;
        for (int j = n-1; j >= 0; --j) {
            int sum = (A[i] - '0') * (B[j] - '0') + (product[j+i+1] - '0') + carry;
            int rem = sum % 10;
            carry = (sum - rem) / 10;
            product[j+i+1] = rem + '0';
        }
        product[i] = carry + '0';
    }
    int i = 0;
    for (; i < product.size() - 1 && product[i] == '0'; ++i);
    if (i > 0)
        product.erase(product.begin(), product.begin() + i);
    return product;
}"
Zigzag String,https://www.interviewbit.com/problems/zigzag-string/,Paypal,Strings,medium,"The string ""PAYPALISHIRING"" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

P.......A........H.......N
..A..P....L....S....I...I....G
....Y.........I........R
And then read line by line: PAHNAPLSIIGYIR

Write the code that will take a string and make this conversion given a number of rows:

string convert(string text, int nRows);
convert(""PAYPALISHIRING"", 3) should return ""PAHNAPLSIIGYIR""
**Example 2 : **

ABCD, 2 can be written as

A....C
...B....D
and hence the answer would be ACBD.","string Solution::convert(string A, int B) {
    
    int n = A.size();
    /*if (n <= B) {
        return A;
    }*/
    if (B <= 1) {
        return A;
    }
    vector <int> place(n,0);
    string ret[B];
    for (int i=0;i<B;i++)
        ret[i]="""";
    bool down = true;
    int count = 0;
    for (int i=0;i<n;)
    {
        if (down)
        {
            if (count < B)
            {
                ret[count] +=A[i];
                count++;
		        i++;
            }
            else
            {
          	    count -= 2;
                down = false;
            }
        }
        else
        {
            if (count >=0)
            {
                ret[count] +=A[i];
                count--;
		        i++;
            }
            else
            {
                count += 2;
                down = true;
            }
        }
    }
    
    string ans = """";
    
    for (int i=0;i<B;i++)
        ans+=ret[i];
    //cout<<ans<<endl;
    return ans;
    // Do not write main() function.
    // Do not read input, instead use the arguments to the function.
    // Do not print the output, instead return values as specified
    // Still have a doubt. Checkout www.interviewbit.com/pages/sample_codes/ for more details
}"
Atoi,https://www.interviewbit.com/problems/atoi/,"Adobe, Amazon, Apple, Microsoft, Google",Strings,medium,"There are certain questions where the interviewer would intentionally frame the question vague.

The expectation is that you will ask the correct set of clarifications or state your assumptions before you jump into coding.

Implement atoi to convert a string to an integer.

Example :

Input : ""9 2704""
Output : 9
Note: There might be multiple corner cases here. Clarify all your doubts using “See Expected Output”.

Questions:

Q1. Does string contain whitespace characters before the number?

A. Yes

Q2. Can the string have garbage characters after the number?

A. Yes. Ignore it.

Q3. If no numeric character is found before encountering garbage characters, what should I do?

A. Return 0.

Q4. What if the integer overflows?

A. Return INT_MAX if the number is positive, INT_MIN otherwise.

Warning : DO NOT USE LIBRARY FUNCTION FOR ATOI.

If you do, we will disqualify your submission retroactively and give you penalty points.","int Solution::atoi(const string &str) {
    if(str == """") return 0;
        stringstream ss(str);
        int ret;
        ss>>ret;
        return ret;
}"
Valid Ip Addresses,https://www.interviewbit.com/problems/valid-ip-addresses/,"Amazon, Microsoft",Strings,medium,"Given a string containing only digits, restore it by returning all possible valid IP address combinations.

A valid IP address must be in the form of A.B.C.D, where A,B,C and D are numbers from 0-255. The numbers cannot be 0 prefixed unless they are 0.

Example:

Given “25525511135”,

return [“255.255.11.135”, “255.255.111.35”]. (Make sure the returned strings are sorted in order)","   bool valid(string &s) {
        if(!s.size()) return false;
        if(s[0] == '0' && s.size() > 1) return false;
        stringstream ss(s);
        int num;
        ss >> num;
        return num < 256;
    }
vector<string> Solution::restoreIpAddresses(string s) {
        vector<string> res;
        for(int i = 0; i < s.size(); ++ i) {
            string a = s.substr(0, i + 1); if(!valid(a)) break;
            for(int j = i + 1; j < s.size(); ++ j) {
                string b = s.substr(i + 1, j - i); if(!valid(b)) break;
                for(int k = j + 1; k < s.size(); ++ k) {
                    string c = s.substr(j + 1, k - j); if(!valid(c)) break;
                    string d = s.substr(k + 1); if(!valid(d)) continue;
                    res.push_back(a + ""."" + b + ""."" + c + ""."" + d);
                }
            }
        }
        return res;
}"
Compare Version Numbers,https://www.interviewbit.com/problems/compare-version-numbers/,Amazon,Strings,medium,"Problem Description
 
 

Compare two version numbers version1 and version2.
If version1 > version2 return 1,
If version1 < version2 return -1,
otherwise return 0.
You may assume that the version strings are non-empty and contain only digits and the . character.
The . character does not represent a decimal point and is used to separate number sequences. For instance, 2.5 is not ""two and a half"" or ""half way to version three"", it is the fifth second-level revision of the second first-level revision.

Note: Here is an example of version numbers ordering:
0.1 < 1.1 < 1.2 < 1.13 < 1.13.4


Problem Constraints
1 <= |A|, |B| <= 5000


Input Format
The first argument is a string A representing version1.
The first argument is a string B representing version2.


Output Format
Return an integer.


Example Input
A = ""1.13""

B = ""1.13.4""



Example Output
-1


Example Explanation
Version1 = ""1.13""
Version2 = ""1.13.4""
Version1 < version2, hence return -1","int Solution::compareVersion(string A, string B) {
    // Do not write main() function.
    // Do not read input, instead use the arguments to the function.
    // Do not print the output, instead return values as specified
    // Still have a doubt. Checkout www.interviewbit.com/pages/sample_codes/ for more details
    int j, i;
    for( i=0, j=0 ; i<A.size() || j<B.size() ; i++, j++){
        unsigned long long num1 = 0, num2 = 0;
        while(i < A.size() && A[i] != '.'){
            num1 *= 10;
            num1 += A[i] - '0';
            i++;
        }
        while(j < B.size() && B[j] != '.'){
            num2 *= 10;
            num2 += B[j] - '0';
            j++;
        }
        if(num1 > num2) return 1;
        if(num1 < num2) return -1;
    }
    return 0;
}"
Longest Palindromic Substring,https://www.interviewbit.com/problems/longest-palindromic-substring/,"Amazon, Microsoft, Google",Strings,medium,"Problem Description
 
 

Given a string A of size N, find and return the longest palindromic substring in A.

Substring of string A is A[i...j] where 0 <= i <= j < len(A)

Palindrome string:

A string which reads the same backwards. More formally, A is palindrome if reverse(A) = A.

Incase of conflict, return the substring which occurs first ( with the least starting index).



Problem Constraints
1 <= N <= 6000 



Input Format
First and only argument is a string A.



Output Format
Return a string denoting the longest palindromic substring of string A.



Example Input
A = ""aaaabaaa""


Example Output
""aaabaaa""


Example Explanation
We can see that longest palindromic substring is of length 7 and the string is ""aaabaaa"".","string Solution::longestPalindrome(string A) {
   int n=A.size(),i,j,k,max=1,max_i=0,max_j=0;
   for(k=0;k<n-1;k++){
       i=k;j=k+1;
       while(i >= 0 && i < n && j >= 0 && j < n && A[i]==A[j]){
            if(max<j-i+1){
               max=j-i+1;
               max_i=i;max_j=j;
           }
           i--;j++;
       }
       
   }
   //cout<<max_i<<"" ""<<max_j<<endl;
   for(k=1;k<n-1;k++){
       i=k-1;j=k+1;
       while(i >= 0 && i < n && j >= 0 && j < n && A[i]==A[j]){
           if(max<j-i+1){
               max=j-i+1;
                max_i=i;max_j=j;
            }
            i--;j++;
       }
       
   }
   //cout<<max_i<<"" ""<<max_j<<endl;
   //return A.substr(max_i, max_j-max_i+1);
  // cout<<max_i<<"" ""<<max_j<<endl;
   string res="""";//(A.begin()+max_i,A.begin()+max_j+1);
   for(i=max_i;i<=max_j;i++)res+=A[i];
   return res;
}"
Pretty Json,https://www.interviewbit.com/problems/pretty-json/,"Facebook, Microsoft",Strings,medium,"Problem Description
 
 

Given a string A representing JSON object. Return an array of strings denoting JSON object with proper indentation.

Rules for proper indentation:
Every inner brace should increase one indentation to the following lines.
Every close brace should decrease one indentation to the same line and the following lines.
The indents can be increased with an additional '\t'

Note:
[] and {} are only acceptable braces in this case.
Assume for this problem that space characters can be done away with.


Problem Constraints
1 <= |A| <= 103


Input Format
The only argument given is the integer array A.


Output Format
Return a list of strings, where each entry corresponds to a single line. The strings should not have ""\n"" character in them.


Example Input
Input 1:
    A = ""{A:""B"",C:{D:""E"",F:{G:""H"",I:""J""}}}""
Input 2:

    A = [""foo"", {""bar"":[""baz"",null,1.0,2]}]


Example Output
Output 1:
    { 
        A:""B"",
        C: 
        { 
            D:""E"",
            F: 
            { 
                G:""H"",
                I:""J""
            } 
        } 
    }
Output 2:
   [
        ""foo"", 
        {
            ""bar"":
            [
                ""baz"", 
                null, 
                1.0, 
                2
            ]
        }
    ]","vector<string> Solution::prettyJSON(string A) {
    string idn = """";
    vector<string> res;
    for(int i = 0; i < A.size(); ++ i) {
        if(A[i] == '{' || A[i] == '[' || A[i] == '}' || A[i] == ']') {
            if(A[i] == '{' || A[i] == '[') {
                res.push_back(idn + string(1, A[i]));
                idn += ""\t"";
            }
            else {
                string temp = string(1, A[i]);
                if(i + 1 < A.size() && A[i + 1] == ',') {
                    temp += A[i + 1];
                    i ++;
                }
                idn.erase(0, 1);
                res.push_back(idn + temp);
            }
            continue;
        }
        string s = """";
        while(A[i] != ',' && A[i] != '[' && A[i] != ']' && A[i] != '{' && A[i] != '}') {
            s += A[i ++];
        }
        if(A[i] == ',') s += A[i ++];
        i --;
        res.push_back(idn + s);
    }
    return res;
}"
Count And Say,https://www.interviewbit.com/problems/count-and-say/,"Facebook, Amazon, Microsoft",Strings,easy,"Problem Description

The count-and-say sequence is the sequence of integers beginning as follows: 
1, 11, 21, 1211, 111221, ...
1 is read off as one 1 or 11. 11 is read off as two 1s or 21.
21 is read off as one 2, then one 1 or 1211.

Given an integer n, generate the nth sequence.

Note: The sequence of integers will be represented as a string.

Example:

if n = 2, the sequence is 11.","string Solution::countAndSay(int A) {
    if(A == 1) return ""1"";
    if(A == 2) return ""11"";
    string rec = countAndSay(A-1), ans = """"; char last = rec[0]; int cnt = 1;
    for(int i = 1; i < rec.size(); i++){
        if(rec[i] == last) { cnt++; }
        if(rec[i] != last || i == rec.size() - 1) { 
            ans = ans + to_string(cnt) + last; 
            last = rec[i]; cnt = 1;
        }
    }
    if(last != rec[rec.size()-2]) ans = ans + to_string(cnt) + last;
    return ans;
}"
Justified Text,https://www.interviewbit.com/problems/justified-text/,"Linkedin, Google, Directi",Strings,hard,"Problem Description
 
 

Given an array of words and a length of L, format the text such that each line has exactly L characters and is fully (left and right) justified. You should pack your words in a greedy approach; that is, pack as many words as you can in each line.

 

Pad extra spaces ' ' when necessary so that each line has exactly L characters. Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right. For the last line of text, it should be left justified and no extra space is inserted between words.

Your program should return a list of strings, where each string represents a single line. 

Note: Each word is guaranteed not to exceed L in length.



Problem Constraints
0 <= |A| <= 1000
0 <= B <= 5 * 104


Input Format
The first argument is an array of strings A representing words.
The second argument is an integer B representing L.


Output Format
Return a list of strings, where each string represents a single line.


Example Input
A: [""This"", ""is"", ""an"", ""example"", ""of"", ""text"", ""justification.""]
B: 16.


Example Output
[
   ""This    is    an"",
   ""example  of text"",
   ""justification.  ""
]


Example Explanation
Given words: [""This"", ""is"", ""an"", ""example"", ""of"", ""text"", ""justification.""]
L: 16.


Return the formatted lines as:
[
   ""This    is    an"",
   ""example  of text"",
   ""justification.  ""
]","vector<string> Solution::fullJustify(vector<string> &words, int L) {
    assert(words.size() >= 0 && words.size() <= 1000);
    assert(L >= 0 && L <= 50000);
    vector<string> res;
    int k = 0, l = 0;
    for (int i = 0; i < words.size(); i += k) {
        for (k = l = 0; i + k < words.size() && l + words[i+k].size() <= L - k; k++) {
            l += words[i+k].size();
        }
        string tmp = words[i];
        for (int j = 0; j < k - 1; j++) {
            if (i + k >= words.size()) tmp += "" "";
            else tmp += string((L - l) / (k - 1) + (j < (L - l) % (k - 1)), ' ');
            tmp += words[i+j+1];
        }
        tmp += string(L - tmp.size(), ' ');
        res.push_back(tmp);
    }
    return res;
}"
Add Binary Strings,https://www.interviewbit.com/problems/add-binary-strings/,"Facebook, Microsoft",Strings,easy,"Problem Description
 
 

Given two binary strings A and B. Return their sum (also a binary string).


Problem Constraints
1 <= length of A <= 105

1 <= length of B <= 105

A and B are binary strings



Input Format
The two argument A and B are binary strings.



Output Format
Return a binary string denoting the sum of A and B



Example Input
Input 1:
A = ""100""
B = ""11""
Input 2:
A = ""110""
B = ""10""


Example Output
Output 1:
""111""
Output 2:
""1000""


Example Explanation
For Input 1:
The sum of 100 and 11 is 111.
For Input 2:
 
The sum of 110 and 10 is 1000.","string Solution::addBinary(string A, string B) {
    while(A.size() < B.size()) A = '0'+A;
    while(A.size() > B.size()) B = '0'+B;
    
    string ret = """";
    int c = 0;
    int n = A.size();
    for(int i = n-1; i>=0; i--) {
        int s = A[i]+B[i]-2*'0';
        ret = (char)((s+c)%2 + '0') + ret;
        c = (s+c)/2;
    }
    if(c) ret = '1'+ret;
    return ret;
}"
Reverse the String,https://www.interviewbit.com/problems/reverse-the-string/,"Amazon, Microsoft, Facebook",Strings,easy,"Problem Description
 
 

You are given a string A of size N.

 

Return the string A after reversing the string word by word.

NOTE:

A sequence of non-space characters constitutes a word.
Your reversed string should not contain leading or trailing spaces, even if it is present in the input string.
If there are multiple spaces between words, reduce them to a single space in the reversed string.
 



Problem Constraints
1 <= N <= 3 * 105



Input Format
The only argument given is string A.



Output Format
Return the string A after reversing the string word by word.



Example Input
Input 1:
    A = ""the sky is blue""
Input 2:
    A = ""this is ib""


Example Output
Output 1:
    ""blue is sky the""
Output 2:
    ""ib is this""



Example Explanation
Explanation 1:
    We reverse the string word by word so the string becomes ""the sky is blue"".
Explanation 2:
    We reverse the string word by word so the string becomes ""this is ib"".","string Solution::solve(string s) {
    string ans = """";
    string cur = """";
    for (int i = s.length() - 1; i >= 0; i--) {
        if (s[i] == ' ') {
            if (cur.length() == 0) {
                continue;
            }
            // found a word 
            reverse(cur.begin(), cur.end());
            if (ans.length() > 0) { 
                ans.push_back(' ');
            }
            ans += cur;
            cur = """";
            continue;
        }
        cur.push_back(s[i]);
    }
    if (cur.length() > 0) {
        reverse(cur.begin(), cur.end());
        if (ans.length() > 0) { 
            ans.push_back(' ');
        }
        ans += cur;
    }
    s = ans;
    return s ;
}"
Reverse Bits,https://www.interviewbit.com/problems/reverse-bits/,Amazon,Bit Manipulation,medium,"Problem Description

Reverse the bits of an 32 bit unsigned integer A.



Problem Constraints
0 <= A <= 232



Input Format
First and only argument of input contains an integer A.



Output Format
Return a single unsigned integer denoting the decimal value of reversed bits.



Example Input
Input 1:

 0
Input 2:

 3


Example Output
Output 1:

 0
Output 2:

 3221225472


Example Explanation
Explanation 1:

        00000000000000000000000000000000

=>      00000000000000000000000000000000
Explanation 2:

        00000000000000000000000000000011    
=>      11000000000000000000000000000000","unsigned int Solution::reverse(unsigned int A) {
  unsigned int ans=0,i,j;
  for(i=1<<31,j=1;i>=1;i/=2,j*=2)
      if(A&j){ans|=i;}
  return ans;
}"
Number of 1 Bits,https://www.interviewbit.com/problems/number-of-1-bits/,"Adobe, Yahoo",Bit Manipulation,easy,"Problem Description
 
 

Write a function that takes an integer and returns the number of 1 bits it has.


Problem Constraints
0 <= A <= 4294967295


Input Format
First and only argument contains integer A


Output Format
Return an integer as the answer


Example Input
Input1:
    11


Example Output
Output1:
3


Example Explanation
Explaination1:
11 is represented as 1101 in binary ","int Solution::numSetBits(unsigned int A) {
    assert(A >= 0 && A <= UINT_MAX );
    unsigned int total_ones = 0;
    while (A != 0) {
        A = A & (A-1);
        total_ones++;
    }
    return total_ones;
}"
Single Number,https://www.interviewbit.com/problems/single-number/,"Amazon, Uber",Bit Manipulation,easy,"Problem Description
 
 

Given an array of integers A, every element appears twice except for one. Find that single one.


NOTE: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?



Problem Constraints
1 <= |A| <= 2000000

0 <= A[i] <= INTMAX



Input Format
First and only argument of input contains an integer array A.



Output Format
Return a single integer denoting the single element.



Example Input
Input 1:

 A = [1, 2, 2, 3, 1]
Input 2:

 A = [1, 2, 2]


Example Output
Output 1:

 3
Output 2:

 1


Example Explanation
Explanation 1:

3 occurs once.
Explanation 2:

1 occurs once.","int Solution::singleNumber(const vector<int> &A) {
    
       int n = A.size();
       int result = 0;
       for (int i = 0; i < n; i++) {
	       result ^= A[i];
       }
       return result;
    
}"
Divide Integers,https://www.interviewbit.com/problems/divide-integers/,"Microsoft, Amazon",Bit Manipulation,medium,"Problem Description
 
 

Divide two integers A and B, without using multiplication, division, and mod operator.
Return the floor of the result of the division.

Also, consider if there can be overflow cases. For overflow cases, return INT_MAX.
Note: INT_MAX = 2^31 - 1


Problem Constraints
INT_MIN <= A, B <= INT_MAX
B != 0


Input Format
The first argument is an integer A.
The second argument is an integer B.


Output Format
Return an integer equal to A / B.


Example Input
A = 5
B = 2


Example Output
2


Example Explanation
A = 5, B = 2, therefore A / B = 5 / 2 = 2.5
Taking the floor value of 2.5 is 2","int Solution::divide(int dividend, int divisor) {
    long long n = dividend, m = divisor;
    // determine sign of the quotient
    int sign = n < 0 ^ m < 0 ? -1 : 1;

    // remove sign of operands
    n = abs(n), m = abs(m);

    // q stores the quotient in computation
    long long q = 0;

    // test down from the highest bit
    // accumulate the tentative value for valid bits
    for (long long t = 0, i = 31; i >= 0; i--)
        if (t + (m << i) <= n)
            t += m << i, q |= 1LL << i;

    // assign back the sign
    if (sign < 0) q = -q;

    // check for overflow and return
        return q >= INT_MAX || q < INT_MIN ? INT_MAX : q;
}
    "
Single Number II,https://www.interviewbit.com/problems/single-number-ii/,"Google, Amazon",Bit Manipulation,medium,"Problem Description
 
 

Given an array of integers, every element appears thrice except for one, which occurs once.
 Find that element that does not appear thrice.
 NOTE: Your algorithm should have a linear runtime complexity.
 Can you implement it without using extra memory?



Problem Constraints
2 <= A <= 5*106
0 <= A <= INTMAX



Input Format
First and only argument of input contains an integer array A.



Output Format
Return a single integer.



Example Input
Input 1:

 A = [1, 2, 4, 3, 3, 2, 2, 3, 1, 1]
Input 2:

 A = [0, 0, 0, 1]


Example Output
Output 1:

 4
Output 2:

 1


Example Explanation
Explanation 1:

 4 occurs exactly once in Input 1.
 1 occurs exactly once in Input 2.","int singleNumber(const vector<int> &A) {
    int n = A.size();
    int ones = 0, twos = 0, threes = 0;
    for (int i = 0; i < n; i++) {
        twos |= ones & A[i];
        ones ^= A[i];
        threes = ones & twos;
        ones &= ~threes;
        twos &= ~threes;
    }
    return ones;
}"
Matrix Search,https://www.interviewbit.com/problems/matrix-search/,Amazon,Binary Search,medium,"Problem Description
 
 

Given a matrix of integers A of size N x M and an integer B. Write an efficient algorithm that searches for integer B in matrix A. 

This matrix A has the following properties:

Integers in each row are sorted from left to right.
The first integer of each row is greater than or equal to the last integer of the previous row.
Return 1 if B is present in A, else return 0.

NOTE: Rows are numbered from top to bottom, and columns are from left to right.



Problem Constraints
1 <= N, M <= 1000

1 <= A[i][j], B <= 106



Input Format
The first argument given is the integer matrix A.

The second argument given is the integer B.



Output Format
Return 1 if B is present in A else, return 0.



Example Input
Input 1: 

A = [ 
      [1,   3,  5,  7]
      [10, 11, 16, 20]
      [23, 30, 34, 50]

    ]
B = 3
Input 2:

A = [

      [5, 17, 100, 111]
      [119, 120, 127, 131]

    ]
B = 3


Example Output
Output 1: 

1
Output 2:

0


Example Explanation
Explanation 1: 

 3 is present in the matrix at A[0][1] position so return 1.
Explanation 2:

 3 is not present in the matrix so return 0.","int Solution::searchMatrix(vector<vector<int> > &A, int B) {
    int N=A.size();
    int M=A[0].size();
    int start=0, end=N*M-1;
    while(start<=end){
        int mid=start+(end-start)/2;
        int x=mid/M;
        int y=mid%M;
        if(A[x][y]==B) return 1;
        if(B<A[x][y]) end=mid-1;
        else start=mid+1;
    }
    return 0;
}"
Count Element Occurrence,https://www.interviewbit.com/problems/count-element-occurence/,N/A,Binary Search,easy,"Given a sorted array of integers, find the number of occurrences of a given target value.

Your algorithm’s runtime complexity must be in the order of O(log n).

If the target is not found in the array, return 0

**Example : **

Given [5, 7, 7, 8, 8, 10] and target value 8,

return 2.

PROBLEM APPROACH :

For complete solution, look at the hint.","int Solution::findCount(const vector<int> &A, int B) {
    int st = lower_bound(A.begin(), A.end(), B)-A.begin();
    int ed = upper_bound(A.begin(), A.end(), B)-A.begin();
    return ed-st;
}"
Median of Array,https://www.interviewbit.com/problems/median-of-array/,"Amazon, Google, Microsoft, Hike",Binary Search,medium,"Problem Description
 
 

There are two sorted arrays A and B of size m and n respectively.

Find the median of the two sorted arrays ( The median of the array formed by merging both arrays ).

The overall run time complexity should be O(log (m+n)).

NOTE: If the number of elements in the merged array is even, then the median is the average of n / 2 th and n/2 + 1th element. For example, if the array is [1 2 3 4], the median is (2 + 3) / 2.0 = 2.5 


Problem Constraints
0 <= |A| <= 106
0 <= |B| <= 106
1 <= |A| + |B| <= 2 * 106


Input Format
The first argument is an integer array A.
The second argument is an integer array B.


Output Format
Return a double value equal to the median.


Example Input
A : [1 4 5]
B : [2 3]


Example Output
3


Example Explanation
Merged A and B will be : [1, 2, 3, 4, 5]
Its median will be 3","double Solution::findMedianSortedArrays(const vector<int> &A, const vector<int> &B) {
    int N1 = A.size();
    int N2 = B.size();
    if (N1 < N2) return findMedianSortedArrays(B, A);   
    if (N2 == 0) return (A[(N1-1)/2] + (double)A[N1/2])/2.0;

    int lo = 0, hi = N2 * 2,mid1,mid2;
    double L1,L2,R1,R2;
    while (lo <= hi) {
         mid2 = (lo + hi) / 2;  
         mid1 = N1 + N2 - mid2; 

         L1 = (mid1 == 0) ? -1000000000 : A[(mid1-1)/2]; 
         L2 = (mid2 == 0) ? -1000000000 : B[(mid2-1)/2];
         R1 = (mid1 == N1 * 2) ? 1000000000 : A[(mid1)/2];
         R2 = (mid2 == N2 * 2) ? 1000000000 : B[(mid2)/2];

        if (L1 > R2) lo = mid2 + 1;    
        else if (L2 > R1) hi = mid2 - 1;    
        else return (max(L1,L2) + min(R1, R2)) / 2;
    }
    return -1;
}"
Search for a Range,https://www.interviewbit.com/problems/search-for-a-range/,"Google, Microsoft",Binary Search,medium,"Problem Description
 
 

Given a sorted array of integers A(0 based index) of size N, find the starting and the ending position of a given integer B in array A.

Your algorithm's runtime complexity must be in the order of O(log n).

Return an array of size 2, such that the first element = starting position of B in A and the second element = ending position of B in A, if B is not found in A return [-1, -1].



Problem Constraints
1 <= N <= 106

1 <= A[i], B <= 109



Input Format
The first argument given is the integer array A.

The second argument given is the integer B.



Output Format
Return an array of size 2, such that the first element = starting position of B in A and the second element = the ending position of B in A if B is not found in A return [-1, -1].



Example Input
Input 1:

 A = [5, 7, 7, 8, 8, 10]
 B = 8
Input 2:

 A = [5, 17, 100, 111]
 B = 3


Example Output
Output 1:

 [3, 4]
Output 2:

 [-1, -1]


Example Explanation
Explanation 1:

 The first occurence of 8 in A is at index 3.
 The second occurence of 8 in A is at index 4.
 ans = [3, 4]
Explanation 2:

 There is no occurence of 3 in the array.","int search(const vector<int> &A, int B, bool first) {
    int low = 0, high = A.size()-1, ans = -1;
    while(low <= high) {
        int mid = (low+high)/2;
        if(A[mid]==B) { ans = mid; if(first) high=mid-1; else low = mid+1; }
        else if(A[mid] < B) low = mid+1;
        else high = mid-1;
    }
    return ans;
}
vector<int> Solution::searchRange(const vector<int> &A, int B) {
    vector<int> result(2);
    result[0] = search(A, B, true);
    result[1] = search(A, B, false);
    return result;
}"
Square Root of Integer,https://www.interviewbit.com/problems/square-root-of-integer/,"Facebook, Amazon, Microsoft",Binary Search,easy,"Problem Description
 
 

Given an integer A.

Compute and return the square root of A.

If A is not a perfect square, return floor(sqrt(A)).

DO NOT USE SQRT FUNCTION FROM STANDARD LIBRARY.

NOTE: Do not use sort function from standard library. Users are expected to solve this in O(log(A)) time.



Problem Constraints
0 <= A <= INTMAX


Input Format
The first and only argument given is the integer A.



Output Format
Return floor(sqrt(A))



Example Input
Input 1:

 11
Input 2:

 9


Example Output
Output 1:

 3
Output 2:

 3


Example Explanation
Explanation:

 When A = 11 , square root of A = 3.316. It is not a perfect square so we return the floor which is 3.
 When A = 9 which is a perfect square of 3, so we return 3.","int Solution::sqrt(int x) {
    assert(x >= 0 && x <= INT_MAX);
    if (x == 0) return 0;
    int start = 1, end = x, ans;
    while (start <= end) {
        int mid = (start + end) / 2;
        if (mid <= x / mid) {
            start = mid + 1;
            ans = mid;
        } else {
            end = mid - 1;
        }
    }
    return ans;
}"
Implement Power Function,https://www.interviewbit.com/problems/implement-power-function/,"Google, Linkedin",Binary Search,easy,"Problem Description
 
 

Implement pow(x, n) % d.
In other words, given x, n and d,
Find (xn % d)
Note that remainders on division cannot be negative. In other words, make sure the answer you return is non-negative integer.


Problem Constraints
-109 <= x <= 109
0 <= n <= 109
1 <= d <= 109


Example Input
Input 1:
x = 2
n = 3
d = 3
Input 2:
x = 5
n = 2
d = 6


Example Output
Output 1:
2
Output 2:
1


Example Explanation
Explanation 1:
23 % 3 = 8 % 3 = 2.
Explanation 2:
52 % 6 = 25 % 6 = 1.","int Solution::pow(int x, int n, int p) {
    assert(x >= -1e9 && x <= 1e9);
    assert(n >= 0 && n <= 1e9);
    assert(p >= 1 && p <= 1e9);
    if (n == 0) return 1 % p;

			long long ans = 1, base = x;
			while (n > 0) {
				// We need (base ** n) % p. 
				// Now there are 2 cases. 
				// 1) n is even. Then we can make base = base^2 and n = n / 2.
				// 2) n is odd. So we need base * base^(n-1) 
				if (n % 2 == 1) {
					ans = (ans * base) % p;
					n--;
				} else {
					base = (base * base) % p;
					n /= 2;
				}
			}
			if (ans < 0) ans = (ans + p) % p;
			return ans;
}"
Rotated Array,https://www.interviewbit.com/problems/rotated-array/,Facebook,Binary Search,easy,"Problem Description
 
 

Suppose a sorted array A is rotated at some pivot unknown to you beforehand.

(i.e., 1 2 4 5 6 7 might become 4 5 6 7 1 2).

Find the minimum element.

The array will not contain duplicates.

Note:- Use the circular rotated property of the array to solve the problem.


Problem Constraints
1 <= len(A) <= 105
1 <= A[i] <= 109


Input Format
The first argument is an Integer array A.


Output Format
Return the minimum element of array A.


Example Input
Input 1:-
A = [7, 2, 4, 5]
Input 2:-
A = [3, 1, 2]


Example Output
Output 1:-
2
Output 2:-
1


Example Explanation
Explanation 1:-
2 is the minimum element in the aray.
Explanation 2:-
1 is the minimum element in the array.","int Solution::findMin(const vector<int> &A) {
    int i;
    int mn=A[0];
    for(i=0; i<A.size(); i++)  mn=min(mn,A[i]);
    return mn;
}"
Rotated Sorted Array Search,https://www.interviewbit.com/problems/rotated-sorted-array-search/,"Facebook, Google, Microsoft, Amazon",Binary Search,medium,"Problem Description
 
 

Given an array of integers A of size N and an integer B.
array A is rotated at some pivot unknown to you beforehand.
(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2 ).
You are given a target value B to search. If found in the array, return its index, otherwise, return -1.
You may assume no duplicate exists in the array.

NOTE:- Array A was sorted in non-decreasing order before rotation.

Think about the case when there are duplicates. Does your current solution work? How does the time complexity change?



Problem Constraints
1 <= N <= 1000000
1 <= A[i] <= 10^9
1 <= B <= 10^9
all elements in A are distinct.



Input Format
The first argument given is the integer array A.

The second argment given is the integer B.



Output Format
Return index of B in array A, otherwise return -1



Example Input
Input 1: 

A = [4, 5, 6, 7, 0, 1, 2, 3]
B = 4 
Input 2: 

A = [5, 17, 100, 3]
B = 6


Example Output
Output 1: 

 0 
Output 2: 

 -1


Example Explanation
Explanation 1:

Target 4 is found at index 0 in A. 
Explanation 2:

Target 6 is found not found in the array A = [5, 17, 100, 3].","int Solution::search(const vector<int> &A, int B) {
    int n = A.size();
    int low = 0, high = n-1;
    while(low<=high){
        int mid = low + (high-low)/2;
        if(A[mid] == B) return mid;
        else if(A[0]<=A[mid]){//i.e. left part is sorted
            if(A[0]<=B && B < A[mid]) high = mid-1;//B lies on left part
            else low = mid+1;
        }else{//right part is sorted
            if(A[mid] < B && B<=A[n-1]) low = mid+1;//B lies on right part
            else high = mid-1;
        }
    }
    return -1;
}"
Sorted Insert Position,https://www.interviewbit.com/problems/sorted-insert-position/,Yahoo,Binary Search,easy,"Problem Description

Given a sorted array A and a target value B, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You may assume no duplicates in the array.



Problem Constraints
1 <= |A| <= 100000

1 <= B <= 109



Input Format
First argument is array A.

Second argument is integer B.



Output Format
Return an integer, the answer to the problem.



Example Input
Input 1:

 A = [1, 3, 5, 6]
B = 5
Input 2:

 A = [1, 3, 5, 6]
B = 2


Example Output
Output 1:

 2
Output 2:

 1


Example Explanation
Explanation 1:

 5 is found at index 2.
Explanation 2:

 2 will be inserted ar index 1.","int Solution::searchInsert(vector<int> &A, int B) {
    return distance(A.begin(), lower_bound(A.begin(), A.end(), B));
}"
Convert Sorted List to Binary Search Tree,https://www.interviewbit.com/problems/convert-sorted-list-to-binary-search-tree/,Google,Graph Data Structure & Algorithms,medium,"Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.

A height balanced BST : a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

Example :


Given A : 1 -> 2 -> 3
A height balanced BST  :

      2
    /   \
   1     3","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
TreeNode* _sortedArrayToBST(const vector<int> &A, int lo, int hi) {
    TreeNode* ret = NULL;
    if (lo > hi) {
        return ret;
    }
    int mid = lo + (hi-lo)/2;
    if ((hi-lo)%2) {
        ++mid;
    }
    ret = new TreeNode(A[mid]);
    ret->left = _sortedArrayToBST(A,lo,mid-1);
    ret->right = _sortedArrayToBST(A,mid+1,hi);
    return ret;
}

TreeNode* sortedArrayToBST(const vector<int> &A) {
    TreeNode* ret = NULL;
    int len = A.size();
    if (len == 0) {
        return ret;
    }
    
    ret = _sortedArrayToBST(A,0,len-1);
    return ret;
} 

TreeNode* Solution::sortedListToBST(ListNode* A) {
    if (!A) {
        return NULL;
    }
    ListNode *temp = A;
    int n = 0;
    while (temp) {
        ++n;
        temp = temp->next;
    }
    //std::cout << n << endl;
    temp = A;
    vector<int> array(n,0);
    int i = 0;
    while (temp) {
        array[i] = temp->val;
        ++i;
        temp = temp->next;
    }
    return sortedArrayToBST(array);
}"
Level Order,https://www.interviewbit.com/problems/level-order/,"Facebook, Google",Graph Data Structure & Algorithms,easy,"Problem Description
 
 

Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).



Problem Constraints
 1 <= number of nodes <= 105



Input Format
First and only argument is root node of the binary tree, A.



Output Format
Return a 2D integer array denoting the zigzag level order traversal of the given binary tree.



Example Input
Input 1:

    3
   / \
  9  20
    /  \
   15   7
Input 2:

   1
  / \
 6   2
    /
   3


Example Output
Output 1:

 [
   [3],
   [9, 20],
   [15, 7]
 ]
Output 2:

 [ 
   [1]
   [6, 2]
   [3]
 ]


Example Explanation
Explanation 1:

 Return the 2D array. Each row denotes the traversal of each level.","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
vector<vector<int> > Solution::levelOrder(TreeNode* A) {
    vector<vector<int> > ret;
    if (!A) {
        return ret;
    }
    queue<TreeNode*> currLevel, nextLevel;
    currLevel.push(A);
    vector<int> curr;
    while (!currLevel.empty()) {
        TreeNode *currNode = currLevel.front();
        currLevel.pop();
        if (currNode) {
            curr.push_back(currNode->val);
            nextLevel.push(currNode->left);
            nextLevel.push(currNode->right);
        }
        if (currLevel.empty()) {
            if (curr.size() > 0) {
                ret.push_back(curr);
            }
            curr.clear();
            swap(currLevel,nextLevel);
        }
    }
    return ret;
}"
Capture Regions on Board,https://www.interviewbit.com/problems/capture-regions-on-board/,Google,Graph Data Structure & Algorithms,hard,"Problem Description

Given a 2D character matrix A of size N x M, containing 'X' and 'O', capture all regions surrounded by 'X'.

A region is captured by flipping all 'O's into 'X's in that surrounded region.



Problem Constraints
1 <= N, M <= 103



Input Format
First and only argument 2D character matrix A of size N X M.



Output Format
Make changes to the the input only as matrix is passed by reference.



Example Input
Input 1:

 A = [  [X, X, X, X],
        [X, O, O, X],
        [X, X, O, X],
        [X, O, X, X]
     ]


Example Output
Output 1:

 A = [  [X, X, X, X],
        [X, X, X, X],
        [X, X, X, X],
        [X, O, X, X]
     ]


Example Explanation
Explanation 1:

 'O' in (4,2) is not surrounded by X from below.","int visited[1009][1009];
int dx[]={0,0,1,-1};
int dy[]={1,-1,0,0};
bool isSafe(int x,int y,int n,int m,vector<vector<char> > &A)
{
    if(x>=0 && x<n && y>=0 && y<m && visited[x][y]==0 && A[x][y]=='O')
        return true;
    return false;
}
void bfs(int x,int y,int n,int m,vector<vector<char> >&A)
{
    visited[x][y]=1;
    queue<pair<int,int> >q;
    q.push({x,y});
    while(q.empty()==false)
    {
        pair<int,int> temp=q.front();
        q.pop();
        for(int i=0;i<4;i++)
        {
            int nx=temp.first+dx[i];
            int ny=temp.second + dy[i];
            if(isSafe(nx,ny,n,m,A))
            {
                visited[nx][ny]=1;
                q.push({nx,ny});
            }
        }
    }
}
void Solution::solve(vector<vector<char> > &A) {
    int n=A.size();
    int m=A[0].size();
    memset(visited,0,sizeof(visited));
    if(n==1 || m==1)
        return;
    for(int j=0;j<m;j++)
        if(A[0][j]=='O')
            bfs(0,j,n,m,A);
    for(int i=1;i<n;i++)
        if(A[i][m-1]=='O')
            bfs(i,m-1,n,m,A);
    for(int j=0;j<=m-2;j++)
        if(A[n-1][j]=='O')
            bfs(n-1,j,n,m,A);
    for(int i=1;i<=n-2;i++)
        if(A[i][0]=='O')
            bfs(i,0,n,m,A);
    
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<m;j++)
        {
            if(A[i][j]=='O' && visited[i][j]==0)
            {
                A[i][j]='X';
            }
        }
    }
    return;
}"
Word Ladder II,https://www.interviewbit.com/problems/word-ladder-ii/,"Google, Microsoft, Ebay",Graph Data Structure & Algorithms,hard,"Problem Description
 
 

Given two words (start and end), and a dictionary, find the shortest transformation sequence from start to end, such that:
Only one letter can be changed at a time
Each intermediate word must exist in the dictionary

If there are multiple such sequences of the shortest length, return all of them.
Refer to the example for more details.

Note:
All words have the same length.
All words contain only lowercase alphabetic characters.


Input Format
The first argument is string start.
The second argument is string end.
The third argument is an array of strings dict


Output Format
Return all transformation sequences such that first word of each sequence is start and last word is end, all intermediate words belongs to dictionary(dict) and consecutive words had atmost 1 difference.


Example Input
start = ""hit""
end = ""cog""
dict = [""hot"",""dot"",""dog"",""lot"",""log""]<>/pre


Example Output
[
  [""hit"",""hot"",""dot"",""dog"",""cog""],
  [""hit"",""hot"",""lot"",""log"",""cog""]
 ]","bool isAdjacent(string a, string b) {
    if (a.size() != b.size()) {
        return false;
    }
    int n = a.size(), i;
    int mismatches = 0;
    for (i = 0; i < n; ++i) {
        if (a.at(i) != b.at(i)) {
            ++mismatches;
        }
    }
    return mismatches == 1;
}

vector<vector<int> > fetchPaths(vector<vector<int> > preds, int dest) {
    vector<vector<int> > ret;
    
    if (dest == 0) {
        return ret;
    }
    for (int i = 0; i < preds[dest].size(); ++i) {
        vector<vector<int> > temp = fetchPaths(preds, preds[dest][i]);
        if (temp.size() == 0) {
            vector<int> temp2(1, dest);
            temp.push_back(temp2);
        } else {
            for (int j = 0; j < temp.size(); ++j) {
                temp[j].push_back(dest);
            }
        }
        ret.insert(ret.end(), temp.begin(), temp.end());
    }
    return ret;

}

vector<vector<string> > Solution::findLadders(string start, 
    string end, vector<string> &dictV) {
    vector<vector<string> > ret;
    vector<string> temp;
    if(start.compare(end) == 0) {
        temp.push_back(start);
        ret.push_back(temp);
        return ret;
    }
    if (isAdjacent(start, end)) {
        temp.push_back(start);
        temp.push_back(end);
        ret.push_back(temp);
        return ret;
    }
    dictV.erase(dictV.end()-2, dictV.end());
    std::map<string, int> dictMap;
    dictMap[start] = 1;
    dictMap[end] = 1;
    std::vector<string>::iterator dict_it;
    for (dict_it = dictV.begin(); dict_it != dictV.end(); ) {
        if (dictMap.find(*dict_it) != dictMap.end()) {
            dict_it = dictV.erase(dict_it);
        } else {
            dictMap[*dict_it] = 1;
            ++dict_it;
        }
    }
    dictV.insert(dictV.begin(), start);
    dictV.push_back(end);

    int n = dictV.size(), i, j, k;
    vector<vector<bool> > graph(n, vector<bool>(n, 0));

    for (i = 0; i < n; ++i) {
        for (j = i+1; j < n; ++j) {
            graph[i][j] = isAdjacent(dictV[i], dictV[j]);
            graph[j][i] = graph[i][j];
        }
    }

    int u, min_dist = INT_MAX, alt;
    std::vector<int>::iterator uit;
    vector<int> Q(n,0), dist(n , INT_MAX);
    vector<vector<int> > pred(n, vector<int>());
    dist[0] = 0;

    for (i = 0; i < n; ++i) {
        Q[i] = i;
    }

    while (!Q.empty()) {
        uit = Q.begin();
        u = *uit;
        min_dist = dist[u];
        for(std::vector<int>::iterator it = Q.begin(); it != Q.end();
         ++it) {
            if (dist[*it] < min_dist) {
                u = *it;
                uit = it;
            }
        }
        Q.erase(uit);

        //std::cout << u << "";"" << Q.size() << std::endl;

        for(i = 0; i < n; ++i) {
            if (u >= 0 && graph[u][i] && dist[u] < INT_MAX) {
                alt = dist[u] + 1;
                if (alt < dist[i]) {
                    dist[i] = alt;
                }
            }
        }
    }
    
    if (dist[n-1] == INT_MAX) {
        return ret;
    }

    for(i = 1; i < n; ++i) {
        for (j = 0; j < n; ++j) {
            if (graph[i][j] && dist[j] + 1 == dist[i]) {
                pred[i].push_back(j);
            }
        }
    }

    /*for (i = 0; i < n; ++i) {
        cout << dictV[i] << "": "";
        for (j = 0; j < pred[i].size(); ++j) {
            cout << dictV[pred[i][j]] << ""; "";
        }
        cout << endl;
    }*/

    vector<vector<int> > paths = fetchPaths(pred, n-1);

    /*cout << paths.size() << endl;
    for (i = 0; i < paths.size(); ++i) {
        for (j = 0; j < paths[i].size(); ++j) {
            cout << paths[i][j] << ""; "";
        }
        cout << endl;
    }*/
    for (i = 0; i < paths.size(); ++i) {
    vector<string> temp(paths[i].size()+1);
    temp[0] = start;
        for (j = 0; j < paths[i].size(); ++j) {
            temp[j+1] = dictV[paths[i][j]];
        }
        ret.push_back(temp);
    }

    /*for (i = 0; i < ret.size(); ++i) {
    for (j = 0; j < ret[i].size(); ++j) {
            cout << ret[i][j] << "";"";
        }
        cout << endl;
    }*/

    return ret;
}"
Clone Graph,https://www.interviewbit.com/problems/clone-graph/,"Google, facebook, Amazon",Graph Data Structure & Algorithms,medium,"Problem Description

Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.

Note: The test cases are generated in the following format (use the following format to use See Expected Output option):

First integer N is the number of nodes.

Then, N intgers follow denoting the label (or hash) of the N nodes.

Then, N2 integers following denoting the adjacency matrix of a graph, where Adj[i][j] = 1 denotes presence of an undirected edge between the ith and jth node, O otherwise.



Problem Constraints
1 <= Number of nodes <= 105



Input Format
First and only argument is a node A denoting the root of the undirected graph.



Output Format
Return the node denoting the root of the new clone graph.



Example Input
Input 1:

      1
    / | \
   3  2  4
        / \
       5   6
Input 2:

      1
     / \
    3   4
   /   /|\
  2   5 7 6


Example Output
Output 1:

 Output will the same graph but with new pointers:
      1
    / | \
   3  2  4
        / \
       5   6
Output 2:

      1
     / \
    3   4
   /   /|\
  2   5 7 6


Example Explanation
Explanation 1:

 We need to return the same graph, but the pointers to the node should be different.","/**
 * Definition for undirected graph.
 * struct UndirectedGraphNode {
 *     int label;
 *     vector<UndirectedGraphNode *> neighbors;
 *     UndirectedGraphNode(int x) : label(x) {};
 * };
 */
UndirectedGraphNode *Solution::cloneGraph(UndirectedGraphNode *node) {
    if (!node) {
        return NULL;
    }
    std::queue<UndirectedGraphNode*> q;
    std::map<UndirectedGraphNode*, UndirectedGraphNode*> visited;
    UndirectedGraphNode *ret = new UndirectedGraphNode(node->label);
    
    q.push(node);
    visited[node] = ret;
    UndirectedGraphNode* curr, *newNode;
    vector<UndirectedGraphNode*> neighbors;
    int i, n;
    while(!q.empty()) {
        curr = q.front();
        q.pop();
        neighbors = curr->neighbors;
        n = neighbors.size();
        for (i = 0; i < n; ++i) {
            if (visited.find(neighbors[i]) != visited.end()) {
                visited[curr]->neighbors.push_back(visited[neighbors[i]]);
            } else {
                newNode = new UndirectedGraphNode(neighbors[i]->label);
                visited[neighbors[i]] = newNode;
                visited[curr]->neighbors.push_back(newNode);
                q.push(neighbors[i]);
            }
        }
    }
    return ret;
}"
Word Search Board,https://www.interviewbit.com/problems/word-search-board/,"Amazon, Google, Microsoft",Graph Data Structure & Algorithms,hard,"Given a 2D board and a word, find if the word exists in the grid.

The word can be constructed from letters of sequentially adjacent cell, where ""adjacent"" cells are those horizontally or vertically neighboring. The cell itself does not count as an adjacent cell. 

The same letter cell may be used more than once.

Example :

Given board =

[
  [""ABCE""],
  [""SFCS""],
  [""ADEE""]
]
word = ""ABCCED"", -> returns 1,
word = ""SEE"", -> returns 1,
word = ""ABCB"", -> returns 1,
word = ""ABFSAB"" -> returns 1
word = ""ABCD"" -> returns 0
Note that 1 corresponds to true, and 0 corresponds to false.","int search(vector<string> &A, string B, 
    int pos, int i, int j, vector<vector<bool> > &visitedNodes) {
    int m = A.size();
    int n = A[0].size();
    assert(n>=1 && n<= 100);
    assert(m>=1 && m<=100);
    assert(B.size()>=1 && B.size()<= 100);
    if (pos == B.size()) {
        return 1;
    }
    if (i < 0 || i >= m || j < 0 || j >= n) {
        return 0;
    }
    if (visitedNodes[i][j]) {
        return 0;
    }
    if (B.at(pos) != A[i].at(j)) {
        return 0;
    }
    //visitedNodes[i][j] = 1;
    int ret = search(A, B, pos+1, i-1, j, visitedNodes) ||
            search(A, B, pos+1, i+1, j, visitedNodes) ||
            search(A, B, pos+1, i, j-1, visitedNodes) ||
            search(A, B, pos+1, i, j+1, visitedNodes);
    //visitedNodes[i][j] = 0;
    return ret;
}
int Solution::exist(vector<string> &A, string B) {
    int m = A.size(), i, j;
    int bLen = B.size();
    if (m == 0) {
        return bLen == 0;
    }
    int n = A[0].size();
    if (n == 0) {
        return bLen == 0;
    }
    if (bLen == 0) {
        return 1;
    }
    vector<vector<bool>> visitedNodes(m, vector<bool>(n,0));
    
    for (i = 0; i < m; ++i) {
        for (j = 0; j < n; ++j) {
            if (search(A, B, 0, i, j, visitedNodes)) {
                return 1;
            }
        }
    }
    return 0;
}"
Word Ladder I,https://www.interviewbit.com/problems/word-ladder-i/,"Google, Microsoft, Ebay",Graph Data Structure & Algorithms,hard,"Problem Description
 
 

Given two words A and B, and a dictionary C, find the length of shortest transformation sequence from A to B, such that:

You must change exactly one character in every transformation.
Each intermediate word must exist in the dictionary.
NOTE:

Return 0 if there is no such transformation sequence.
All words have the same length.
All words contain only lowercase alphabetic characters.


Problem Constraints
1 <= length(A), length(B), length(C[i]) <= 25
1 <= length(C) <= 5000


Input Format
The first argument of input contains a string, A.

The second argument of input contains a string, B.

The third argument of input contains an array of strings, C.



Output Format
Return an integer representing the minimum number of steps required to change string A to string B.



Example Input
Input 1:

 A = ""hit""
 B = ""cog""
 C = [""hot"", ""dot"", ""dog"", ""lot"", ""log""]
Input 2:

 A = ""cat""
 B = ""bat""
 C = [""rat""]
Input 3:

 A = ""bait""
 B = ""pant""
 C = [""a"",""b""]


Example Output
Output 1:

 5
Output 2:

 2
Output 3:

 0


Example Explanation
Explanation 1:

 ""hit"" -> ""hot"" -> ""dot"" -> ""dog"" -> ""cog""
Explanation 2:

 ""cat"" -> ""bat""
Explanation 3:

 No intermediate words are present in the given dictionary so transformation is not possible. We will return 0 for this case.","int Solution::solve(string start, string end, vector<string> &dictV) {
    unordered_set<string> dict(dictV.begin(), dictV.end());
    unordered_map<string, int> distance; // store the distancetance from start to the current word
    queue<string> q; // FIFO for bfs purpose
    distance[start] = 1;
    q.push(start);
    dict.erase(start);
    while (!q.empty()) {
        string word = q.front(); 
        q.pop();
        if (word == end) break;
        for (int i = 0; i < word.size(); i++) {
            for (int j = 0; j < 26; j++) {
                string newWord = word;
                newWord[i] = 'a' + j;
                if (dict.find(newWord) != dict.end() && distance.find(newWord) == distance.end()) {
                    distance[newWord] = distance[word] + 1;
                    q.push(newWord);
                    dict.erase(newWord);
                }
            }
        }
    }
    if (distance.find(end) == distance.end()) return 0; // not found
    return distance[end];
}"
Inorder Traversal,https://www.interviewbit.com/problems/inorder-traversal/,"Amazon, Microsoft, Grofers",Tree Data Structure,easy,"Problem Description
 
 

Given a binary tree, return the inorder traversal of its nodes values.

NOTE: Using recursion is not allowed.



Problem Constraints
 1 <= number of nodes <= 105



Input Format
First and only argument is root node of the binary tree, A.



Output Format
Return an integer array denoting the inorder traversal of the given binary tree.



Example Input
Input 1:

   1
    \
     2
    /
   3
Input 2:

   1
  / \
 6   2
    /
   3


Example Output
Output 1:

 [1, 3, 2]
Output 2:

 [6, 1, 3, 2]


Example Explanation
Explanation 1:

 The Inorder Traversal of the given tree is [1, 3, 2].
Explanation 2:

 The Inorder Traversal of the given tree is [6, 1, 3, 2].","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
vector<int> Solution::inorderTraversal(TreeNode* A) {
    vector<int> ret;
    if (!A) {
        return ret;
    }
    stack<TreeNode*> S;
    TreeNode* curr = A;
    while (curr || !S.empty()) {
        if (curr) {
            S.push(curr);
            curr = curr->left;
        } else {
            TreeNode * temp = S.top();
            S.pop();
            ret.push_back(temp->val);
            curr = temp->right;
        }
    }
    return ret;
}"
Next Greater Number BST,https://www.interviewbit.com/problems/next-greater-number-bst/,N/A,Tree Data Structure,easy,"Given a BST node, return the node which has value just greater than the given node.

Example:

Given the tree

               100
              /   \
            98    102
           /  \
         96    99
          \
           97
Given 97, you should return the node corresponding to 98 as thats the value just greater than 97 in the tree.

If there are no successor in the tree ( the value is the largest in the tree, return NULL).

Using recursion is not allowed.

Assume that the value is always present in the tree.","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
TreeNode* Solution::getSuccessor(TreeNode* A, int B) {
    TreeNode* temp, *temp1 = NULL;
    if (!A) {
        return A;
    }
    temp = A;
    //std::cout << temp->val << "";"";
    while (temp && temp->val != B) {
        if (temp->val < B) {
            temp = temp->right;
        } else {
            temp1 = temp;
            temp = temp->left;
        }
    }
    // Now temp is the node
    if (temp && temp->right) {
        temp = temp->right;
        while (temp->left) {
            temp = temp->left;
        }
        return temp;
    }
    return temp1;
}"
Recover Binary Search Tree,https://www.interviewbit.com/problems/recover-binary-search-tree/,"Microsoft, Amazon",Tree Data Structure,hard,"Two elements of a binary search tree (BST) are swapped by mistake.

Tell us the 2 values swapping which the tree will be restored.

Note:

A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?

Example :


Input : 
         1
        / \
       2   3

Output : 
       [1, 2]

Explanation : Swapping 1 and 2 will change the BST to be 
         2
        / \
       1   3
which is a valid BST      ","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
/*vector<int> _inorder(TreeNode* A) {
    vector<int> ret;
    if (!A) {
        return ret;
    }
    stack<TreeNode*> S;
    TreeNode* curr = A;
    while (curr || !S.empty()) {
        if (curr) {
            S.push(curr);
            curr = curr->left;
        } else {
            TreeNode * temp = S.top();
            S.pop();
            ret.push_back(temp->val);
            curr = temp->right;
        }
    }
    return ret;
}*/
vector<int> _inorder(TreeNode* A) {
    vector<int> ret;
    if (!A) {
        return ret;
    }
    vector<int> left = _inorder(A->left);
    ret.insert(ret.end(), left.begin(), left.end());
    ret.push_back(A->val);
    vector<int> right = _inorder(A->right);
    ret.insert(ret.end(), right.begin(), right.end());
    return ret;
}
vector<int> Solution::recoverTree(TreeNode* A) {
    vector<int> inOrder = _inorder(A);
    vector<int> ret;
    int i, temp = -1;
    for (i = 0; i < inOrder.size()-1; ++i) {
        //std::cout << inOrder[i] << std::endl;
        if (inOrder[i] > inOrder[i+1]) {
            if (temp == -1) {
                temp = i;
                ret.push_back(inOrder[i]);
            } else {
                ret.insert(ret.begin(),inOrder[i+1]);
            }
            if (ret.size() == 2) {
                break;
            }
        }
    }
    //std::cout << temp << "";"" << inOrder.size() << endl;
    if (ret.size() != 2) {
        ret.insert(ret.begin(),inOrder[temp+1]);
    }
    //std::cout << inOrder[inOrder.size()-1] << std::endl;
    return ret;
}

/*void correctBSTUtil( TreeNode* root, TreeNode** first,
                     TreeNode** middle, TreeNode** last,
                     TreeNode** prev )
{
    if( root )
    {
        // Recur for the left subtree
        correctBSTUtil( root->left, first, middle, last, prev );
 
        // If this node is smaller than the previous node, it's violating
        // the BST rule.
        if (*prev && root->val < (*prev)->val)
        {
            // If this is first violation, mark these two nodes as
            // 'first' and 'middle'
            if ( !*first )
            {
                *first = *prev;
                *middle = root;
            }
 
            // If this is second violation, mark this node as last
            else
                *last = root;
        }
 
        // Mark this node as previous
        *prev = root;
 
        // Recur for the right subtree
        correctBSTUtil( root->right, first, middle, last, prev );
    }
}
 
// A function to fix a given BST where two nodes are swapped.  This
// function uses correctBSTUtil() to find out two nodes and swaps the
// nodes to fix the BST
void correctBST(TreeNode* root, vector<int> &ret)
{
    // Initialize pointers needed for correctBSTUtil()
    TreeNode *first, *middle, *last, *prev;
    first = middle = last = prev = NULL;
 
    // Set the poiters to find out two nodes
    correctBSTUtil( root, &first, &middle, &last, &prev );
 
    // Fix (or correct) the tree
    if( first && last ) {
        ret.push_back(last->val);
        ret.push_back(first->val);
        //swap( &(first->data), &(last->data) );
    } else if( first && middle ) { // Adjacent nodes swapped
        ret.push_back(middle->val);
        ret.push_back(first->val);
        //swap( &(first->data), &(middle->data) );
    }
 
    // else nodes have not been swapped, passed tree is really BST.
}

vector<int> Solution::recoverTree(TreeNode* A) {
    vector<int> ret;
    correctBST(A,ret);
    return ret;
}*/"
Inorder Traversal of Cartesian Tree,https://www.interviewbit.com/problems/inorder-traversal-of-cartesian-tree/,"Amazon, Facebook",Tree Data Structure,medium,"Given an inorder traversal of a cartesian tree, construct the tree.

Cartesian tree :  is a heap ordered binary tree, where the root is greater than all the elements in the subtree.

Note: You may assume that duplicates do not exist in the tree.

Example :

Input : [1 2 3]

Return :   
          3
         /
        2
       /
      1","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
int _maxIdx(vector<int> &A, int lo, int hi) {
    if (lo > hi) {
        return -1;
    }
    int ret = lo, currMax = A[lo], i;
    for (i = lo+1; i <= hi; ++i) {
        if (A[i] > currMax) {
            currMax = A[i];
            ret = i;
        }
    }
    return ret;
}
TreeNode* _buildTree(vector<int> &A, int lo, int hi) {
    if (lo > hi) {
        return NULL;
    }
    int maxIdx = _maxIdx(A,lo,hi);
    int maxElem = A[maxIdx];
    TreeNode *ret = new TreeNode(maxElem);
    ret->left = _buildTree(A,lo,maxIdx-1);
    ret->right = _buildTree(A,maxIdx+1,hi);
    return ret;
}
TreeNode* Solution::buildTree(vector<int> &A) {
    if (A.empty()) {
        return NULL;
    }
    return _buildTree(A,0,A.size()-1);
}"
Least Common Ancestor,https://www.interviewbit.com/problems/least-common-ancestor/,"Facebook, Adobe, Microsoft, Amazon, Google",Tree Data Structure,medium,"Problem Description
 
 

Find the lowest common ancestor in an unordered binary tree given two values in the tree.

Lowest common ancestor: the lowest common ancestor (LCA) of two nodes v and w in a tree or directed acyclic graph (DAG) is the lowest (i.e. deepest) node that has both v and w as descendants.

Note:
You are given 2 values. Find the lowest common ancestor of the two nodes represented by val1 and val2
No guarantee that val1 and val2 exist in the tree. If one value doesn't exist in the tree then return -1.
There are no duplicate values.
You can use extra memory, and helper functions, and can modify the node struct but, you can't add a parent pointer.


Input Format
The first argument is a TreeNode A, pointing to the root of the binary tree.
The second argument is an integer B.
The third argument is an integer C.


Output Format
Return an integer, equal to the value of the LCA of B and C.


Example Input


        _______3______
       /              \
    ___5__          ___1__
   /      \        /      \
   6      _2_     0        8
         /   \
         7    4


B = 5
C = 1



Example Output
3


Example Explanation


        _______3______
       /              \
    ___5__          ___1__
   /      \        /      \
   6      _2_     0        8
         /   \
         7    4

For the above tree, the LCA of nodes 5 and 1 is 3.
Please note that LCA for nodes 5 and 4 is 5.","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
bool findPath(TreeNode *root, vector<int> &path, int k)
{
    // base case
    if (root == NULL) return false;
 
    // Store this node in path vector. The node will be removed if
    // not in path from root to k
    path.push_back(root->val);
 
    // See if the k is same as root's key
    if (root->val == k)
        return true;
 
    // Check if k is found in left or right sub-tree
    if ( (root->left && findPath(root->left, path, k)) ||
         (root->right && findPath(root->right, path, k)) )
        return true;
 
    // If not present in subtree rooted with root, remove root from
    // path[] and return false
    path.pop_back();
    return false;
}
 
int Solution::lca(TreeNode* A, int val1, int val2) {
    
    vector<int> path1, path2;
 
    // Find paths from root to n1 and root to n1. If either n1 or n2
    // is not present, return -1
    if ( !findPath(A, path1, val1) || !findPath(A, path2, val2))
          return -1;
 
    /* Compare the paths to get the first different value */
    int i;
    for (i = 0; i < path1.size() && i < path2.size() ; ++i)
        if (path1[i] != path2[i])
            break;
    return path1[i-1];
}"
Construct Binary Tree From Inorder And Preorder,https://www.interviewbit.com/problems/construct-binary-tree-from-inorder-and-preorder/,"Amazon, Microsoft",Tree Data Structure,medium,"Problem Description
 
 

Given preorder and inorder traversal of a tree, construct the binary tree.
Note: You may assume that duplicates do not exist in the tree.


Problem Constraints
1 <= |A| <= 105
|A| == |B|


Input Format
The first argument is an integer array A representing the preorder traversal.
The second argument is an integer array B representing the inorder traversal.


Output Format
Return the pointer to the root node of the tree.


Example Input
Preorder : [1, 2, 3]
Inorder  : [2, 1, 3]


Example Output
            1
           / \
          2   3","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
 TreeNode *buildTreeTmp(vector<int>::iterator prel, vector<int>::iterator prer, vector<int>::iterator inl, vector<int>::iterator inr) {
    if (prel >= prer)
        return NULL;

    int val = *prel;
    TreeNode *root = new TreeNode(val);

    vector<int>::iterator rootIndex = find(inl, inr, val); 
    vector<int>::size_type lsize = rootIndex - inl;

    root->left = buildTreeTmp(prel + 1, prel + 1 + lsize, inl, rootIndex);
    root->right = buildTreeTmp(prel + 1 + lsize, prer, rootIndex + 1, inr);

    return root;
}
 
TreeNode* Solution::buildTree(vector<int> &preorder, vector<int> &inorder) {
    return preorder.size() == 0 ? NULL : buildTreeTmp(preorder.begin(), preorder.end(), inorder.begin(), inorder.end());
}"
Flatten Binary Tree to Linked List,https://www.interviewbit.com/problems/flatten-binary-tree-to-linked-list/,"Adobe, Amazon, Microsoft",Tree Data Structure,hard,"Problem Description
 
 

Given a binary tree A, flatten it to a linked list in-place.

The left child of all nodes should be NULL.



Problem Constraints
1 <= size of tree <= 100000



Input Format
First and only argument is the head of tree A.



Output Format
Return the linked-list after flattening.



Example Input
Input 1:

     1
    / \
   2   3
Input 2:

         1
        / \
       2   5
      / \   \
     3   4   6


Example Output
Output 1:

1
 \
  2
   \
    3
Output 2:

1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6


Example Explanation
Explanation 1:

 Tree flattening looks like this.
Explanation 2:

 Tree flattening looks like this.","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
TreeNode* Solution::flatten(TreeNode* A) {
    TreeNode *ret = A;
    while (A) {
        if (A->left) {
            TreeNode *temp = A->left;
            while (temp->right) {
                temp = temp->right;
            }
            temp->right = A->right;
            A->right = A->left;
            A->left = NULL;
        }
        A = A->right;
    }
    return ret;
}"
Valid Binary Search Tree,https://www.interviewbit.com/problems/valid-binary-search-tree/,"Amazon, Facebook",Tree Data Structure,easy,"Given a binary tree, determine if it is a valid binary search tree (BST).

Assume a BST is defined as follows:

The left subtree of a node contains only nodes with keys less than the node’s key.
The right subtree of a node contains only nodes with keys greater than the node’s key.
Both the left and right subtrees must also be binary search trees.
Example :

Input : 
   1
  /  \
 2    3

Output : 0 (False)


Input : 
  2
 / \
1   3

Output : 1 (True) 
Return 0 / 1 ( 0 for false, 1 for true ) for this problem

SOLUTION APPROACH :

        VIDEO : https://www.youtube.com/watch?v=yEwSGhSsT0U",N/A
Preorder Traversal,https://www.interviewbit.com/problems/preorder-traversal/,"Amazon, Microsoft",Tree Data Structure,medium,"Given a binary tree, return the preorder traversal of its nodes’ values.

Example :

Given binary tree

   1
    \
     2
    /
   3
return [1,2,3].

Using recursion is not allowed.","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
vector<int> Solution::preorderTraversal(TreeNode* A) {
    vector<int> ret;
    if (!A) {
        return ret;
    }
    stack<TreeNode*> S;
    S.push(A);
    while (!S.empty()) {
        TreeNode * temp = S.top();
        S.pop();
        ret.push_back(temp->val);
        if (temp->right) {
            S.push(temp->right);
        }
        if (temp->left) {
            S.push(temp->left);
        }
    }
    return ret;
}"
Max Depth of Binary Tree,https://www.interviewbit.com/problems/max-depth-of-binary-tree/,"Facebook, Microsoft",Tree Data Structure,medium,"Given a binary tree, find its maximum depth.

The maximum depth of a binary tree is the number of nodes along the longest path from the root node down to the farthest leaf node.

NOTE : The path has to end on a leaf node.

Example :

         1
        /
       2
max depth = 2.","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
int Solution::maxDepth(TreeNode* A) {
    if (!A) {
        return 0;
    }
    return 1 + std::max(maxDepth(A->left), maxDepth(A->right));
}"
Binary Tree From Inorder And Postorder,https://www.interviewbit.com/problems/binary-tree-from-inorder-and-postorder/,"Amazon, Microsoft",Tree Data Structure,medium,"Given inorder and postorder traversal of a tree, construct the binary tree.

Note: You may assume that duplicates do not exist in the tree.

Example :

Input : 
        Inorder : [2, 1, 3]
        Postorder : [2, 3, 1]

Return : 
            1
           / \
          2   3","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
int search(vector<int> &arr, int value, int strt, int end) {
    int i = -1;
    for(i = strt; i <= end; ++i) {
        if(arr[i] == value)
            return i;
    }
    return i;
}

TreeNode* _buildTree(vector<int> &inorder, vector<int> &postorder, 
int inlo, int inhi, int postlo, int posthi) {
    //std::cout << inlo << "";"" << inhi << "";"" << postlo << "";"" << posthi << std::endl;
    if (inlo > inhi || postlo > posthi) {
        return NULL;
    }
    //std::cout << postorder[posthi] << "";"";
    TreeNode *temp = new TreeNode(postorder[posthi]);
    
    int tempIdx = search(inorder, temp->val, inlo, inhi);
    //std::cout << temp->val << "";"" << tempIdx << std::endl;
    temp->left = _buildTree(inorder,postorder,inlo, tempIdx-1, postlo, postlo+tempIdx-inlo-1);
    temp->right = _buildTree(inorder,postorder,tempIdx+1, inhi, postlo+tempIdx-inlo, posthi-1);
    
    return temp;
}
TreeNode* Solution::buildTree(vector<int> &inorder, vector<int> &postorder) {
    int len = inorder.size();//, i;
    /*std::cout << ""Inorder"" << std::endl;
    for (i = 0; i < len; i++) {
        std::cout << inorder[i] << "";"";
    }
    std::cout << endl;
    std::cout << ""Postorder"" << std::endl;
    for (i = 0; i < len; i++) {
        std::cout << postorder[i] << "";"";
    }
    std::cout << endl;*/
    return _buildTree(inorder, postorder, 0, len-1, 0, len-1);
}"
Balanced Binary Tree,https://www.interviewbit.com/problems/balanced-binary-tree/,Amazon,Tree Data Structure,easy,"Problem Description
 
 

Given a root of binary tree A, determine if it is height-balanced.

A height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.



Problem Constraints
1 <= size of tree <= 100000



Input Format
First and only  argument is the root of the tree A.



Output Format
Return 0 / 1 ( 0 for false, 1 for true ) for this problem.



Example Input
Input 1:

    1
   / \
  2   3
Input 2:

 
       1
      /
     2
    /
   3


Example Output
Output 1:

1
Output 2:

0


Example Explanation
Explanation 1:

It is a complete binary tree.
Explanation 2:

Because for the root node, left subtree has depth 2 and right subtree has depth 0. 
Difference = 2 > 1. ","/*
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
pair<int, bool> isBalancedWithDepth(TreeNode *root) {
    if (root == NULL) return make_pair(0, true);
    pair<int, bool> left = isBalancedWithDepth(root->left);
    pair<int, bool> right = isBalancedWithDepth(root->right);
    int depth = max(right.first, left.first) + 1;
    // The subtree is balanced if right subtree is balanced, left subtree is balanced 
    // and the depth difference is less than 1. 
    bool isbalanced = right.second && left.second && (abs(right.first - left.first) < 2);
    return make_pair(depth, isbalanced);
}
int Solution::isBalanced(TreeNode* root) {
        if (root == NULL) return true;
        return isBalancedWithDepth(root).second;
}"
Sorted Array To Balanced BST,https://www.interviewbit.com/problems/sorted-array-to-balanced-bst/,Amazon,Tree Data Structure,easy,"Problem Description
 
 

Given an array where elements are sorted in ascending order, convert it to a height Balanced Binary Search Tree (BBST).

Balanced tree : a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.



Problem Constraints
1 <= length of array <= 100000



Input Format
First argument is an integer array A.



Output Format
Return a root node of the Binary Search Tree.



Example Input
Input 1:

 A : [1, 2, 3]
Input 2:

 A : [1, 2, 3, 5, 10]


Example Output
Output 1:

      2
    /   \
   1     3
Output 2:

      3
    /   \
   2     5
  /       \
 1         10


Example Explanation
Explanation 1:

 You need to return the root node of the Binary Tree.","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
TreeNode* sortedArrayToBSTQ(const vector<int>& arr, 
                        int start, int end)  
{  
    /* Base Case */
    if (start > end)  
    return NULL;  
  
    /* Get the middle element and make it root */
    int mid = (start + end)/2;  
    TreeNode *root = new TreeNode(arr[mid]);  
  
    /* Recursively construct the left subtree  
    and make it left child of root */
    root->left = sortedArrayToBSTQ(arr, start,  
                                    mid - 1);  
  
    /* Recursively construct the right subtree  
    and make it right child of root */
    root->right = sortedArrayToBSTQ(arr, mid + 1, end);  
  
    return root;  
}  
TreeNode* Solution::sortedArrayToBST(const vector<int> &A) {
    TreeNode *root = sortedArrayToBSTQ(A,0,A.size()-1);
    return root;
}"
Sum Root to Leaf Numbers,https://www.interviewbit.com/problems/sum-root-to-leaf-numbers/,"Google, Microsoft",Tree Data Structure,medium,"Problem Description
 
 

Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.
An example is the root-to-leaf path 1->2->3 which represents the number 123.
Find the total sum of all root-to-leaf numbers % 1003.


Problem Constraints
0 <= Node.val <= 9


Input Format
The first argument is TreeNode A, pointing to the root of the tree.


Output Format
Return an integer equal to the total sum of all root-to-leaf numbers % 1003.


Example Input
    1
   / \
  2   3


Example Output
25


Example Explanation
    1
   / \
  2   3
The root-to-leaf path 1->2 represents the number 12.
The root-to-leaf path 1->3 represents the number 13.

Return the sum = (12 + 13) % 1003 = 25 % 1003 = 25.","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
int solve(TreeNode *root, int curSum) {
    if (root == NULL) return curSum;
    curSum = (curSum * 10 + root->val) % 1003;
    if (root->left == NULL && root->right == NULL) return curSum;
    if (!root->left) return solve(root->right, curSum);
    if (!root->right) return solve(root->left, curSum);
    return (solve(root->left, curSum) + solve(root->right, curSum)) % 1003;
}
int Solution::sumNumbers(TreeNode* A) {
    return solve(A, 0); 
}"
Symmetric Binary Tree,https://www.interviewbit.com/problems/symmetric-binary-tree/,"Amazon, Zomato",Tree Data Structure,easy,"Problem Description
 
 

Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).



Problem Constraints
1 <= number of nodes <= 105



Input Format
First and only argument is the root node of the binary tree.



Output Format
Return 0 / 1 ( 0 for false, 1 for true ).



Example Input
Input 1:

    1
   / \
  2   2
 / \ / \
3  4 4  3
Input 2:

    1
   / \
  2   2
   \   \
   3    3


Example Output
Output 1:

 1
Output 2:

 0


Example Explanation
Explanation 1:

 The above binary tree is symmetric. 
Explanation 2:

The above binary tree is not symmetric.","bool isSymmetricHelper(TreeNode *leftTree, TreeNode *rightTree) {
    if (leftTree == NULL || rightTree == NULL) return leftTree == rightTree;
    if (leftTree->val != rightTree->val) return false;
    return isSymmetricHelper(leftTree->left, rightTree->right) && isSymmetricHelper(leftTree->right, rightTree->left);
}
int Solution::isSymmetric(TreeNode *root) {
    return root == NULL || isSymmetricHelper(root->left, root->right);
}"
Postorder Traversal,https://www.interviewbit.com/problems/postorder-traversal/,"Amazon, Microsoft",Tree Data Structure,easy,"Problem Description
 
 

Given a binary tree, return the Postorder traversal of its nodes values.

NOTE: Using recursion is not allowed.



Problem Constraints
 1 <= number of nodes <= 105



Input Format
First and only argument is root node of the binary tree, A.



Output Format
Return an integer array denoting the Postorder traversal of the given binary tree.



Example Input
Input 1:

   1
    \
     2
    /
   3
Input 2:

   1
  / \
 6   2
    /
   3


Example Output
Output 1:

 [3, 2, 1]
Output 2:

 [6, 3, 2, 1]


Example Explanation
Explanation 1:

 The Preoder Traversal of the given tree is [3, 2, 1].
Explanation 2:

 The Preoder Traversal of the given tree is [6, 3, 2, 1].","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

vector<int> Solution::postorderTraversal(TreeNode* A) {
    vector<int> ret;
    if (!A) {
        return ret;
    }
    stack<TreeNode*> S,T;

    S.push(A);
    while (!S.empty()) {
        TreeNode * temp = S.top();
        S.pop();
        T.push(temp);
        if (temp->left)
            S.push(temp->left);
        if (temp->right)
            S.push(temp->right);
    }
    while (!T.empty()) {
        TreeNode * temp = T.top();
        T.pop();
        ret.push_back(temp->val);
    }
    return ret;
}"
Populate Next Right Pointers Tree,https://www.interviewbit.com/problems/populate-next-right-pointers-tree/,"Microsoft, Amazon",Tree Data Structure,hard,"Problem Description
 
 

Given a binary tree
    struct TreeLinkNode {
      TreeLinkNode *left;
      TreeLinkNode *right;
      TreeLinkNode *next;
    } 
Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.
Initially, all next pointers are set to NULL.

NOTE:
You may only use constant extra space.
Recursion has memory overhead and does not qualify for constant space.
The tree need not be a perfect binary tree.


Input Format
The first argument is TreeNode A, pointing to the root of the tree.


Output Format
Update the given TreeNode A.


Example Input
         1
       /  \
      2    3
     / \  / \
    4  5  6  7


Example Output
         1 -> NULL
       /  \
      2 -> 3 -> NULL
     / \  / \
    4->5->6->7 -> NULL","/**
 * Definition for binary tree with next pointer.
 * struct TreeLinkNode {
 *  int val;
 *  TreeLinkNode *left, *right, *next;
 *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
 * };
 */
void Solution::connect(TreeLinkNode* A) {
    TreeLinkNode *q = A;
    while(q){
        TreeLinkNode *t = q,*newQue = NULL,*queptr ;

        while(t){
            if(t->left){
                if(newQue == NULL){
                    newQue = t->left;
                    queptr = t->left;
                }else{
                    queptr->next = t->left;
                    queptr = t->left;
                }

            }
            if(t->right){
                if(newQue == NULL){
                    newQue = t->right;
                    queptr = t->right;
                }else{
                    queptr->next = t->right;
                    queptr = t->right;
                }
            }
            t = t->next ;
        }
        q = newQue;
    }
}"
Identical Binary Trees,https://www.interviewbit.com/problems/identical-binary-trees/,Amazon,Tree Data Structure,easy,"Given two binary trees, write a function to check if they are equal or not.

Two binary trees are considered equal if they are structurally identical and the nodes have the same value.

Return  0 / 1  ( 0 for false, 1 for true ) for this problem

Example :

Input : 

   1       1
  / \     / \
 2   3   2   3

Output : 
  1 ","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
int Solution::isSameTree(TreeNode* A, TreeNode* B) {
    if (!A && !B) {
        return 1;
    } else if (!A || !B) {
        return 0;
    }
    if (A->val == B->val && isSameTree(A->left, B->left) && isSameTree(A->right,B->right)) {
        return 1;
    }
    return 0;
}"
BST Iterator,https://www.interviewbit.com/problems/bst-iterator/,"Apple, Amazon, Facebook",Tree Data Structure,hard,"Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.

The first call to next() will return the smallest number in BST. Calling next() again will return the next smallest number in the BST, and so on.

Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.

Try to optimize the additional space complexity apart from the amortized time complexity.","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
stack<TreeNode*> S;
BSTIterator::BSTIterator(TreeNode *root) {
    //S.clear();
    while (root) {
        S.push(root);
        root = root->left;
    }
}

/** @return whether we have a next smallest number */
bool BSTIterator::hasNext() {
    return !S.empty();
}

/** @return the next smallest number */
int BSTIterator::next() {
    TreeNode *next = S.top();
    S.pop();
    int ret = next->val;
    if (next->right) {
        next = next->right;
        while (next) {
            S.push(next);
            next = next->left;
        }
    }
    return ret;
}

/**
 * Your BSTIterator will be called like this:
 * BSTIterator i = BSTIterator(root);
 * while (i.hasNext()) cout << i.next();
 */"
ZigZag Level Order Traversal BT,https://www.interviewbit.com/problems/zigzag-level-order-traversal-bt/,"Amazon, Microsoft",Tree Data Structure,medium,"Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).

Example : 

Given binary tree

    3
   / \
  9  20
    /  \
   15   7
return

[
         [3],
         [20, 9],
         [15, 7]
]","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
vector<vector<int> > Solution::zigzagLevelOrder(TreeNode* A) {
    vector<vector<int> > ret;
    if (!A) {
        return ret;
    }
    std::stack<TreeNode*> rtl;
    std::stack<TreeNode*> ltr;
    ltr.push(A);
    
    while (!rtl.empty() || !ltr.empty()) {
        vector<int> level;
        while (!ltr.empty()) {
            TreeNode *temp = ltr.top();
            ltr.pop();
            level.push_back(temp->val);
            
            if (temp->left) {
                rtl.push(temp->left);
            }
            if (temp->right) {
                rtl.push(temp->right);
            }
        }
        if (!level.empty()) {
            ret.push_back(level);
            level.clear();   
        }
        while (!rtl.empty()) {
            TreeNode *temp = rtl.top();
            rtl.pop();
            level.push_back(temp->val);
            
            if (temp->right) {
                ltr.push(temp->right);
            }
            if (temp->left) {
                ltr.push(temp->left);
            }
        }
        if (!level.empty()) {
            ret.push_back(level);
            level.clear();   
        }
    }
    return ret;
}"
Path Sum,https://www.interviewbit.com/problems/path-sum/,"Microsoft, Yahoo, Amazon",Tree Data Structure,easy,"Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.

Example :

Given the below binary tree and sum = 22,

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.

Return 0 / 1 ( 0 for false, 1 for true ) for this problem","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
int Solution::hasPathSum(TreeNode* A, int B) {
    if (!A) {
        if (B == 0) {
            return 1;
        }
        return 0;
    }
    int ans = 0;
    int subSum = B - A->val;
    if (subSum == 0 && !A->left && !A->right) {
        return 1;
    }
    if (A->left) {
        ans = ans || hasPathSum(A->left,subSum);
    }
    if (A->right) {
        ans = ans || hasPathSum(A->right,subSum);
    }
    return ans;
}"
Next Pointer Binary Tree,https://www.interviewbit.com/problems/next-pointer-binary-tree/,"Microsoft, Amazon",Tree Data Structure,easy,"Given a binary tree

    struct TreeLinkNode {
      TreeLinkNode *left;
      TreeLinkNode *right;
      TreeLinkNode *next;
    }
Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

Initially, all next pointers are set to NULL.

Note:

You may only use constant extra space.
You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).
Example :

Given the following perfect binary tree,

         1
       /  \
      2    5
     / \  / \
    3  4  6  7
After calling your function, the tree should look like:

         1 -> NULL
       /  \
      2 -> 5 -> NULL
     / \  / \
    3->4->6->7 -> NULL
Note that using recursion has memory overhead and does not qualify for constant space.",N/A
Min Depth of Binary Tree,https://www.interviewbit.com/problems/min-depth-of-binary-tree/,"Facebook, Amazon",Tree Data Structure,medium,"Problem Description
 
 

Given a binary tree, find its minimum depth.
The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.
NOTE: The path has to end on a leaf node.


Input Format
The first argument is a TreeNode, pointing to the root of the binary tree.


Output Format
Return an integer equal to the minimum depth of the tree.


Example Input
  1
 /
2


Example Output
2


Example Explanation
Minimum Depth is 2, which is from 1 -> 2.","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */ 
int Solution::minDepth(TreeNode* root) {
    // Corner case. Should never be hit unless the code is called on root = NULL
    if (root == NULL) return 0;
    // Base case : Leaf node. This accounts for height = 1.
    if (root->left == NULL && root->right == NULL) return 1;

    if (!root->left) return minDepth(root->right) + 1;
    if (!root->right) return minDepth(root->left) + 1;

    return min(minDepth(root->left), minDepth(root->right)) + 1; 
}"
Root to Leaf Paths With Sum,https://www.interviewbit.com/problems/root-to-leaf-paths-with-sum/,"Microsoft, Yahoo, Amazon",Tree Data Structure,medium,"Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.

For example:

Given the below binary tree and sum = 22,

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
return

[
   [5,4,11,2],
   [5,8,4,5]
]","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
vector<vector<int> > Solution::pathSum(TreeNode* A, int B) {
    vector<vector<int> > ret;
    if (!A) {
        if (B == 0) {
            return ret;
        }
        return ret;
    }
    int ans = 0;
    int subSum = B - A->val;
    if (subSum == 0 && !A->left && !A->right) {
        vector<int> temp(1,A->val);
        ret.push_back(temp);
        return ret;
    }
    if (A->left) {
        vector<vector<int> > temp = pathSum(A->left,subSum);
        for (int i = 0; i < temp.size(); ++i) {
            vector<int> temp1 = temp[i];
            std::vector<int>::iterator it = temp1.begin();
            temp1.insert(it,A->val);
            ret.push_back(temp1);
        }
    }
    if (A->right) {
        vector<vector<int> > temp = pathSum(A->right,subSum);
        for (int i = 0; i < temp.size(); ++i) {
            vector<int> temp1 = temp[i];
            std::vector<int>::iterator it = temp1.begin();
            temp1.insert(it,A->val);
            ret.push_back(temp1);
        }
    }
    return ret;
}"
Merge K Sorted Lists,https://www.interviewbit.com/problems/merge-k-sorted-lists/,"Facebook, Amazon, Google",Heaps And Maps,hard,"Merge k sorted linked lists and return it as one sorted list.

Example :

1 -> 10 -> 20
4 -> 11 -> 13
3 -> 8 -> 9
will result in

1 -> 3 -> 4 -> 8 -> 9 -> 10 -> 11 -> 13 -> 20","/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
ListNode* Solution::mergeKLists(vector<ListNode*> &A) {
    map<int,int> heap;
    int i;
    ListNode* temp, *ret;
    
    for (i = 0; i < A.size(); i++) {
        temp = A[i];
        while (temp) {
            if (heap.find(temp->val) != heap.end()) {
                ++heap[temp->val];
            } else {
                heap[temp->val] = 1;
            }
            temp = temp->next;
        }
    }
    
    ret = new ListNode((heap.begin())->first);
    temp = ret;
    if (heap[ret->val] == 1) {
        heap.erase(ret->val);
    } else {
        --heap[ret->val];
    }
    
    for (map<int,int>::iterator it = heap.begin(); it != heap.end(); ++it) {
        while (it->second != 0) {
            temp->next = new ListNode(it->first);
            temp = temp->next;
            --it->second;
        }
    }
    return ret;
    
}"
LRU Cache,https://www.interviewbit.com/problems/lru-cache/,"Adobe, Amazon, Microsoft",Heaps And Maps,hard,"Design and implement a data structure for LRU (Least Recently Used) cache. It should support the following operations: get and set.

get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
set(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least recently used item before inserting the new item.
The LRU Cache will be initialized with an integer corresponding to its capacity. Capacity indicates the maximum number of unique keys it can hold at a time.

Definition of “least recently used” : An access to an item is defined as a get or a set operation of the item. “Least recently used” item is the one with the oldest access time.

NOTE: If you are using any global variables, make sure to clear them in the constructor.

Example :

Input : 
         capacity = 2
         set(1, 10)
         set(5, 12)
         get(5)        returns 12
         get(1)        returns 10
         get(10)       returns -1
         set(6, 14)    this pushes out key = 5 as LRU is full. 
         get(5)        returns -1 ","#include<list>
#include<unordered_map>
 
                typedef list<int> LI; // doubly linked list
                typedef pair<int, LI::iterator> PII;
                typedef unordered_map<int, PII> HIPII;

                
                HIPII cache;
                LI used;
                int _capacity;
                
                void touch(HIPII::iterator it) {
                        int key = it->first;
                        used.erase(it->second.second);
                        used.push_front(key);
                        it->second.second = used.begin();
                }

                
                LRUCache::LRUCache(int capacity) {
                        _capacity = capacity;
                        cache.clear();
                        used.clear();
                }

                int LRUCache::get(int key) {
                        HIPII::iterator it = cache.find(key);
                        if (it == cache.end()) return -1;
                        touch(it);
                        return it->second.first;
                }

                void LRUCache::set(int key, int value) {
                        HIPII::iterator it = cache.find(key);
                        if (it != cache.end()) touch(it);
                        else {
                                if (cache.size() == _capacity) {
                                        cache.erase(used.back());
                                        used.pop_back();
                                }
                                used.push_front(key);
                        }
                        cache[key] = make_pair(value, used.begin());
                }"
NESTED_CMPL2,https://www.interviewbit.com/problems/nestedcmpl2/,N/A,Time Complexity,easy,"What is the time complexity of the following code :

    int a = 0;
    for (i = 0; i < N; i++) {
        for (j = N; j > i; j--) {
            a = a + i + j;
        }
    } O(N)
O(N*log(N))
O(N * Sqrt(N))
O(N*N)","Total number of runs = N + (N - 1) + (N - 2) + ... 1 + 0

= N * (N + 1) / 2

= 1/2 * N^2 + 1/2 * N

O(N^2) times. "
CHOOSE3,https://www.interviewbit.com/problems/choose3/,N/A,Time Complexity,easy,"In a competition, four different functions are observed. All the functions use a single for loop and within the for loop, same set of statements are executed.

Consider the following for loops:

  A) for(i = 0; i < n; i++)
 
  B) for(i = 0; i < n; i += 2)
 
  C) for(i = 1; i < n; i *= 2)
 
  D) for(i = n; i > -1; i /= 2)
If n is the size of input(positive), which function is the most efficient? In other words, which loop completes the fastest.A
B
C
D","The time complexity of the first for loop is O(n). 

The time complexity of the second for loop is O(n/2), equivalent to O(n) in asymptotic analysis. 

The time complexity of the third for loop is O(logn). 

The fourth for loop doesn't terminate. "
NESTED_CMPL3,https://www.interviewbit.com/problems/nestedcmpl3/,"Amazon, Microsoft",Time Complexity,easy,"What is time complexity of following code :

        int count = 0;
        for (int i = N; i > 0; i /= 2) {
            for (int j = 0; j < i; j++) {
                count += 1;
            }
        }O(N * N)
O(N * log N)
O(N * log(log(N)))
O(N)
O(N * Sqrt(N))","In the first iteration, the j loop runs N times.

In the second iteration, the j loop runs N / 2 times. 

In the ith iteration, the j loop runs N / 2^i times. 

So, the total number of runs of loop = N + N / 2 + N / 4 + ... 1 

= **N * ( 1 + 1/2 + 1/4 + 1/8 + ... ) < 2 * N** 
"
CHOOSE4,https://www.interviewbit.com/problems/choose4/,N/A,Time Complexity,easy,"What does it mean when we say that an algorithm X is asymptotically more efficient than Y?X will always be a better choice for all inputs
X will always be a better choice for large inputs
X will always be a better choice for small inputs
Y will always be a better choice for small inputs",In asymptotic analysis we consider growth of algorithm in terms of input size. An algorithm X is said to be asymptotically better than Y if X takes smaller time than y for all input sizes n larger than a value n0 where n0 > 0.
AMORTIZED1,https://www.interviewbit.com/problems/amortized1/,N/A,Time Complexity,easy,"What is the time complexity of the following code :

        int j = 0;
        for(int i = 0; i < n; ++i) {
            while(j < n && arr[i] < arr[j]) {
                j++;
            }
        }(n)
O(n^2)
O(nlogn)
O(n(logn)^2)
Can't say. Depends on the value of arr.","Note that the variable j is not initialized for each value of variable i.
Hence, the inner j++ will be executed at most n times.
The i loop also runs n times.
So, the whole thing runs for O(n) times.


**Still not convinced ?**

Lets assume the array passed has its element in decreasing order. We will just dry run through the code :

Iteration 1 : i = 0, j = 0. arr[0] < arr[0] is false. So, the inner while loop breaks.

Iteration 2: i =1, j = 0. arr[1] < arr[0] is true. j becomes 1.

Iteration 3 : i = 1, j = 1. Condition false. We break. Note that j will remain 1 and is not reset back to 0.

Iteration 4 : i = 2, j = 1. arr[2] < arr[1]. True. j = 2.

Iteration 5 : i = 2, j = 2. Condition false. Break.

Iteration 6 : i = 3, j = 2. arr[3] < arr[2]. True. j = 3.

Iteration 7 : i = 3, j = 3. Condition false. Break.


As you can see, the inner while loop only runs once in this case.
So, total iterations is **2 * N.**"
CHOOSE2,https://www.interviewbit.com/problems/choose2/,N/A,Time Complexity,easy,"Which of the given options provides the increasing order of complexity of functions f1, f2, f3 and f4:

f1(n) = 2^n

f2(n) = n^(3/2)

f3(n) = nLogn

f4(n) = n^(Logn)f3, f2, f4, f1
f3, f2, f1, f4
f2, f3, f1, f4
f2, f3, f4, f1",Try to look at the values for functions for very large value of n.
GCD_CMPL,https://www.interviewbit.com/problems/gcdcmpl/,N/A,Time Complexity,easy,"In the following C++ function, let n >= m.


int gcd(int n, int m) {
  if (n%m ==0) return m;
  if (n < m) swap(n, m);
  while (m > 0) {
    n = n%m;
    swap(n, m);
  }
  return n;
}
What is the time complexity of the above function assuming n > m?. 
? symbol represents theta notation and ? symbol represents omega notation.(logn)
?(n)
?(loglogn)
?(sqrt(n))","The worst case will arise when n and m are consecutive Fibonacci numbers.
i.e.
gcd(Fn,Fn?1) = gcd(Fn?1,Fn?2) =? = gcd(F1,F0) = 1

and nth Fibonacci number is 1.618^n, where 1.618 is the Golden ratio.

So, to find gcd(n,m), number of recursive calls will be  ?(logn).

More detailed explanation : 

Let us say n = fibonacci(N) and m = fibonacci(N - 1)

fibonacci(N) = fibonacci(N-1) + fibonacci(N-2)

OR n = m + k where k and nth Fibonacci number is 1.618n, where 1.618 is the Golden ratio.< m. 

Therefore the step 

    n = n % m will make n = k
    
    swap(n, m) will result in
    
    n = fibonacci(N-1)
        
    m = k = fibonacci(N-2)
    
So, it will take N steps before m becomes 0.

This means, in the worst case, this algorithm can take N step if **n** is Nth fibonacci number. 

**Think of whats the relation between N and n**. "
LOOP_CMPL2,https://www.interviewbit.com/problems/loopcmpl2/,N/A,Time Complexity,easy,"What is the time complexity of the following code :

int i, j, k = 0;
for (i = n/2; i <= n; i++) {
    for (j = 2; j <= n; j = j * 2) {
         k = k + n/2;
    }
}?(n)
?(nLogn)
?(n^2)
?(n^2 / Logn)
?(n^2Logn)","Lets look at the code we are evaluating : 

int i, j, k = 0;

    for (i  = n/2; i <= n; i++) {

        for (j = 2; j <= n; j = j * 2) {

            k = k + n/2;

        }

    }


Now, lets just assume `n = 8` for now. 
We will try to see, the values of j corresponding to each i. 

i = 4, j = 2, 4, 8

i = 5, j = 2, 4, 8

i = 6, j = 2, 4, 8

i = 7, j = 2, 4, 8

i = 8, j = 2, 4, 8


If you notice, j keeps doubling till it is less than or equal to n. Number of times, you can double a number till it is less than n would be log(n). 

Lets take more examples here to convince ourselves.

n = 16, j = 2, 4, 8, 16

 n = 32, j = 2, 4, 8, 16, 32


So, j would run for O(log n) steps. 
i runs for n/2 steps. 

So, total steps ` = O (n/ 2 * log (n)) = O(n logn) `
"
WHILE_CMPL,https://www.interviewbit.com/problems/whilecmpl/,N/A,Time Complexity,easy,"What is the time complexity of the following code :

        int a = 0, i = N;
        while (i > 0) {
            a += i;
            i /= 2;
        }O(N)
O(Sqrt(N))
O(N / 2)
O(log N)
O(log(log N))","We have to find the smallest x such that `N / 2^x < 1 OR 2^x > N`

x = log(N) "
CHOOSE1,https://www.interviewbit.com/problems/choose1/,N/A,Time Complexity,easy,"Which of the following is not bounded by O(n^2)?(15^10) * n + 12099
n^1.98
n^3 / (sqrt(n))
(2^20) * n","The order of growth of option (C) is n^2.5 which is higher than n^2.

Lets look at it with a different approach :

f(n) = O(n^2) if

f(n) <= C * n^2 for n > n0.


Lets look at every option one by one.

* Option 1 :

(15^10) * n + 12099

    Lets say C = 16^10

        15^10 * n + 12099 < 16^10 * n^2 for n > 1.

    So, it is O(n^2).


* Option 2 : n^1.98

C = 1.
    n^1.98 < n^2 for n > 1.
So, its O(n^2) ```
Option 3 : n^3 / (sqrt(n)) or n^2.5
    There is no possible combination of C and n0 possible
Option 4 : 2^20 * n
    C = 2^20, n0 = 1
        2^20 * n <= 2^20 * n^2 for n > 1
```"
LOOP_CMPL,https://www.interviewbit.com/problems/loopcmpl/,Amazon,Time Complexity,easy,"What is the time, space complexity of following code :

        int a = 0, b = 0;    
        for (i = 0; i < N; i++) {
            a = a + rand();  
        }
        for (j = 0; j < M; j++) {
            b = b + rand();
        }
Assume that rand() is O(1) time, O(1) space function.O(N * M) time, O(1) space
O(N + M) time, O(N + M) space
O(N + M) time, O(1) space
O(N * M) time, O(N + M) space
O(N * M) time, O(N * M) space","The first loop is O(N) and the second loop is O(M). Since you don't know which is bigger, you say **this is O(N + M)**. This can also be written as O(max(N, M)).

Since there is no additional space being utilised, the space complexity is constant / O(1)"
NESTED_CMPL,https://www.interviewbit.com/problems/nestedcmpl/,N/A,Time Complexity,easy,"What is the time, space complexity of following code :

int a = 0, b = 0; 
for (i = 0; i < N; i++) { 
    for (j = 0; j < N; j++) { 
        a = a + j; 
    } 
} 
for (k = 0; k < N; k++) { 
    b = b + k; 
}O(N * N) time, O(1) space
O(N) time, O(N) space
O(N * N * N) time, O(1) space
O(N * N) time, O(N) space","The first set of nested loops is O(N^2) and the second loop is O(N). 

This is O(max(N^2,N)) which is O(N^2). "
ARRAY_2D,https://www.interviewbit.com/problems/array2d/,N/A,Arrays,easy,"
vector<vector<int> > performOps(vector<vector<int> > &A) {
    vector<vector<int> > B;
    B.resize(A.size());
    for (int i = 0; i < A.size(); i++) {
        B[i].resize(A[i].size());
        for (int j = 0; j < A[i].size(); j++) {
            B[i][A[i].size() - 1 - j] = A[i][j];
        }
    }
    return B;
}

Lets say performOps was called with A : [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]] .

What would be the output of the following call :


vector<vector<int> > B = performOps(A);
for (int i = 0; i < B.size(); i++) {
    for (int j = 0; j < B[i].size(); j++) cout<<B[i][j]<<"" "";
}",4 3 2 1 8 7 6 5 12 11 10 9
ARRAY_BUG,https://www.interviewbit.com/problems/arraybug/,N/A,Arrays,easy,"The following code is supposed to rotate the array A by B positions.

So, for example,


A : [1 2 3 4 5 6]
B : 1

The output :

[2 3 4 5 6 1]
However, there is a small bug in the problem. Fix the bug and submit the problem.","vector<int> Solution::rotateArray(vector<int> &A, int B) {
	vector<int> ret; 
	for (int i = 0; i < A.size(); i++) {
		ret.push_back(A[(i + B)%A.size()]);
	}
	return ret; 
}"
ARRAY_IMPL1,https://www.interviewbit.com/problems/arrayimpl1/,N/A,Arrays,easy,"vector<int> performOps(vector<int> A) {
    vector<int> B(2 * A.size(), 0);
    for (int i = 0; i < A.size(); i++) {
        B[i] = A[i];
        B[i + A.size()] = A[(A.size() - i) % A.size()];
    }
    return B;
}

Lets say performOps was called with A : [5, 10, 2, 1].
What would be the output of the following call :

( NOTE : The output shoudl be written in the below provided text field , there should not be any ‘,’ between the numbers . For example: 1 2 3 4 )


vector<int> B = performOps(A);
for (int i = 0; i < B.size(); i++) {
    cout<<B[i]<<"" "";
}",5 10 2 1 5 1 2 10 
MATH_BUG01,https://www.interviewbit.com/problems/mathbug01/,N/A,Math,easy,"Following code tries to figure out if a number is prime ( Wiki )

However, it has a bug in it.

Please correct the bug and then submit the code.// Return 1 if A is prime, else 0
int Solution::isPrime(int A) {
	int upperLimit = (int)(sqrt(A));
	for (int i = 2; i <= upperLimit; i++) {
		if (i < A && A % i == 0) return 0;
	}
	return 1;
}","// Return 1 if A is prime, else 0
int Solution::isPrime(int A) {
    if(A == 1) return 0;
	int upperLimit = (int)(sqrt(A));
	while(upperLimit*upperLimit<= A)
	    upperLimit++;
	for (int i = 2; i <= upperLimit; i++) {
		if (i < A && A % i == 0) return 0;
	}
	return 1;
}"
MATH_BUG02,https://www.interviewbit.com/problems/mathbug02/,N/A,Math,easy,"Given a non negative integer A,

following code tries to find all pair of integers (a, b) such that

a and b are positive integers
a <= b, and
a2 + b2 = A.
0 <= A <= 100000
However, the code has a small bug. Correct the bug and submit the code.vector<vector<int> > Solution::squareSum(int A) {
	vector<vector<int> > ans;
	for (int a = 0; a * a < A; a++) {
		for (int b = 0; b * b < A; b++) {
			if (a * a + b * b == A) {
				vector<int> newEntry; 
				newEntry.push_back(a);
				newEntry.push_back(b);
				ans.push_back(newEntry);
			}
		}
	}
	return ans;
}","vector<vector<int> > Solution::squareSum(int A) {
	vector<vector<int> > ans;
	for (int a = 0; a * a < A; a++) {
		for (int b = a; b * b < A; b++) {
			if (a * a + b * b == A) {
				vector<int> newEntry; 
				newEntry.push_back(a);
				newEntry.push_back(b);
				ans.push_back(newEntry);
			}
		}
	}
	return ans;
}"
Spider's Web,https://www.interviewbit.com/problems/spiders-web/,N/A,Puzzles,easy,"A spider is trying to build a web for itself. The web built by it doubles every day.

If the spider entirely built the web in 15 days, how many days did it take for the spider to build 25% of the web?

Answer is an integer.  Just put the number without any decimal places if it’s an integer. If the answer is Infinity, output Infinity.

Feel free to get in touch with us if you have any questions","Given that Spider doubles its work every day let’s figure out the amount of work done till the 14th day ( a day before 15 days ). 

Let’s say the work done till the 14th day is X. Spider doubled the work done till the 14th on 15th. On day 15th, Spider did X more work.

We know that 2X = 100% work. 

Which means X = 50% work.

The Spider built 50% of the web till the 14th day. 

If you extend it, the Spider did 25% of the work till the 13th day."
AMORTIZED2,https://www.interviewbit.com/problems/amortized2/,N/A,Time Complexity,easy,"What is the time complexity of the following code :

        int j = 0;
        for(i = 0; i < n; ++i) {
            while(j < n && arr[i] < arr[j]) {
                j++;
            }
        }
O(n^2)
O(nlogn)
O(n(logn)^2)
O(n)
O(n * sqrt(n))
O(n^2 logn)
Can't say. Depends on the value of arr.",N/A
PRETTYPRINT,https://www.interviewbit.com/problems/prettyprint/,N/A,Arrays,easy,"Print concentric rectangular pattern in a 2d matrix. 

Let us show you some examples to clarify what we mean.

Example 1:

Input: A = 4.

Output:

4 4 4 4 4 4 4 
4 3 3 3 3 3 4 
4 3 2 2 2 3 4 
4 3 2 1 2 3 4 
4 3 2 2 2 3 4 
4 3 3 3 3 3 4 
4 4 4 4 4 4 4 
Example 2:

Input: A = 3.

Output:

3 3 3 3 3 
3 2 2 2 3 
3 2 1 2 3 
3 2 2 2 3 
3 3 3 3 3 
The outermost rectangle is formed by A, then the next outermost is formed by A-1 and so on.

You will be given A as an argument to the function you need to implement, and you need to return a 2D array.",N/A
Kth Smallest Element in the Array,https://www.interviewbit.com/problems/kth-smallest-element-in-the-array/,N/A,Binary Search,easy,"Problem Description
 
 

Find the Bth smallest element in an unsorted array of non-negative integers A.
Definition of kth smallest element: The kth smallest element is the minimum possible n such that there are at least k elements in the array <= n.
In other words, if the array A was sorted, then Ak - 1

NOTE: You are not allowed to modify the array (The array is read-only). Try to do it using constant extra space.



Problem Constraints
1 <= |A| <= 106

1 <= B <= |A|

1 <= A[i] <= 109



Input Format
The first argument is an integer array A.

The second argument is integer B.



Output Format
Return the Bth smallest element in given array.



Example Input
Input 1:

A = [2, 1, 4, 3, 2]
B = 3
Input 2:

A = [1, 2]
B = 2


Example Output
Output 1:

 2
Output 2:

 2


Example Explanation
Explanation 1:

 3rd element after sorting is 2.
Explanation 2:

 2nd element after sorting is 2.",N/A
NUMRANGE,https://www.interviewbit.com/problems/numrange/,N/A,Two Pointers,easy,"Given an array of non negative integers A, and a range (B, C), 

find the number of continuous subsequences in the array which have sum S in the range [B, C] or B <= S <= C

Continuous subsequence is defined as all the numbers A[i], A[i + 1], .... A[j]

where 0 <= i <= j < size(A)

Example :

A : [10, 5, 1, 0, 2]
(B, C) : (6, 8)
ans = 3 

as [5, 1], [5, 1, 0], [5, 1, 0, 2] are the only 3 continuous subsequence with their sum in the range [6, 8]

NOTE : The answer is guranteed to fit in a 32 bit signed integer.",N/A
SUBTRACT,https://www.interviewbit.com/problems/subtract/,N/A,Linked Lists,easy,"Given a singly linked list, modify the value of first half nodes such that :

1st node’s new value = the last node’s value - first node’s current value
2nd node’s new value = the second last node’s value - 2nd node’s current value,
and so on …

NOTE :

If the length L of linked list is odd, then the first half implies at first floor(L/2) nodes. So, if L = 5, the first half refers to first 2 nodes.
If the length L of linked list is even, then the first half implies at first L/2 nodes. So, if L = 4, the first half refers to first 2 nodes.
Example :

Given linked list 1 -> 2 -> 3 -> 4 -> 5,

You should return 4 -> 2 -> 3 -> 4 -> 5

as

for first node, 5 - 1 = 4
for second node, 4 - 2 = 2
Try to solve the problem using constant extra space.",N/A
NEXTGREATER,https://www.interviewbit.com/problems/nextgreater/,N/A,Stacks And Queues,easy,"Given an array, find the next greater element G[i] for every element A[i] in the array.  The Next greater Element for an element A[i] is the first greater element on the right side of A[i] in array. 

More formally,

G[i] for an element A[i] = an element A[j] such that 
    j is minimum possible AND 
    j > i AND
    A[j] > A[i]
Elements for which no greater element exist, consider next greater element as -1.

Example:

Input : A : [4, 5, 2, 10]

Output : [5, 10, 10, -1]

Example 2:

Input : A : [3, 2, 1]

Output : [-1, -1, -1]",N/A
INVERSIONS,https://www.interviewbit.com/problems/inversions/,Amazon,Heaps And Maps,easy,"Problem Description
 
 

Given an array A, count the number of inversions in the array.
Formally speaking, two elements A[i] and A[j] form an inversion if A[i] > A[j] and i < j


Example Input
A : [2, 4, 1, 3, 5]


Example Output
3


Example Explanation
A : [2, 4, 1, 3, 5]
Output : 3
as the 3 inversions are (2, 1), (4, 1), (4, 3).",N/A
Ratio of Boys and Girls,https://www.interviewbit.com/problems/ratio-of-boys-and-girls/,Google,Puzzles,easy,"In a country where everyone wants a boy, each family continues having babies till they have a boy.

After a long time, what is the proportion of boys to girls in the country? (Assuming probability of having a boy or a girl is the same)

Round off your answer to two decimal places and output the answer as I.xx where I is the integer part of your answer, and xx is the first two decimal places of the rounded-off answer.","Assume there are C number of couples, so there would be C boys. The number of girls can be calculated by the following method.

	Number of girls = 0*(Probability of 0 girls) + 1*(Probability of 1 girl) + 2*(Probability of 2 girls) + …
	Number of girls = 0*(C*1/2) + 1*(C*1/2*1/2) + 2*(C*1/2*1/2*1/2) + …
	Number of girls = 0 + C/4 + 2*C/8 + 3*C/16 + …
	Number of girls = C
	(using mathematical formulas; it becomes apparent if you sum up the first 4-5 terms)
The proportion of boys to girls is 1 : 1.

As such, the answer would be 1.00"
Max Non Negative SubArray,https://www.interviewbit.com/problems/max-non-negative-subarray/,Google,Arrays,easy,"Problem Description

Given an array of integers, A of length N, find out the maximum sum sub-array of non negative numbers from A.

The sub-array should be contiguous i.e., a sub-array created by choosing the second and fourth element and skipping the third element is invalid.

Maximum sub-array is defined in terms of the sum of the elements in the sub-array.

Find and return the required subarray.

NOTE:  

If there is a tie, then compare with segment's length and return segment which has maximum length.
If there is still a tie, then return the segment with minimum starting index.


Problem Constraints
1 <= N <= 105

-109 <= A[i] <= 109



Input Format
The first and the only argument of input contains an integer array A, of length N.



Output Format
Return an array of integers, that is a subarray of A that satisfies the given conditions.



Example Input
Input 1:

 A = [1, 2, 5, -7, 2, 3]
Input 2:

 A = [10, -1, 2, 3, -4, 100]


Example Output
Output 1:

 [1, 2, 5]
Output 2:

 [100]


Example Explanation
Explanation 1:

 The two sub-arrays are [1, 2, 5] [2, 3].
 The answer is [1, 2, 5] as its sum is larger than [2, 3].
Explanation 2:

 The three sub-arrays are [10], [2, 3], [100].
 The answer is [100] as its sum is larger than the other two.","vector<int> Solution::maxset(vector<int> &Vec) { 
        int N = Vec.size();

        long long mx_sum = 0;
        long long cur_sum = 0;
        int mx_range_left = -1;
        int mx_range_right = -1;
        int cur_range_left = 0;
        int cur_range_right = 0;

        while(cur_range_right < N) {
            if(Vec[cur_range_right] < 0) {
                cur_range_left = cur_range_right + 1;
                cur_sum = 0;
            } else {
                cur_sum += (long long)Vec[cur_range_right];
                if(cur_sum > mx_sum) {
                    mx_sum = cur_sum;
                    mx_range_left = cur_range_left;
                    mx_range_right = cur_range_right + 1;
                } else if(cur_sum == mx_sum) {
                    if(cur_range_right + 1 - cur_range_left > mx_range_right - mx_range_left) {
                        mx_range_left = cur_range_left;
                        mx_range_right = cur_range_right + 1;
                    }
                }
            }
            cur_range_right++;
        }
        vector<int> ans;
        if(mx_range_left == -1 || mx_range_right == -1)
                return ans;

        for(int i = mx_range_left; i < mx_range_right; ++i)
                ans.push_back(Vec[i]);
        return ans;
}"
Wave Array,https://www.interviewbit.com/problems/wave-array/,"Google, Adobe, Amazon",Arrays,easy,"Problem Description
 
 

Given an array of integers A, sort the array into a wave-like array and return it. 
In other words, arrange the elements into a sequence such that

a1 >= a2 <= a3 >= a4 <= a5..... 
NOTE: If multiple answers are possible, return the lexicographically smallest one.



Problem Constraints
1 <= len(A) <= 106

1 <= A[i] <= 106



Input Format
The first argument is an integer array A.



Output Format
Return an array arranged in the sequence as described.



Example Input
Input 1:

A = [1, 2, 3, 4]
Input 2:

A = [1, 2]


Example Output
Output 1:

[2, 1, 4, 3]
Output 2:

[2, 1]


Example Explanation
Explanation 1:

One possible answer : [2, 1, 4, 3]
Another possible answer : [4, 1, 3, 2]
First answer is lexicographically smallest. So, return [2, 1, 4, 3].
Explanation 1:

Only possible answer is [2, 1].","vector<int> Solution::wave(vector<int> &A) {
    sort(A.begin(), A.end());
    for(int i=0; i<A.size()-1; i+=2) swap(A[i], A[i+1]);
    return A;
}"
Rearrange Array,https://www.interviewbit.com/problems/rearrange-array/,Facebook,Math,medium,"Given an array A of size N. Rearrange the given array so that A[i] becomes A[A[i]] with O(1) extra space.
Lets say N = size of the array. Then, following holds true :

All elements in the array are in the range [0, N-1]
N * N does not overflow for a signed integer

Constraints:

1 <= N <= 5×104

0 <= A[i] <= N - 1

The elements of A are distinct 

Input Format

The argument A is an array of integers

Example 1:

Input : [1, 0]
Return : [0, 1]
Example 2:

Input : [0, 2, 1, 3]
Return : [0, 1, 2, 3]","void Solution::arrange(vector<int> &A) {
    int i,s=A.size();
    for(i=0;i<s;i++) A[i]=A[i]+(A[A[i]]%s)*s;
    for(i=0;i<s;i++) A[i]/=s;
}"
Greatest Common Divisor,https://www.interviewbit.com/problems/greatest-common-divisor/,Google,Math,medium,"Problem Description
 
 

Given 2 non-negative integers A and B, find gcd(A, B).
GCD of 2 integers m and n is defined as the greatest integer g such that g is a divisor of both m and n.
Both A and B fit in a 32-bit signed integer.
NOTE: DO NOT USE LIBRARY FUNCTIONS


Problem Constraints
0 <= A <= 109
0 <= B <= 109


Input Format
The first argument is an integer A.
The second argument is an integer B.


Output Format
Return the Greatest Common Divisor of A and B


Example Input
Input 1:
A = 6
B = 9


Example Output
Output 1:
3


Example Explanation
Explanation 1:
3 is the GCD of 6 and 9","int Solution::gcd(int A, int B) {
    return (B == 0)?A:gcd(B, A%B);
}"
Allocate Books,https://www.interviewbit.com/problems/allocate-books/,"Google, Facebook",Binary Search,medium,"Problem Description
 
 

Given an array of integers A of size N and an integer B.

The College library has N books. The ith book has A[i] number of pages.

You have to allocate books to B number of students so that the maximum number of pages allocated to a student is minimum.

A book will be allocated to exactly one student.
Each student has to be allocated at least one book.
Allotment should be in contiguous order, for example: A student cannot be allocated book 1 and book 3, skipping book 2.
Calculate and return that minimum possible number.

NOTE: Return -1 if a valid assignment is not possible.



Problem Constraints
1 <= N <= 105
 1 <= A[i], B <= 105



Input Format
The first argument given is the integer array A.
The second argument given is the integer B.



Output Format
Return that minimum possible number.



Example Input
Input 1:
A = [12, 34, 67, 90]
B = 2
Input 2:
A = [5, 17, 100, 11]
B = 4


Example Output
Output 1:
113
Output 2:
100


Example Explanation
Explanation 1:
There are two students. Books can be distributed in following fashion : 
1)  [12] and [34, 67, 90]
    Max number of pages is allocated to student 2 with 34 + 67 + 90 = 191 pages
2)  [12, 34] and [67, 90]
    Max number of pages is allocated to student 2 with 67 + 90 = 157 pages 
3)  [12, 34, 67] and [90]
    Max number of pages is allocated to student 1 with 12 + 34 + 67 = 113 pages
    Of the 3 cases, Option 3 has the minimum pages = 113.","#include<bits/stdc++.h>
int Solution::books(vector<int> &A, int B) {
    if(A.size()<B) return -1;
    assert(A.size()<=100000);
    long long min_time = (*max_element(A.begin(), A.end()));
    long long max_time = accumulate(A.begin(), A.end(), 0);
    assert(min_time<=100000);
    long long mid;
    int required=0, time=0;
    while(min_time<=max_time){
        required=1;
        time=0;
        mid = (min_time+max_time)/2;
        for(int i=0; i<A.size(); i++){
            if(time+A[i]>mid){
                time=A[i];
                required++;
            }
            else time+=A[i];
        }
            if(required>B) min_time = mid+1;
            else max_time = mid-1;
    }
    return min_time;
}"
Painter's Partition Problem,https://www.interviewbit.com/problems/painters-partition-problem/,"Codenation, Google, Amazon",Binary Search,medium,"Problem Description
 
 

Given 2 integers A and B and an array of integers C of size N. Element C[i] represents the length of ith board.
 You have to paint all N boards [C0, C1, C2, C3 … CN-1]. There are A painters available and each of them takes B units of time to paint 1 unit of the board.

Calculate and return the minimum time required to paint all boards under the constraints that any painter will only paint contiguous sections of the board.
 NOTE: 
 1. 2 painters cannot share a board to paint. That is to say, a board cannot be painted partially by one painter, and partially by another.
 2. A painter will only paint contiguous boards. This means a configuration where painter 1 paints boards 1 and 3 but not 2 is invalid.

 Return the ans % 10000003.



Problem Constraints
1 <= A <= 1000

1 <= B <= 106

1 <= N <= 105

1 <= C[i] <= 106



Input Format
The first argument given is the integer A.

The second argument given is the integer B.

The third argument given is the integer array C.



Output Format
Return minimum time required to paint all boards under the constraints that any painter will only paint contiguous sections of board % 10000003.



Example Input
Input 1:

 A = 2
 B = 5
 C = [1, 10]
Input 2:

 A = 10
 B = 1
 C = [1, 8, 11, 3]


Example Output
Output 1:

 50
Output 2:

 11


Example Explanation
Explanation 1:

 Possibility 1:- One painter paints both blocks, time taken = 55 units.
 Possibility 2:- Painter 1 paints block 1, painter 2 paints block 2, time take = max(5, 50) = 50
 There are no other distinct ways to paint boards.
 ans = 50 % 10000003
Explanation 2:

 Each block is painted by a painter so, Painter 1 paints block 1, painter 2 paints block 2, painter 3 paints block 3 
 and painter 4 paints block 4, time taken = max(1, 8, 11, 3) = 11
 ans = 11 % 10000003","#include<bits/stdc++.h>
int Solution::paint(int A, int B, vector<int> &C) {
    long long min_time = (*max_element(C.begin(), C.end()));
    long long max_time =accumulate(C.begin(), C.end(), 0);
    assert(B<=1000000);
    long long mid;
    int required=0, time=0;
    while(min_time<=max_time){
        required=1;
        time=0;
        mid = (min_time+max_time)/2;
        for(int i=0; i<C.size(); i++){
            if(time+C[i]>mid){
                time=C[i];
                required++;
            }
            else time+=C[i];
        }
        if(required>A) min_time = mid+1;
        else max_time = mid-1;
    }
    return (B*min_time)% 10000003;
}"
Power of 2,https://www.interviewbit.com/problems/power-of-2/,Amazon,Strings,medium,"Problem Description
 
 

Find if the given number is a power of 2 or not. More specifically, find if the given number can be expressed as 2^k where k >= 1.
Note: The number length can be more than 64, which means the number can be greater than 2 ^ 64 (out of long long range)


Problem Constraints
1 <= |A| <= 104


Input Format
The first argument is a string A.


Output Format
Return 1 if the number is a power of 2 else return 0


Example Input
128


Example Output
1


Example Explanation
128 can be expressed as 2 ^ 7.","bool Not_one(string N) {
    int sz = N.size();
    if(sz > 1)
            return 1;
    if(N[0] != '1')
            return 1;
    return 0;
}

bool is_Eve(string N) {
    int data = (N[N.size() - 1] - '0') & 1;
    if(data)
            return 0;
    return 1;
}

string Divide(string N, int data) {
    reverse(N.begin(), N.end());
    long long base = 10;
    string temp = """";
    for(int i = (int)N.size() - 1, rem = 0; i >= 0; --i) {
        long long Cur = (N[i] - '0') + rem * base;
        int val = Cur / data;
        rem = Cur % data;
        temp += (val + '0');
    }
    
    while(temp.size() && !(temp[0] - '0'))
            temp.erase(temp.begin());
    
    return temp;
}

int Solution::power(string N) {
    assert(N.size() >= 1 && N.size() <= 1e4);
    int sz = N.size();
    if(sz == 1) {
        if(N[0] == '2' || N[0] == '4' || N[0] == '8')
                return 1;
        return 0;
    } else {
        while(Not_one(N) && is_Eve(N)) {
            N = Divide(N, 2);
            if(N.size() == 1 &&  N[0] == '1')
                    break;
        }
        if(Not_one(N))
                return 0;
        return 1;
    }
} "
Max Continuous Series of 1s,https://www.interviewbit.com/problems/max-continuous-series-of-1s/,Amazon,Two Pointers,medium,"Problem Description
 
 

Given a binary array A, find the maximum sequence of continuous 1's that can be formed by replacing at-most B zeroes.

For this problem, return the indices of maximum continuous series of 1s in order.

If there are multiple possible solutions, return the sequence which has the minimum start index.



Problem Constraints
 0 <= B <= 105

 1 <= size(A) <= 105

 0 <= A[i] <= 1



Input Format
First argument is an binary array A.

Second argument is an integer B.



Output Format
 Return an array of integers denoting the indices(0-based) of 1's in the maximum continuous series.



Example Input
Input 1:

 A = [1 1 0 1 1 0 0 1 1 1 ]
 B = 1
Input 2:

 A = [1, 0, 0, 0, 1, 0, 1]
 B = 2


Example Output
Output 1:

 [0, 1, 2, 3, 4]
Output 2:

 [3, 4, 5, 6]


Example Explanation
Explanation 1:

 Flipping 0 present at index 2 gives us the longest continous series of 1's i.e subarray [0:4].
Explanation 2:

 Flipping 0 present at index 3 and index 5 gives us the longest continous series of 1's i.e subarray [3:6].","vector<int> Solution::maxone(vector<int> &a, int b) {
    int i,j,k,n,m,p,t ;
    n = a.size() ;
    m = 0 ;
    int start=0 ;
    t = 0 ;
    for(i=0;i<n;i++) {
        if(a[i] == 0) m++ ;
        if(m > b) {
            while(a[start] != 0) start++ ;
            start++ ;
            m-- ;
        }
        if(t < i-start+1) {
            t = i-start+1 ;
            j = start ;
        }
    }
    vector<int> v ;
    for(i=j;i<j+t;i++) v.push_back(i) ;
    return v ;
}"
Redundant Braces,https://www.interviewbit.com/problems/redundant-braces/,Amazon,Stacks And Queues,easy,"Problem Description
 
 

Given a string A denoting an expression. It contains the following operators '+', '-', '*', '/'.

Chech whether A has redundant braces or not.

NOTE: A will be always a valid expression.



Problem Constraints
1 <= |A| <= 105



Input Format
The only argument given is string A.



Output Format
Return 1 if A has redundant braces, else return 0.



Example Input
Input 1:

 A = ""((a+b))""
Input 2:

 A = ""(a+(a+b))""
Input 3:

 A = ""((a*b)+(c+d))""


Example Output
Output 1:

 1
Output 2:

 0
Output 3:

 0


Example Explanation
Explanation 1:

 ((a+b)) has redundant braces so answer will be 1.
Explanation 2:

 (a+(a+b)) doesn't have have any redundant braces so answer will be 0.
Explanation 3:

 ((a*b)+(c+d)) doesn't have have any redundant braces so answer will be 0.","int Solution::braces(string str) {
    assert(str.size() >= 1 && str.size() <= 1e5);
    stack<char> st;
    for (auto& ch : str) {
        if (ch == ')') {
            char top = st.top();
            st.pop();
            bool flag = true;
            while (!st.empty() and top != '(') {
                if (top == '+' || top == '-' ||
                    top == '*' || top == '/')
                    flag = false;
                top = st.top();
                st.pop();
            }
            if (flag == true)
                return true;
        }
        else
            st.push(ch);
    }
    return false;
}"
Colorful Number,https://www.interviewbit.com/problems/colorful-number/,N/A,Hashing,easy,"Problem Description
 
 

For Given Number A, find if it's a COLORFUL number or not.

COLORFUL number:
A number can be broken into different contiguous sub-subsequence parts. 
Suppose, a number 3245 can be broken into parts like 3 2 4 5 32 24 45 324 245. 
And this number is a COLORFUL number, since product of every digit of a contiguous subsequence is different
Return 1 if A is a COLORFUL number, else return 0



Problem Constraints
0 <= A <= 109


Input Format
The first argument is an integer A.


Output Format
Return 1 if A is a COLORFUL number, else return 0


Example Input
A = 23


Example Output
1


Example Explanation
A = 23
2 3 23
2 -> 2
3 -> 3
23 -> 6
this number is a COLORFUL number since the product of every digit of a sub-sequence is different.

Output: 1","int Solution::colorful(int A) {
   if (A < 10) return 1;
	set<int> s;
	vector<int> v;
	while (A) {
		int lastdigit = A % 10;
	    A /= 10;
		for (auto &i : v) i *= lastdigit;
		v.push_back(lastdigit);
		for (auto i : v) {
			if (s.count(i)) return 0;
			else s.insert(i);
		}
	}
	return 1;
}"
Order of People Heights,https://www.interviewbit.com/problems/order-of-people-heights/,Google,Tree Data Structure,hard,"You are given the following :

A positive number N
Heights : A list of heights of N persons standing in a queue
Infronts : A list of numbers corresponding to each person (P) that gives the number of persons who are taller than P and standing in front of P
You need to return  list of actual order of persons’s height

Consider that heights will be unique

Example

Input : 
Heights: 5 3 2 6 1 4
InFronts: 0 1 2 0 3 2
Output : 
actual order is: 5 3 2 1 6 4 
So, you can see that for the person with height 5, there is no one taller than him who is in front of him, and hence Infronts has 0 for him.

For person with height 3, there is 1 person ( Height : 5 ) in front of him who is taller than him.

You can do similar inference for other people in the list.","include<iostream>
#include<cstdio>
#include<cstring>
#include<climits>
#include<climits>

#include<cstdlib>
#include<vector>
#include<set>
#include<map>
#include<cassert>
#include<sstream>
#include<string>
#include<cmath>
#include<algorithm>
#include<queue>
#include<stack>
#include<unordered_map>
#include<unordered_set>

using namespace std;

#define mpa make_pair
#define ff first
#define ss second
#define pb push_back

struct Node {
		int data;
		int best;
		int pri;
		int size;
		struct Node *left;
		struct Node *rig;
};

struct Node arr[400000];
struct Node *dummy;
struct Node *ptr = arr;
struct Node *root;

class Solution{
    public:	

	void init()
	{

        srand(time(NULL));
		ptr ->left = ptr ->rig = dummy;
		ptr ->pri = -1;
		ptr ->size = 0;
		ptr ->data = -1e9;
		ptr ->best = -1e9;
		root = dummy = ptr;
		ptr++;
	}

	void update(struct Node *A)
	{
		A ->size = A ->left ->size + A ->rig ->size + 1;
		A ->best = max(A ->data, max(A ->left ->best, A ->rig ->best));
	}

	struct Node *rot(struct Node *A, struct Node *B)
	{
		if(A ->left == B) {
			A ->left = B ->rig;
			B ->rig = A;
		} else {
			A ->rig = B ->left;
			B ->left = A;
		}
	
		update(A);
		update(B);
	
		return B;
	}

	struct Node *insert_tree(struct Node *root, int data)
	{
		if(root == dummy) {
			ptr ->data = data;
			ptr ->best = data;
			ptr ->pri = rand();
			ptr ->size = 1;
			ptr ->left = ptr ->rig = dummy;
			return ptr++;
		} else if(root ->data < data) {
			root ->rig = insert_tree(root ->rig, data);
			if(root ->rig ->pri > root ->pri) { //Need Rotation
				root = rot(root, root ->rig);
			}
		} else {
			root ->left = insert_tree(root ->left, data);
			if(root ->left ->pri > root ->pri) {//Need rotation
				root = rot(root, root ->left);
			}
		}
	
		update(root);
		return root;	
	}

	struct Node *remove(struct Node *root, int data) 
	{
		if(root != dummy) {
			if(root ->data > data) {

				root ->left = remove(root ->left, data);
			
			} else if(root ->data < data) {

				root ->rig = remove(root ->rig, data);
			
			} else {
			
				if(root ->left == dummy && root ->rig == dummy) {
					root = dummy;
					return root;
				}
			
				if(root ->left ->pri > root ->rig ->pri) {
				//	cout<<""left rotate\n"";
					root = rot(root, root ->left);
				} else {
				//	cout<<""right rotate\n"";
					root = rot(root, root ->rig);
				}
			
				if(root != dummy) {
					root = remove(root, data);
				} else {
				//	cout<<""leaf\n"";
					root ->left = dummy;
				}
			}
		}
		update(root);
		return root;
	}

	int Find(struct Node *root, int K)
	{
		if(root ->left ->size > K) 
			return Find(root ->left, K);
		else if(root ->left ->size < K)
			return Find(root ->rig, K - root ->left ->size - 1);
		return root ->data;
	}

	void print(struct Node *root)
	{
		if(root == dummy) {
			return ;
		}
	
		print(root ->left);
		cout<< ""( "" << root ->data <<"", "" << root ->best <<"" ) "";
		print(root ->rig);
	}


	int Count(struct Node *root, int data)
	{
		if(root == dummy)
			return 0;
		
		if(root ->data > data) {
			return Count(root ->left, data);
		} else if(root ->data < data) {
			return root ->left ->size + Count(root ->rig, data) + 1;
		}
		return root ->left ->size;
	}

	bool find(struct Node *root, int data)
	{
		if(root == dummy)
			return false;
	
		if(root ->data > data) {
			return find(root ->left, data);
		} else if(root ->data < data) {
			return find(root ->rig, data);
		} else
			return root ->data == data;
	}

	void insert(int data)
	{
		root = insert_tree(root, data);
	}

	void delet(int data)
	{
		root = remove(root, data);
	}

	int FindKth(int K)
	{
		if(root ->size <= K) {
			//puts(""invalid"");
			return -1;
		} else {
			return Find(root, K);
		}
	}

	int Count_Element(int x)
	{
		return Count(root, x);
	}
	
    vector<int> order(vector<int> Heights, vector<int> InFronts) {
           
	    init();
            
	    int sz = Heights.size();
	   
//        cout << "" sz => "" << sz <<""\n"";   
	   
        for(int i = 0; i < sz; ++i) {
	    	insert(i);
	    }
		
            vector<pair<int, int> > vec;
            for(int i = 0; i < sz; ++i) {
                vec.push_back(mpa(Heights[i], InFronts[i]));
            }
            sort(vec.begin(), vec.end());
            
            vector<int> Ans(sz, 0);

            for(int i = 0; i < sz; ++i) {
                int idx = FindKth(vec[i].ss);
                Ans[idx] = vec[i].ff;
                delet(idx);
            }

            return Ans;
    }
};

int main()
{
    int T;
    scanf(""%d"", &T);

    while(T--) {
        
        Solution obj;
        
        int N;
        scanf(""%d"", &N);

        vector<int> A(N, 0);
        vector<int> B(N, 0);
        for(int i = 0; i < N; ++i) {
            scanf(""%d"", &A[i]);
        }
        
	scanf(""%d"", &N);
 	for(int i = 0; i < N; ++i) {
            scanf(""%d"", &B[i]);
        }
		
        vector<int> Ans = obj.order(A, B);
        for(int i = 0; i < N; ++i) {
            cout<<Ans[i]<<"" "";
        }
        cout<<endl;
    }

    return 0;
}"
Shortest Unique Prefix,https://www.interviewbit.com/problems/shortest-unique-prefix/,Google,Tree Data Structure,medium,"Find shortest unique prefix to represent each word in the list.

Example:

Input: [zebra, dog, duck, dove]
Output: {z, dog, du, dov}
where we can see that
zebra = z
dog = dog
duck = du
dove = dov
NOTE : Assume that no word is prefix of another. In other words, the representation is always possible.","// Trie structure
struct Node {
	bool stop = false;
	int counter = 0;
	map<char, Node *> children;
};

// Building a prefix trie
Node * buildTrie(const vector<string> &dictionary) {
	Node * root = new Node;

	for(string word : dictionary) {
		Node * n = root;

		for(char c : word) {
			Node * child;
			auto it = n->children.find(c);
			if(it != n->children.end()) {
				child = it->second;
			} else {
				child = new Node;
				n->children.insert(pair<char, Node *>(c, child));
			}

			++child->counter;
			n = child;
		}

		n->stop = true;
	}

	return root;
}

void _createMap(map<string, string> & result, const Node * n, string prefix) {
	if(n->counter == 1) {
		stringstream word;
		word << prefix;

		while(n->children.size() > 0) {
			// there is only one child here, sice counter == 1
			auto it = n->children.begin();
			n = it->second;
			word << it->first;
		}

		// assert(result.find(prefix) == result.end()); // validity check
		result.insert(pair<string, string>(word.str(), prefix));
		return;
	}

	// ""bar"", ""bartender"" situation - unclear instructions from OP
	if(n->stop) { 
		return;
	}

	for(auto it : n->children) {
		_createMap(result, it.second, prefix + it.first);
	}
}

map<string, string> createMap(const Node * root) {
	map<string, string> result;

	for(auto it : root->children) {
		_createMap(result, it.second, string(1, it.first));
	}

	return result;
}

vector<string> Solution::prefix(vector<string> &A) {
    vector<string> ret;
    map<string, string> prefixMap = createMap(buildTrie(A));
    
    for (string word: A) {
        ret.push_back(prefixMap[word]);
    }
    
    return ret;
    
}"
Max Sum Without Adjacent Elements,https://www.interviewbit.com/problems/max-sum-without-adjacent-elements/,N/A,Dynamic Programming,medium,"Given a 2 x N grid of integer, A, choose numbers such that the sum of the numbers

is maximum and no two chosen numbers are adjacent horizontally, vertically or diagonally, and return it.

Note: You can choose more than 2 numbers.

Input Format:

The first and the only argument of input contains a 2d matrix, A.
Output Format:

Return an integer, representing the maximum possible sum.
Constraints:

1 <= N <= 20000
1 <= A[i] <= 2000
Example:

Input 1:
    A = [   [1]
            [2]    ]

Output 1:
    2

Explanation 1:
    We will choose 2.

Input 2:
    A = [   [1, 2, 3, 4]
            [2, 3, 4, 5]    ]
    
Output 2:
    We will choose 3 and 5.","int Solution::adjacent(vector<vector<int> > &A) {
    int i,j,n,it;
    n=A[0].size();
    vector<int> ans(n+1);
    ans[n]=0;
    ans[n-1]=max(A[0][n-1],A[1][n-1]);
    for(i=n-2;i>=0;i--)
        ans[i]=max(ans[i+1],ans[i+2]+max(A[0][i],A[1][i]));
    return ans[0];
}"
Repeating Sub-Sequence,https://www.interviewbit.com/problems/repeating-subsequence/,Google,Dynamic Programming,medium,"Problem Description
 
 

Given a string A, Check if the length of the longest repeating sub-sequence is greater than or equal to 2,
A longest repeating sub-sequence is defined such that,
the two subsequences have the same string character at the same position
any ith character in the two subsequences shouldn’t have the same index in the original string
NOTE: If the Sub-sequence length is greater than or equal to 2 return 1, else return 0.

 



Problem Constraints
 1 <= |A| <= 100



Input Format
The first and only argument of input contains a string A.



Output Format
Return an integer, 0 or 1:

    => 0 : Length of Repeating subsequence is less than 2
    => 1 : Length of Repeating subsequence is greater than or equal to 2
 



Example Input
Input 1:

 A = ""abab""
Input 2:

 A = ""abba""
 



Example Output
Output 1:

 1
Output 2:

 0
 



Example Explanation
Explanation 1:

 ""ab"" is repeated.
Explanation 2:

 There is no repeating subsequence.","    int N;
    vector<vector<int> > dp;    

    int rec(int x, int y, string str) {
        
        if(x == N || y == N)
                return 0;
        
        if(dp[x][y] != -1)
                return dp[x][y];

        int ans = rec(x + 1, y, str);
        ans = max(ans, rec(x, y + 1, str));
        if(x != y && str[x] == str[y]) {
           ans = max(ans, rec(x + 1, y + 1, str) + 1);
        }

        return dp[x][y] = ans;
    }
     
    
    int Solution::anytwo(string str) {
        N = str.size();
        dp.clear();
        dp.resize(N, vector<int> (N, -1));

        int ans = rec(0, 0, str);
        return ans;
    }"
Evaluate Expression To True,https://www.interviewbit.com/problems/evaluate-expression-to-true/,Amazon,Dynamic Programming,medium,"Given an expression, A, with operands and operators (OR , AND , XOR), in how many ways can you evaluate the expression to true, by grouping in different ways?

Operands are only true and false.

Return the number of ways to evaluate the expression modulo 103 + 3.



Input Format:

The first and the only argument of input will contain a string, A.

The string A, may contain these characters:
    '|' will represent or operator 
    '&' will represent and operator
    '^' will represent xor operator
    'T' will represent true operand
    'F' will false
Output:

Return an integer, representing the number of ways to evaluate the string.
Constraints:

1 <= length(A) <= 150
Example:

Input 1:
    A = ""T|F""

Output 1:
    1

Explanation 1:
    The only way to evaluate the expression is:
        => (T|F) = T 

Input 2:
    A = ""T^T^F""
    
Output 2:
    0
    
Explanation 2:
    There is no way to evaluate A to a true statement.","#define MOD 1003
int Solution::cnttrue(string A) {
    int aLen = A.size();
    int n = (aLen+1)/2, i, j, width, k, parens;
    //std::cout << A << "": of size "" << aLen << "". N: "" << n << endl;
    vector<vector<int> > falseWays(n, vector<int>(n, 0)), trueWays(n, vector<int>(n, 0));
    
    string operands = """", operators = """";
    
    for (i = 0, j = 0; i < aLen; ++i) {
        if (A[i] == 'T' || A[i] == 'F') {
            operands += A[i];
        } else {
            operators += A[i];
        }
    }
    /*std::cout << operators << endl;
    std::cout << operands << endl;*/
    for (i = 0; i < n; ++i) {
        trueWays[i][i] = operands[i] == 'T' ? 1 : 0;
        falseWays[i][i] = operands[i] == 'F' ? 1 : 0;
    }
    
    
    for (width = 1; width < n; ++width) {
        for (i = 0, j = width; j < n; ++i, ++j) {
            for (k = 0; k < width; ++k) {
                parens = i + k;
                int total_iparens = trueWays[i][parens] + falseWays[i][parens];
                int total_parensj = trueWays[parens+1][j] + falseWays[parens+1][j];
                
                if (operators[parens] == '&') {
                    trueWays[i][j] += (trueWays[i][parens]*trueWays[parens+1][j])%MOD;
                    falseWays[i][j] += (total_iparens*total_parensj)%MOD - 
                        (trueWays[i][parens]*trueWays[parens+1][j])%MOD;
                }
                
                if (operators[parens] == '|') {
                    falseWays[i][j] += (falseWays[i][parens]*falseWays[parens+1][j])%MOD;
                    trueWays[i][j] += (total_iparens*total_parensj)%MOD - 
                        (falseWays[i][parens]*falseWays[parens+1][j])%MOD;
                }
                
                if (operators[parens] == '^') {
                    trueWays[i][j] += (falseWays[i][parens]*trueWays[parens+1][j] + 
                        trueWays[i][parens]*falseWays[parens+1][j])%MOD;
                    falseWays[i][j] += (falseWays[i][parens]*falseWays[parens+1][j]
                        + trueWays[i][parens]*trueWays[parens+1][j])%MOD;
                }
                /*if (parens == 1 && i == 0 && j == 2) {
                    std::cout << i << "";"" << j << "";"" << parens << ""; "" << trueWays[i][j] << "";"" 
                        << falseWays[i][j] << operators[parens] << endl;
                    std::cout << total_iparens << endl;
                    std::cout << total_parensj << endl;
                }*/
                /*std::cout << i << "";"" << j << "";"" << parens << ""; "" << trueWays[i][j] << "";"" 
                    << falseWays[i][j] << endl;*/
            }
        }
    }
    
    /*for (i = 0; i < n; ++i) {
        for (j = 0; j < n; ++j) {
            cout << trueWays[i][j] << ""; "";
        }
        cout << endl;
    }
    cout << ""False Ways: "" << endl;
    for (i = 0; i < n; ++i) {
        for (j = 0; j < n; ++j) {
            cout << falseWays[i][j] << ""; "";
        }
        cout << endl;
    }*/
    
    return trueWays[0][n-1]%MOD;
}"
Coins in a Line,https://www.interviewbit.com/problems/coins-in-a-line/,N/A,Dynamic Programming,medium,"Problem Description

There are A coins (Assume A is even) in a line.

Two players take turns to take a coin from one of the ends of the line until there are no more coins left.

The player with the larger amount of money wins, Assume that you go first.

Return the maximum amount of money you can win.

NOTE:

You can assume that opponent is clever and plays optimally.


Problem Constraints
1 <= length(A) <= 500

1 <= A[i] <= 105



Input Format
The first and the only argument of input contains an integer array A.



Output Format
Return an integer representing the maximum amount of money you can win.



Example Input
Input 1:

 A = [1, 2, 3, 4]
Input 2:

 A = [5, 4, 8, 10]


Example Output
Output 1:

 6
Output 2:

 15


Example Explanation
Explanation 1:

 You      : Pick 4
 Opponent : Pick 3
 You      : Pick 2
 Opponent : Pick 1


Total money with you : 4 + 2 = 6

Explanation 2:

 You      : Pick 10
 Opponent : Pick 8
 You      : Pick 5
 Opponent : Pick 4


Total money with you : 10 + 5 = 15","int rec(vector<int> &a,int i,int j,vector<vector<int> > &m)
{
    if(j<i) return 0;
    if(i==j) return a[i];
    if(i+1==j) return max(a[i],a[j]);
    if(m[i][j]!=-1) return m[i][j];
    return m[i][j]=max(a[i]+min( rec(a,i+2,j,m) , rec(a,i+1,j-1,m) ),a[j]+min( rec(a,i+1,j-1,m),rec(a,i,j-2,m) ) );
}
int Solution::maxcoin(vector<int> &a) {
    vector<vector<int> > m(a.size(),vector<int> (a.size(),-1));
    return rec(a,0,a.size()-1,m);   
}"
Seats,https://www.interviewbit.com/problems/seats/,Walmart,Greedy Algorithm,medium,"Problem Description
 
 

There is a row of seats represented by string A. Assume that it contains N seats adjacent to each other. 
There is a group of people who are already seated in that row randomly. i.e. some are sitting together & some are scattered.

An occupied seat is marked with a character 'x' and an unoccupied seat is marked with a dot ('.')

Now your target is to make the whole group sit together i.e. next to each other, without having any vacant seat between them in such a way that the total number of hops or jumps to move them should be minimum.

In one jump a person can move to the adjacent seat (if available).

NOTE:  1. Return your answer modulo 107 + 3.



Problem Constraints
1 <= N <= 1000000

A[i] = 'x' or '.'



Input Format
The first and only argument is a string A of size N.



Output Format
Return an integer denoting the minimum number of jumps required.



Example Input
Input 1:

 A = ""....x..xx...x..""
Input 2:

 A = ""....xxx""


Example Output
Output 1:

 5
Output 2:

 0


Example Explanation
Explanation 1:

 Here is the row having 15 seats represented by the String (0, 1, 2, 3, ......... , 14) 
                 . . . . x . . x x . . . x . . 
 Now to make them sit together one of approaches is -
                 . . . . . . x x x x . . . . .
 Steps To achieve this:
 1) Move the person sitting at 4th index to 6th index: Number of jumps by him =   (6 - 4) = 2
 2) Bring the person sitting at 12th index to 9th index: Number of jumps by him = (12 - 9) = 3
 So, total number of jumps made: 2 + 3 = 5 which is the minimum possible.


If we other ways to make them sit together but the number of jumps will exceed 5 and that will not be minimum.
 

Explanation 2:

 They are already together. So, the cost is zero.","MOD = 10000003


def getPersonsNo(A):
    ret = 0
    for a in A:
        if a == 'x':
            ret += 1
    return ret


def findMedianPos(A):
    n = len(A)
    noPersons = getPersonsNo(A)
    noPersons = (noPersons + 1) // 2
    countTillMedian = 0

    for i in range(n):
        if A[i] == 'x':
            countTillMedian += 1
            if countTillMedian == noPersons:
                return i


class Solution:
    # @param A : string
    # @return an integer
    def seats(self, A):
        A = list(A)
        n = len(A)

        if n == 0:
            return 0
        noPersons = getPersonsNo(A)
        if noPersons <= 1:
            return 0

        medianPos = findMedianPos(A)
        ret = 0
        i = 0
        j = medianPos
        # Move all persons from before medianPos
        while i < j:
            if A[i] == 'x' and A[j] == '.':
                A[j] = A[i]
                A[i] = '.'
                ret += (j - i)
                i += 1
                j -= 1
            elif A[j] == 'x':
                j -= 1
            else:
                i += 1

        i = n - 1
        j = medianPos
        # Move all persons from after medianPos
        while j < i:
            if A[i] == 'x' and A[j] == '.':
                A[j] = A[i]
                A[i] = '.'
                ret += (i - j)
                i -= 1
                j += 1
            elif A[j] == 'x':
                j += 1
            else:
                i -= 1
        return ret % MOD"
Sum Of Fibonacci Numbers,https://www.interviewbit.com/problems/sum-of-fibonacci-numbers/,N/A,Graph Data Structure & Algorithms,medium,"Problem Description
 
 

How many minimum numbers from the Fibonacci series are required such that the sum of numbers should be equal to a given Number A? 
Note: repetition of numbers is allowed.


Problem Constraints
1 <= A <= 109


Input Format
The first argument is an integer A.


Output Format
Return an integer equal to the minimum number of Fibonacci numbers whose sum is equal to A


Example Input
Input 1:
A = 4
Input 2:
A = 7


Example Output
Output 1:
2
Output 2:
2


Example Explanation
Explanation 1:
Two numbers are required, A = 4 which is equal to (2 + 2)
Explanation 2:
Two numbers are required, A = 7 which is equal to (2 + 5)","int Solution::fibsum(int A) {
    int fibs[46] = {1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903};
    int ans = 0;
    int i = 45;
    for( i=45;i>=0;i-- ) {
        while( A >= fibs[i] ) {
            A -= fibs[i];
            ++ans;
        }
    }
    return ans;
}"
Stepping Numbers,https://www.interviewbit.com/problems/stepping-numbers/,Amazon,Graph Data Structure & Algorithms,medium,"Problem Description
 
 

Given A and B you have to find all stepping numbers in the range A to B (both inclusive).

The stepping number:

A number is called as a stepping number if the adjacent digits have a difference of 1.

For e.g. 123 is a stepping number, but 358 is not a stepping number

 



Problem Constraints
0 <= A <= 104
1 <= B <= 107
A <= B


Input Format
First argument is an integer A.

Second argument is an integer B.

 



Output Format
Return a integer array sorted in ascending order denoting the stepping numbers between A and B.



Example Input
Input 1:

 A = 10
 B = 20
 



Example Output
Output 1:

 [10, 12]
 



Example Explanation
Explanation 1:

 The stepping numbers in range [10, 20] are 10, and 12. 
 ","vector<int> Ans;
void dfs(int len, int N, int M, int num = 0) {
    if(num >= N && num <= M) {
            Ans.push_back(num);
     }
     if(len == 0)
        return;
    

    if(num == 0) {
        for(int i = 1; i <= 9; ++i) {
            dfs(len - 1, N, M, i);
        }
        return;
    }

    int last_dig = num%10;
    if(last_dig == 0) {
    
        dfs(len - 1, N, M, (num * 10) + (last_dig + 1));
    
    } else if(last_dig == 9) {
    
        dfs(len - 1, N, M, (num * 10) + (last_dig - 1));
    
    } else {
        dfs(len - 1, N, M, (num * 10) + (last_dig - 1));
        dfs(len - 1, N, M, (num * 10) + (last_dig + 1));
    }
}

vector<int> Solution:: stepnum(int N, int M) {
    int len = 0;
    int temp = M;
    Ans.clear();
    while(temp) {
        temp /= 10;
        len++;
    }

    Ans.clear();
    dfs(len, N, M);
    sort(Ans.begin(), Ans.end());
    return Ans;
}"
REC_CMPL1,https://www.interviewbit.com/problems/reccmpl1/,Amazon,Time Complexity,easy,"What is the worst case time complexity of the following code :

/* 
 * V is sorted 
 * V.size() = N
 * The function is initially called as searchNumOccurrence(V, k, 0, N-1)
 */
int searchNumOccurrence(vector<int> &V, int k, int start, int end) {
    if (start > end) return 0;
    int mid = (start + end) / 2;
    if (V[mid] < k) return searchNumOccurrence(V, k, mid + 1, end);
    if (V[mid] > k) return searchNumOccurrence(V, k, start, mid - 1);
    return searchNumOccurrence(V, k, start, mid - 1) + 1 + searchNumOccurrence(V, k, mid + 1, end);
}
NOTE : This question involves recursion which will be explained later in topic Backtracking. So, if you are not able to approach this question now, you can give it a try later.O(sqrt N)
O(log N)
O(log^2 N )
O(N)
O(N * log N)
O(N * sqrt N)","It might seem at the first look that the program is O(log N). 
However, the last case 

return searchNumOccurrence(V, k, start, mid - 1) + 1 + searchNumOccurrence(V, k, mid + 1, end);


is the bottleneck step. 
Assuming all the values in the array are the same, we get the following relation : 

T(N) = 2 * T(N/2) + constant

     = 4 * T(N/4) + constant     ( 2 * constant = another constant ) 

     = 8 * T(N/8) + constant 

     …

     = N * T(N/N) + constant 

     = N + constant 

     = O(N)

"
REC_CMPL2,https://www.interviewbit.com/problems/reccmpl2/,N/A,Time Complexity,easy,"What is the worst case time complexity of the following code:

int findMinPath(vector<vector<int> > &V, int r, int c) {
  int R = V.size();
  int C = V[0].size();
  if (r >= R || c >= C) return 100000000; // Infinity
  if (r == R - 1 && c == C - 1) return 0;
  return V[r][c] + min(findMinPath(V, r + 1, c), findMinPath(V, r, c + 1));
}
Assume R = V.size() and C = V[0].size().

NOTE : This question involves recursion which will be explained later in topic Backtracking. So, if you are not able to approach this question now, you can give it a try later.","Note that in every function call, we end up making 2 calls.

So, the function calls ends up looking like a tree :

                   F(0,0)
                /          \ 
            F(0, 1)         F(1, 0)
             /    \         /       \ 
          F(0, 2)  F(1,1)  F(1, 1)  F(2, 0)
             ....
The function calls end up making a complete binary tree.

  Number of calls on Level 0 = 1
  Number of calls on Level 1 = 2
  Number of calls on Level 2 = 4
  ...
  Number of calls on level i = 2^i. 
Total number of calls = 1 + 2 + 4 + ... 2^i + ... 2^(M + N - 2)  
                      = O(2^(M + N))"
REC_CMPL3,https://www.interviewbit.com/problems/reccmpl3/,N/A,Time Complexity,easy,"What is the worst case time complexity of the following code:

int memo[101][101];
int findMinPath(vector<vector<int> >& V, int r, int c) {
  int R = V.size();
  int C = V[0].size();
  if (r >= R || c >= C) return 100000000; // Infinity
  if (r == R - 1 && c == C - 1) return 0;
  if (memo[r][c] != -1) return memo[r][c];
  memo[r][c] =  V[r][c] + min(findMinPath(V, r + 1, c), findMinPath(V, r, c + 1));
  return memo[r][c];
}

Callsite : 
memset(memo, -1, sizeof(memo));
findMinPath(V, 0, 0);
Assume R = V.size() and C = V[0].size() and V has positive elements

NOTE : This question involves recursion which will be explained later in topic Backtracking. So, if you are not able to approach this question now, you can give it a try later.","Note that for a given `(r, c)`
 
the following code will not be executed more than once : 

memo[r][c] =  V[r][c] + min(findMinPath(V, r + 1, c), findMinPath(V, r, c + 1));


Once memo[r][c] is set, the functions will return at 

if (memo[r][c] != -1) return memo[r][c];


So, every function ends up calling other functions at most 1 time. 
In other words, every function ends up executing atmost O(1) times (Note that you can shift the part about checking for memo[r][c] != -1 at the callsite ).

`O(R * C)` possible number of combinations are possible for `(r, c)`
Hence, the time complexity of the function : O(R*C)"
Equal,https://www.interviewbit.com/problems/equal/,Facebook,Hashing,medium,"Problem Description
 
 

Given an array A of N integers, find the index of values that satisfy P + Q = R + S, where P, Q, R & S are integers values in the array

Expected time complexity O(N2)

NOTE:
1) Return the indices A1 B1 C1 D1, so that 
  A[A1] + A[B1] = A[C1] + A[D1]
  A1 < B1, C1 < D1
  A1 < C1, B1 != D1, B1 != C1 
2) If there are more than one solutions,
   then return the tuple of values which are lexicographical smallest. 

Assume we have two solutions
S1 : A1 B1 C1 D1 ( these are values of indices in the array )
S2 : A2 B2 C2 D2

S1 is lexicographically smaller than S2 if:
  A1 < A2 OR
  A1 = A2 AND B1 < B2 OR
  A1 = A2 AND B1 = B2 AND C1 < C2 OR 
  A1 = A2 AND B1 = B2 AND C1 = C2 AND D1 < D2
If no solution is possible, return an empty list.


Problem Constraints
1 <= N <= 1000

0 <= A[i] <= 1000



Input Format
First and only argument is an integer array A of length N.



Output Format
Return an array of size four which contains indices of values P, Q, R, and S.



Example Input
Input 1:

 A = [3, 4, 7, 1, 2, 9, 8]
Input 2:

 A = [2, 5, 1, 6]


Example Output
Output 1:

 [0, 2, 3, 5]
Output 2:

 [0, 1, 2, 3]


Example Explanation
Explanation 1:

 A[0] + A[2] = A[3] + A[5]
 Note: indexes returned should be 0-based.
Explanation 2:

 A[0] + A[1] = A[2] + A[3]","vector<int> Solution::equal(vector<int> &vec) { 
    int N = vec.size();
    // With every sum, we store the lexicographically first occuring pair of integers. 
    map<int, pair<int, int> > Hash;
    vector<int> Ans;
    
    for(int i = 0; i < N; ++i) {
        for(int j = i + 1; j < N; ++j) {
            
            int Sum = vec[i] + vec[j];

            if (Hash.find(Sum) == Hash.end()) {
                Hash[Sum] = make_pair(i, j);
                continue;
            }
            
            pair<int, int> p1 = Hash[Sum];
            if(p1.first != i && p1.first != j && p1.second != i && p1.second != j) {
                vector<int> ans;
                ans.push_back(p1.first);
                ans.push_back(p1.second);
                ans.push_back(i);
                ans.push_back(j);
                
                if (Ans.size() == 0) Ans = ans;
                else {
                    // compare and assign Ans
                    bool shouldReplace = false;
                    for (int i1 = 0; i1 < Ans.size(); i1++) {
                        if (Ans[i1] < ans[i1]) break;
                        if (Ans[i1] > ans[i1]) {
                            shouldReplace = true;
                            break;
                        }
                    }
                    if (shouldReplace) Ans = ans;
                }
            }
        }
    }

    return Ans;
}"
Highest Product,https://www.interviewbit.com/problems/highest-product/,Amazon,Greedy Algorithm,easy,"Problem Description
 
 

Given an array A, of N integers A.
Return the highest product possible by multiplying 3 numbers from the array.
NOTE: The solution will fit in a 32-bit signed integer.


Problem Constraints
3 <= N <= 5*105


Input Format
The first and the only argument is an integer array A.


Output Format
Return the highest possible product.


Example Input
Input 1:
A = [1, 2, 3, 4]
Input 2:
A = [0, -1, 3, 100, 70, 50]


Example Output
Output 1:
24
Output 1:
350000


Example Explanation
Explanation 1:
2 * 3 * 4 = 24
Explanation 2:
70 * 50 * 100 = 350000","int Solution::maxp3(vector<int> &A) {
    if (A.size() < 3)
        return 0;
    sort(A.begin(), A.end());       
    int n = A.size();
    int ans = max(A[n - 1] * A[n - 2] * A[n - 3], A[0] * A[1] * A[n - 1]);
    return ans;
}"
Assign Mice to Holes,https://www.interviewbit.com/problems/assign-mice-to-holes/,Amazon,Greedy Algorithm,easy,"Problem Description

There are N Mice and N holes that are placed in a straight line. Each hole can accomodate only 1 mouse.

The positions of Mice are denoted by array A and the position of holes are denoted by array B.

A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x ? 1. Any of these moves consumes 1 minute.

Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.



Problem Constraints
1 <= N <= 105

-109 <= A[i], B[i] <= 109



Input Format
First argument is an integer array A.

Second argument is an integer array B.



Output Format
Return an integer denoting the minimum time when the last nouse gets inside the holes.



Example Input
Input 1:

 A = [-4, 2, 3]
 B = [0, -2, 4]
Input 2:

 A = [-2]
 B = [-6]


Example Output
Output 1:

 2
Output 2:

 4


Example Explanation
Explanation 1:

 Assign the mouse at position (-4 to -2), (2 to 0) and (3 to 4).
 The number of moves required will be 2, 2 and 1 respectively.
 So, the time taken will be 2.
Explanation 2:

 Assign the mouse at position -2 to -6.
 The number of moves required will be 4.
 So, the time taken will be 4.","int Solution::mice(vector<int> &A, vector<int> &B) {
    int i,j,n=A.size(),ans=0;
    sort(A.begin(),A.end());sort(B.begin(),B.end());
    for(int i=0;i<n;i++)
        ans=max(ans,abs(A[i]-B[i]));
    return ans;
}"
Black Shapes,https://www.interviewbit.com/problems/black-shapes/,Amazon,Graph Data Structure & Algorithms,medium,"Given N x M character matrix A of O's and X's, where O = white, X = black.


Return the number of black shapes. A black shape consists of one or more adjacent X's (diagonals not included)




Input Format:

    The First and only argument is a N x M character matrix.
Output Format:

    Return a single integer denoting number of black shapes.
Constraints:

    1 <= N,M <= 1000
    A[i][j] = 'X' or 'O'
Example:

Input 1:
    A = [ OOOXOOO
          OOXXOXO
          OXOOOXO  ]
Output 1:
    3
Explanation:
    3 shapes are  :
    (i)    X
         X X
    (ii)
          X
    (iii)
          X
          X
Note: we are looking for connected shapes here.

XXX
XXX
XXX
is just one single connected black shape.",x`
Knight On Chess Board,https://www.interviewbit.com/problems/knight-on-chess-board/,Amazon,Graph Data Structure & Algorithms,medium,"Given any source point, (C, D) and destination point, (E, F) on a chess board, we need to find whether Knight can move to the destination or not.

Knight's movements on a chess board

The above figure details the movements for a knight ( 8 possibilities ).

If yes, then what would be the minimum number of steps for the knight to move to the said point.

If knight can not move from the source point to the destination point, then return -1.

Note: A knight cannot go out of the board.



Input Format:

The first argument of input contains an integer A.
The second argument of input contains an integer B.
    => The chessboard is of size A x B.
The third argument of input contains an integer C.
The fourth argument of input contains an integer D.
    => The Knight is initially at position (C, D).
The fifth argument of input contains an integer E.
The sixth argument of input contains an integer F.
    => The Knight wants to reach position (E, F).
Output Format:

If it is possible to reach the destination point, return the minimum number of moves.
Else return -1.
Constraints:

1 <= A, B <= 500
Example

Input 1:
    A = 8
    B = 8
    C = 1
    D = 1
    E = 8
    F = 8
    
Output 1:
    6

Explanation 1:
    The size of the chessboard is 8x8, the knight is initially at (1, 1) and the knight wants to reach position (8, 8).
    The minimum number of moves required for this is 6.","int dx[]={-2,-2,+2,+2,+1,-1,+1,-1};
int dy[]={+1,-1,+1,-1,-2,-2,+2,+2};

bool valid(int x,int y,vector<vector<int>>& vis)
{
    return (x>=1 && y>=1 && x<vis.size() && y<vis[0].size());
}
int Solution::knight(int A, int B, int C, int D, int E, int F) {
    
    vector<vector<int>> vis(A+1,vector<int>(B+1,0));
    
    
    queue<pair<int,int>> q;
    q.push({C,D});
    vis[C][D]=1;
    
    int step=0;
    while(not q.empty())
    {
        int s=q.size();
        while(s--)
        {
            int x=q.front().first;
            int y=q.front().second;
            
            q.pop();
            
            if(x==E && y==F)
            return step;
            
            for(int d=0;d<8;d++)
            {
                int nx=x+dx[d];
                int ny=y+dy[d];
                
                if(valid(nx,ny,vis) && not vis[nx][ny])
                {
                    vis[nx][ny]=1;
                    q.push({nx,ny});
                }
            }
        }
        step++;
    }
    
    return -1;
    
}"
Anti Diagonals,https://www.interviewbit.com/problems/anti-diagonals/,"Microsoft, Adobe",Arrays,easy,"Problem Description

Give a N*N square matrix, return an array of its anti-diagonals. Look at the example for more details.
Example:

Input:

1 2 3
4 5 6
7 8 9
Return the following:
[ 
  [1],
  [2, 4],
  [3, 5, 7],
  [6, 8],
  [9]
]


Input: 
1 2
3 4
Return the following: 
[
  [1],
  [2, 3],
  [4]
]","vector<vector<int> > Solution::diagonal(vector<vector<int> > &A) {
    int n = A.size(), d,i;
    vector<vector<int> > ret;
    if (n <= 0 || A[0].size() != n) {
        return ret;
    }
    vector<int> temp;
    for (d = 0; d < 2*n - 1; ++d) {
        temp.clear();
        for (i = 0; i <= d; ++i) {
            if (i < n && d-i < n) {
                temp.push_back(A[i][d-i]);
            }
        }
        if (temp.size() > 0) {
            ret.push_back(temp);
        }
    }
    return ret;
}"
Hotel Bookings Possible,https://www.interviewbit.com/problems/hotel-bookings-possible/,"Microsoft, Amazon",Arrays,medium,"Problem Description
 
 

A hotel manager has to process N advance bookings of rooms for the next season. His hotel has C rooms. Bookings contain an arrival date and a departure date. He wants to find out whether there are enough rooms in the hotel to satisfy the demand. Write a program that solves this problem in time O(N log N) .

Note- If we have arrival and departure on the same date then arrival must be served before the departure.


Problem Constraints
1 <= |A| <= 106
|A|== |B|
1 <= Ai <= Bi <= 108
1 <= C <= 106



Input Format
First argument is an integer array A containing arrival time of booking.

Second argument is an integer array B containing departure time of booking.

Third argument is an integer C denoting the count of rooms.



Output Format
Return True if there are enough rooms for N bookings else return False.

Return 0/1 for C programs.



Example Input
Input 1:

 A = [1, 3, 5]
 B = [2, 6, 8]
 C = 1
Input 2:

 A = [1, 2, 3]
 B = [2, 3, 4]
 C = 2


Example Output
Output 1:

 0
Output 2:

 1


Example Explanation
Explanation 1:

 At day = 5, there are 2 guests in the hotel. But I have only one room.
Explanation 2:

 At day = 1, there is 1 guest in the hotel.
 At day = 2, there are 2 guests in the hotel. 
 At day = 3, there are 2 guests in the hotel.
 At day = 4, there is 1 guest in the hotel.

 We have two rooms available, which satisfy the demand.","bool Solution::hotel(vector<int> &arrive, vector<int> &depart, int K) 
{
    assert(K>0 && K<=1000000);
    for(int a:arrive)
        assert(a>=0 && a<=1e8);
    for(int a:depart)
        assert(a>=0 && a<=1e8);
    for(int i=0;i<arrive.size();i++)
        assert(arrive[i]<=depart[i]);
    if(K == 0)
            return false;

    int N = arrive.size();
    assert(N>=1 && N<=1e6);
    vector<pair<int, int> > vec;
    for(int i = 0; i < N; ++i) {
        vec.push_back(make_pair(arrive[i], 0));
        vec.push_back(make_pair(depart[i], 1));
    }
     
    sort(vec.begin(), vec.end());
    
    int curActive = 0;
    int maxAns = 0;
    for (int i = 0; i < vec.size(); i++) {
       if (vec[i].second == 0) { // arrival
           curActive++;
           maxAns = max(maxAns, curActive);
        } else {
            curActive--;
        }
    } 
    if (K >= maxAns) return true;
    return false;
}"
Min Steps in Infinite Grid,https://www.interviewbit.com/problems/min-steps-in-infinite-grid/,"Directi, Amazon",Arrays,easy,"Problem Description
 
 

You are in an infinite 2D grid where you can move in any of the 8 directions

 (x,y) to 
    (x-1, y-1), 
    (x-1, y)  , 
    (x-1, y+1), 
    (x  , y-1),
    (x  , y+1), 
    (x+1, y-1), 
    (x+1, y)  , 
    (x+1, y+1) 
You are given a sequence of points and the order in which you need to cover the points.. Give the minimum number of steps in which you can achieve it. You start from the first point.

NOTE: This question is intentionally left slightly vague. Clarify the question by trying out a few cases in the “See Expected Output” section.



Problem Constraints
1 <= |A| <= 106
- 2 * 103 <= Ai, Bi <= 2 * 103
|A| == |B|


Input Format
Given two integer arrays A and B, where A[i] is x coordinate and B[i] is y coordinate of ith point respectively.



Output Format
Return an Integer, i.e minimum number of steps.



Example Input
Input 1:

 A = [0, 1, 1]
 B = [0, 1, 2]


Example Output
Output 1:

 2


Example Explanation
Explanation 1:

 Given three points are: (0, 0), (1, 1) and (1, 2).
 It takes 1 step to move from (0, 0) to (1, 1). It takes one more step to move from (1, 1) to (1, 2).","class Solution {
    public:
        int coverPoints(vector<int> x, vector<int> y) {
            if (x.size() <= 1) return 0;
            assert(x.size() == y.size());
            int ans = 0;
            for (int i = 1; i < x.size(); i++) {
                ans += max(abs(x[i] - x[i-1]), abs(y[i] - y[i-1]));
            }
            return ans;
        }
};"
Power Of Two Integers,https://www.interviewbit.com/problems/power-of-two-integers/,"Housing, Amazon",Math,medium,"Problem Description
 
 

Given a positive integer that fits in a 32-bit signed integer, find if it can be expressed as A^P where P > 1 and A > 0.
A and P both should be integers.


Problem Constraints
1 <= A <= 109


Input Format
The first argument is an integer A.


Output Format
Return an integer, 1 for True, 0 for False


Example Input
A = 4


Example Output
1


Example Explanation
A = 4, it can be written as 2 ^ 2","int Solution::isPower(int A) {
    int i,j;
    
    int n = int(ceil(sqrt(A)));
    
    if (A == 1) {
        return true;
    }
    //cout << n+1 << endl;
    vector<bool>v(n+1, true);
    v[0] = false;
    v[1] = false;
    
    
    for(i=2;i<=n;i++)
    {
        if (i > n/i) {
            break;
        }
        if(v[i])
        {
            //m.push_back(i);
            for(j=i*i;j<=n;j+=i)
            {
                v[j]=false;
            }
        }
    }
    float temp;
    for (i = 2; i <= A; ++i) {
        if (i > A/i) {
            break;
        }
        if (v[i]) {
            temp = exp(std::log(A)/i);;
            //cout << temp << endl;
            if (temp == ceil(temp)) {
                return true;
            }
        }
    }
    return false;
}"
Prime Sum,https://www.interviewbit.com/problems/prime-sum/,N/A,Math,easy,"Problem Description
 
 

Given an even number ( greater than 2 ), return two prime numbers whose sum will be equal to the given number.
If there is more than one solution possible, return the lexicographically smaller solution i.e.
If [a, b] is one solution with a <= b,
and [c,d] is another solution with c <= d, then

[a, b] < [c, d] 
If a < c OR ( a == c AND b < d ).
NOTE: A solution will always exist. read Goldbach's conjecture


Problem Constraints
1 <= A <= 2 * 107


Input Format
The first argument is an integer A.


Output Format
Return an array of integers.


Example Input
4


Example Output
[2, 2]


Example Explanation
2 + 2 equals 4, which is the lexicographically smaller solution
","vector<int> Solution::primesum(int A) {
    int n=A;
    int i,j;
    
    vector<bool>v(n+1, true);
    v[0] = false;
    v[1] = false;
    
    vector<int>m(2,0);
    
    for(i=2;i<=n;i++)
    {
        if (i > n/i) {
            break;
        }
        if(v[i])
        {
            //m.push_back(i);
            for(j=i*i;j<=n;j+=i)
            {
                v[j]=false;
            }
        }
    }
    
    for (i = 2; i <= A/2; ++i) {
        if (v[i] && v[A-i]) {
            m[0] = i;
            m[1] = A-i;
            return m;
        }
    }
    
    return m;
}"
Largest Continuous Sequence Zero Sum,https://www.interviewbit.com/problems/largest-continuous-sequence-zero-sum/,Microsoft,Hashing,medium,"Problem Description
 
 

 Given an array A of N integers.

Find the largest continuous sequence in a array which sums to zero.



Problem Constraints
1 <= N <= 106

 -107 <= A[i] <= 107



Input Format
Single argument which is an integer array A.



Output Format
Return an array denoting the longest continuous sequence with total sum of zero.

NOTE : If there are multiple correct answers, return the sequence which occurs first in the array.



Example Input
A = [1,2,-2,4,-4]


Example Output
[2,-2,4,-4]


Example Explanation
[2,-2,4,-4] is the longest sequence with total sum of zero.","vector<int> Solution::lszero(vector<int> &A) {
    int n = A.size();
    vector<int> ret;
    if (n == 0) {
        return ret;
    }
    vector<int> sum(n, 0);
    sum[0] = A[0];
    int i;
    int retStart=-1, retEnd=-1;
    std::map<int,int> sumDict;
    
    for (i = 1; i < n; ++i) {
        sum[i] += A[i] + sum[i-1];
    }
    for (i = 0; i < n; ++i) {
        //cout << sum[i] << endl;
        if (sum[i] == 0) {
            retStart = -1;
            retEnd = i;
        }
    }

    for (i = 0; i < n; ++i) {
        if (sumDict.find(sum[i]) != sumDict.end()) {
            if (retStart == -1 && retEnd == -1) {
                retStart = sumDict[sum[i]];
                retEnd = i;
            } else if (retEnd - retStart < i - sumDict[sum[i]]) {
                retStart = sumDict[sum[i]];
                retEnd = i;
            }
        } else {
            sumDict[sum[i]] = i;
        }
    }
    vector<int> sol(A.begin()+retStart+1, A.begin() + retEnd+1);
    return sol;
}"
Arrange II,https://www.interviewbit.com/problems/arrange-ii/,Amazon,Dynamic Programming,medium,"You are given a sequence of black and white horses, and a set of K stables numbered 1 to K. You have to accommodate the horses into the stables in such a way that the following conditions are satisfied:

You fill the horses into the stables preserving the relative order of horses. For instance, you cannot put horse 1 into stable 2 and horse 2 into stable 1. You have to preserve the ordering of the horses.
No stable should be empty and no horse should be left unaccommodated.
Take the product (number of white horses * number of black horses) for each stable and take the sum of all these products. This value should be the minimum among all possible accommodation arrangements
Example:


Input: {WWWB} , K = 2
Output: 0

Explanation:
We have 3 choices {W, WWB}, {WW, WB}, {WWW, B}
for first choice we will get 1*0 + 2*1 = 2.
for second choice we will get 2*0 + 1*1 = 1.
for third choice we will get 3*0 + 0*1 = 0.

Of the 3 choices, the third choice is the best option. 

If a solution is not possible, then return -1","int Solution::arrange(string A, int B) {
    vector<vector<int> > dp(A.size()+1, vector<int> (B+1, 0));
    for (int i = 1; i <= A.size(); i++) {
        for (int j = 1; j <= B; j++) {
            if (j > i) {
                dp[i][j] = -1;
                continue;
            }
            int b = 0,w = 0;
            dp[i][j] = INT_MAX;
            for (int k = i; k >= 1; k--) {
                if (j > k) break;
                if (A[k-1]  =='B')
                    b++;
                else 
                    w++;
                if (dp[k-1][j-1] != -1)
                    dp[i][j] = min(dp[k-1][j-1]+b*w, dp[i][j]);
            }
            if (j == 1)
                dp[i][j] = b*w;
        }
    }
    return dp[A.size()][B];
}"
Equal Average Partition,https://www.interviewbit.com/problems/equal-average-partition/,Amazon,Dynamic Programming,medium,"Problem Description
 
 

Given an array A with non negative numbers, divide the array into two parts such that the average of both the parts is equal.

Return both parts (If exist). If there is no solution. return an empty list.

NOTE:

If a solution exists, you should return a list of exactly 2 lists of integers A and B which follow the following condition :

numElements in A <= numElements in B
If numElements in A = numElements in B, then A is lexicographically smaller than B ( Lexicographical Order )
If multiple solutions exist, return the solution where length(A) is minimum. If there is still a tie, return the one where A is lexicographically smallest.

The array will contain only non-negative numbers.

 



Problem Constraints
1 <= |A| <= 100
0 <= Ai <= 100
0 <= ?(Ai) <= 5000


Input Format
First and only argument is an integer array A.


Output Format
Return 2D array consisting of two rows where each row denoted a partition.


Example Input
Input 1:

 A = [1 7 15 29 11 9]


Example Output
Output 1:

 [9 15] [1 7 11 29]


Example Explanation
Explanation 1:

 The average of part is (15+9)/2 = 12, average of second part elements is (1 + 7 + 11 + 29) / 4 = 12","//Similar to subset sum problem but with an additional constraint on the length of the subset
//time=O(n*2^n)(w/o dp) time=O(n*n*sum)(with dp)
// bool customComp(vector<int> &A1,vector<int> &A2){
// if(A1.size()<A2.size())
// return true;
// if(A1.size()==A2.size()){
// int i=0;
// while(i<A1.size() && A1[i]==A2[i])
// i++;
// return (i==A1.size() || A1[i]<A2[i]);
// }
// return false;
// }
bool isPossible(int idx, int size, int sum, vector < int > & A, vector < int > & A1, vector < vector < vector < bool >>> & dp) {
  //base cases
  if (size == 0)
    return sum == 0;
  if (idx == A.size())
    return false;
  //The very first time we get a solution we exit. So calcuations are getting repeated for false cases. So we check if (idx,size,sum) has already been
  //calculated i.e been set to false. If yes, return else calculate save and return.
  if (dp[idx][size][sum] == false)
    return dp[idx][size][sum];
  if (A[idx] <= sum) {
    //option1:use idx th element
    A1.push_back(A[idx]);
    if (isPossible(idx + 1, size - 1, sum - A[idx], A, A1, dp))
      return true;
    A1.pop_back();
    //this can also be done since A[idx]> sum so there's no point going any further since A is sorted
    // if(isPossible(idx+1,size,sum,A,A1,dp))
    // return true;
  }
  if (isPossible(idx + 1, size, sum, A, A1, dp))
    return true;
  return dp[idx][size][sum] = false;
}
vector < vector < int > > Solution::avgset(vector < int > & A) {
  assert(A.size() >= 1 && A.size() <= 100);
  int sum = 0;
  for( auto it: A ) {
      assert(it >= 0 && it <= 100); 
        sum += it;
  }
  assert(sum >= 0 && sum <= 5000);
  sort(A.begin(), A.end());
  int n = A.size();
  int s = 0;
  for (int num: A)
    s += num;
  vector < vector < vector < bool >>> dp(101, vector < vector < bool >> (101, vector < bool > (5001, true)));
  // dp[i][j][k] tells if in A[i...n-1],there exists a subset of length j with sum k
  vector < vector < int >> ans;
  // subset1:sum=s1 size=n1 subset2:sum=s2 size=n2 For equal average partition:s1/n1==s2/n2 which leads to s1=(n1*s)/n
  //size of 1st subset can be from 1 to (n-1)(since both subsets need to be non-empty). if for a given n1, s1 comes out to be decimal we can straight away say that we can't find sum s1 in A
  for (int n1 = 1; n1 < n; n1++) {
    if ((n1 * s) % n == 0) {
      int s1 = (n1 * s) / n;
      vector < int > A1;
      if (isPossible(0, n1, s1, A, A1, dp)) {
        vector < int > A2;
        int i = 0;
        for (int num: A1) {
          while (i < n && A[i] != num) {
            A2.push_back(A[i]);
            i++;
          }
          i++;
        }
        while (i < n)
          A2.push_back(A[i++]);
        ans.push_back(A1);
        ans.push_back(A2);
        //The way we generated subset1, it will follow all the ordering constraints given in the question. So we dont really need to sort.
        // sort(ans.begin(),ans.end(),customComp);
        break;
      }
    }
  }
  return ans;
}"
Sorted Permutation Rank,https://www.interviewbit.com/problems/sorted-permutation-rank/,"Housing, Microsoft, Zenefits",Math,medium,"Problem Description
 
 

Given a string A. Find the rank of the string amongst its permutations sorted lexicographically.

Assume that no characters are repeated.

Note: The answer might not fit in an integer, so return your answer % 1000003



Problem Constraints
1 <= |A| <= 1000



Input Format
First argument is a string A.



Output Format
Return an integer denoting the rank of the given string.



Example Input
Input 1:

A = ""acb""
Input 2:

A = ""a""


Example Output
Output 1:

2
Output 2:

1


Example Explanation
Explanation 1:

Given A = ""acb"".
The order permutations with letters 'a', 'c', and 'b' : 
abc
acb
bac
bca
cab
cba
So, the rank of A is 2.
Explanation 2:

Given A = ""a"".
Rank is clearly 1.
","#define mod 1000003

int fact(int n) {
    if (n == 0) return 1;
    else return ( n * fact(n - 1)) % mod;
}

int Solution::findRank(string A) {
    int ans = 0;
    int n = A.length();
    for (int i = 0; i<n-1; i++) {
        int c= 0;
        for (int j = i+1; j<n; j++) {
            if (A[j] < A[i]) c++;
        }
        
        ans += ((c * fact(n - i - 1))) % mod;
    }
    return (ans + 1) % mod;
}"
Sorted Permutation Rank with Repeats,https://www.interviewbit.com/problems/sorted-permutation-rank-with-repeats/,"Housing, Zenefits",Math,hard,"Problem Description
 
 

Given a string A, find the rank of the string amongst its permutations sorted lexicographically. Note that the characters might be repeated. If the characters are repeated, we need to look at the rank in unique permutations. Look at the example for more details.

NOTE: 

The answer might not fit in an integer, so return your answer % 1000003 where 1000003 is a prime number.
String A can consist of both lowercase and uppercase letters. Characters with lesser ASCII values are considered smaller, i.e., 'a' > 'Z'.


Problem Constraints
1 <= len(A) <= 1000000 



Input Format
First argument is a string A.



Output Format
Return an integer denoting the rank.



Example Input
Input 1:

 A = ""aba""
Input 2:

 A = ""bca""


Example Output
Output 1:

 2
Output 2:

 4


Example Explanation
Explanation 1:

 The order permutations with letters 'a', 'a', and 'b' :
    aab
    aba 
    baa
 So, the rank is 2.
Explanation 2:

 The order permutations with letters 'a', 'b', and 'c' :
    abc
    acb 
    bac
    bca
    cab
    cba
 So, the rank is 4.","int mod = 1000003;

long long power(long long x, long long y)
{
    long long res = 1;
    while (y > 0) {
        if (y & 1ll)
            res = (res * x) % mod;
        y = y >> 1;
        x = (x * x) % mod;
    }
    return res;
}
int inverse(int a)
{
    return power(a, mod - 2);
}

int Solution::findRank(string A) {
    
    multiset<char> s(A.begin(), A.end());
    long long ans = 0;

    map<char,int> f;
    for(char c : A) f[c]++;

    int n = A.size();
    vector<int> fact(n+1, 1);

    for(int i = 1; i<=n; i++) fact[i] = fact[i-1] * i, fact[i] %= mod;
    for(int i = 0; i<n; i++)
    {
        char smallest = *s.begin();
        char curr = A[i];
        for(char c = smallest; c < curr; c++)
        {
            if(f[c])
            {
                f[c]--;
                long long sum = 0;
                long long temp = 1;
                for(auto [c1, freq] : f)
                {
                    sum += freq;
                    temp *= inverse(fact[freq]), temp %= mod;
                }
                temp *= fact[sum];
                temp %= mod;
                ans += temp;
                ans %= mod;
                f[c]++;
            }
        }
        f[curr]--;
        s.erase(s.find(curr));
    }

    return (ans+1) % mod;
}"
Coin Sum Infinite,https://www.interviewbit.com/problems/coin-sum-infinite/,Microsoft,Dynamic Programming,medium,"Problem Description
 
 

You are given a set of coins A. In how many ways can you make sum B assuming you have an infinite amount of each coin in the set.

Note: Coins in set A will be unique. The expected space complexity of this problem is O(B).
Note that the answer can overflow. So, give us the answer % 1000007


Problem Constraints
1 <= |A| <= 500
1 <= B <= 5 * 104


Input Format
The first argument is an integer array A.
The second argument is an integer B.


Output Format
Return the answer % 1000007


Example Input
A = [1, 2, 3]
B = 4


Example Output
4


Example Explanation
The 4 possible ways are
{1, 1, 1, 1}
{1, 1, 2}
{2, 2}
{1, 3}","int Solution::coinchange2(vector<int> &A, int B) {
    int mod = 1000007;
    int n = A.size();
    vector<int> dp(B + 1, 0);
    dp[0] = 1;
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= B; j++){
            if(j >= A[i - 1]){
                dp[j] += dp[j - A[i - 1]];
                dp[j] %= mod;
            }
        }
    }
    return dp[B];
}"
Bulbs,https://www.interviewbit.com/problems/interview-questions/,N/A,Greedy Algorithm,easy,"Problem Description
 
 

N light bulbs are connected by a wire.

Each bulb has a switch associated with it, however due to faulty wiring, a switch also changes the state of all the bulbs to the right of current bulb.

Given an initial state of all bulbs, find the minimum number of switches you have to press to turn on all the bulbs.

You can press the same switch multiple times.

Note : 0 represents the bulb is off and 1 represents the bulb is on.


Problem Constraints
0 <= N <= 5e5
0 <= A[i] <= 1


Input Format
The first and the only argument contains an integer array A, of size N.


Output Format
Return an integer representing the minimum number of switches required.


Example Input
A = [0 1 0 1]


Example Output
4


Example Explanation
press switch 0 : [1 0 1 0]
press switch 1 : [1 1 0 1]
press switch 2 : [1 1 1 0]
press switch 3 : [1 1 1 1]","class Solution {
    public:
	    int bulbs(vector<int> &A) {
		    int state= 0, ans = 0;
		    for (int i = 0;i < A.size();i++) {
			    if (A[i] == state) {
				    ans++;
				    state = 1 - state;
			    }
		    }
		    return ans;
	    }
};"
Flip,https://www.interviewbit.com/problems/flip/,"Microsoft, Amazon",Arrays,easy,"Problem Description
 
 

You are given a binary string A(i.e. with characters 0 and 1) consisting of characters A1, A2, ..., AN. In a single operation, you can choose two indices L and R such that 1 ? L ? R ? N and flip the characters AL, AL+1, ..., AR. By flipping, we mean change character 0 to 1 and vice-versa.

Your aim is to perform ATMOST one operation such that in final string number of 1s is maximised.

If you don't want to perform the operation, return an empty array. Else, return an array consisting of two elements denoting L and R. If there are multiple solutions, return the lexicographically smallest pair of L and R.

NOTE: Pair (a, b) is lexicographically smaller than pair (c, d) if a < c or, if a == c and b < d.



Problem Constraints
1 <= size of string <= 100000



Input Format
First and only argument is a string A.



Output Format
Return an array of integers denoting the answer.



Example Input
Input 1:

A = ""010""
Input 2:

A = ""111""


Example Output
Output 1:

[1, 1]
Output 2:

[]


Example Explanation
Explanation 1:

A = ""010""


Pair of [L, R] | Final string
____________|__________
[1 1]          | ""110""
[1 2]          | ""100""
[1 3]          | ""101""
[2 2]          | ""000""
[2 3]          | ""001""



We see that two pairs [1, 1] and [1, 3] give same number of 1s in final string. So, we return [1, 1].

Explanation 2:

No operation can give us more than three 1s in final string. So, we return empty array [].
","vector<int> Solution::flip(string A) {
    int n=A.length();

    //build new array of 1s and -1s
    vector<int> ar(n);
    for(int i=0; i<n; i++)
        if(A[i]=='1')ar[i]=-1;
        else ar[i]=1;

    //pair storing the answer
    pair<int, int> ans=make_pair(INT_MAX, INT_MAX);

    //basic kadane's algorithm implementation
    //we also storing the begin point for best till now
    int best_till_now=0,best_ending_here=0,l=0;
    for(int i=0; i<n; i++){
        if(best_ending_here+ar[i]<0){
            l=i+1;
            best_ending_here=0;
        }
        else best_ending_here+=ar[i];
        if(best_ending_here>best_till_now){
            best_till_now=best_ending_here;
            ans.first=l;
            ans.second=i;
        }
    }

    //if no valid subarray found
    if(ans.first==INT_MAX)return vector<int>();

    //return answer
    vector<int> ret;
    ret.push_back(ans.first+1);
    ret.push_back(ans.second+1);
    return ret;
}"
Different Bits Sum Pairwise,https://www.interviewbit.com/problems/different-bits-sum-pairwise/,"Google, Zenefits",Bit Manipulation,medium,"Problem Description
 
 

We define f(X, Y) as the number of different corresponding bits in the binary representation of X and Y. 
For example, f(2, 7) = 2, since the binary representation of 2 and 7 are 010 and 111, respectively. The first and the third bit differ, so f(2, 7) = 2.

You are given an array of N positive integers, A1, A2,..., AN. Find sum of f(Ai, Aj) for all pairs (i, j) such that 1 ? i, j ? N. Return the answer modulo 109+7.



Problem Constraints
1 <= N <= 105

1 <= A[i] <= 231 - 1



Input Format
The first and only argument of input contains a single integer array A.



Output Format
Return a single integer denoting the sum.



Example Input
Input 1:

 A = [1, 3, 5]
Input 2:

 A = [2, 3]


Example Output
Ouptut 1:

 8
Output 2:

 2


Example Explanation
Explanation 1: 

 f(1, 1) + f(1, 3) + f(1, 5) + f(3, 1) + f(3, 3) + f(3, 5) + f(5, 1) + f(5, 3) + f(5, 5) 
 = 0 + 1 + 1 + 1 + 0 + 2 + 1 + 2 + 0 = 8
Explanation 2:

 f(2, 2) + f(2, 3) + f(3, 2) + f(3, 3) = 0 + 1 + 1 + 0 = 2","typedef long long LL;
#define MOD 1000000007ll
int Solution::cntBits(vector<int> &A) {
    int ans=0,n=A.size();

    //traverse over all bits
    for(int i=0; i<31; i++){

        //count number of elements with ith bit = 0
        LL cnt=0;
        for(int j=0; j<n; j++)
            if((A[j]&(1<<i)))cnt++;

        //add to answer cnt*(n-cnt)*2
        ans += (cnt*((LL)n-cnt)*2)%MOD;
        if(ans>=MOD)ans-=MOD;

    }

    return ans;
}"
Palindrome List,https://www.interviewbit.com/problems/palindrome-list/,"Amazon, Microsoft",Linked Lists,medium,"Problem Description
 
 

Given a singly linked list A, determine if it's a palindrome. Return 1 or 0, denoting if it's a palindrome or not, respectively.



Problem Constraints
 1 <= |A| <= 105 



Input Format
The first and the only argument of input contains a pointer to the head of the given linked list. 



Output Format
 Return 0, if the linked list is not a palindrome. 

 Return 1, if the linked list is a palindrome. 



Example Input
 Input 1: 

A = [1, 2, 2, 1]
Input 2:

A = [1, 3, 2]


Example Output
 Output 1: 

 1 
 Output 2: 

 0 


Example Explanation
Explanation 1:

 The first linked list is a palindrome as [1, 2, 2, 1] is equal to its reversed form.
Explanation 2:

 The second linked list is not a palindrom as [1, 3, 2] is not equal to [2, 3, 1].","/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */

ListNode* reverseList(ListNode* A){
    ListNode* prev=NULL;
    ListNode* nxt=NULL;
    while(A){
        nxt=A->next;
        A->next=prev;
        prev=A;
        A=nxt;
    }
    return prev;
} 

int Solution::lPalin(ListNode* A) {
    ListNode* HEAD = A;
    int size=0;
    while(A){
        size++;
        A=A->next;
    }
    int mygo = size/2;
    A=HEAD;
    ListNode* TAIL=NULL;
    if(size%2==0){    
        while(mygo--){
            A=A->next;
        }
        TAIL = reverseList(A);
    }
    else{
        mygo++;
        while(mygo--){
            A=A->next;
        }
        TAIL = reverseList(A);
    }
    for(int i=0;i<size/2;i++){
        if(HEAD->val!=TAIL->val) return 0;
        HEAD = HEAD->next;
        TAIL = TAIL->next;
    }
    return 1;
    
}"
Nearest Smaller Element,https://www.interviewbit.com/problems/nearest-smaller-element/,"Amazon, Microsoft",Stacks And Queues,easy,"Given an array, find the nearest smaller element G[i] for every element A[i] in the array such that the element has an index smaller than i.

More formally,

    G[i] for an element A[i] = an element A[j] such that 
    j is maximum possible AND 
    j < i AND
    A[j] < A[i]
Elements for which no smaller element exist, consider next smaller element as -1.

Input Format

The only argument given is integer array A.
Output Format

Return the integar array G such that G[i] contains nearest smaller number than A[i].If no such element occurs G[i] should be -1.
For Example

Input 1:
    A = [4, 5, 2, 10, 8]
Output 1:
    G = [-1, 4, -1, 2, 2]
Explaination 1:
    index 1: No element less than 4 in left of 4, G[1] = -1
    index 2: A[1] is only element less than A[2], G[2] = A[1]
    index 3: No element less than 2 in left of 2, G[3] = -1
    index 4: A[3] is nearest element which is less than A[4], G[4] = A[3]
    index 4: A[3] is nearest element which is less than A[5], G[5] = A[3]
    
Input 2:
    A = [3, 2, 1]
Output 2:
    [-1, -1, -1]
Explaination 2:
    index 1: No element less than 3 in left of 3, G[1] = -1
    index 2: No element less than 2 in left of 2, G[2] = -1
    index 3: No element less than 1 in left of 1, G[3] = -1","vector<int> Solution::prevSmaller(vector<int> &A) {
    vector<int> ans;
    ans.resize(A.size());

    stack<int> st;
    
    for (int i = 0; i < A.size(); i++) {
        while (!st.empty() && st.top() >= A[i]) st.pop();
        if (st.empty()) {
            ans[i] = -1;
        } else {
            ans[i] = st.top();
        }
        st.push(A[i]);
    }
    return ans;
}"
Distinct Numbers in Window,https://www.interviewbit.com/problems/distinct-numbers-in-window/,Amazon,Heaps And Maps,medium,"Problem Description

You are given an array of N integers, A1, A2 ,..., AN and an integer B. Return the of count of distinct numbers in all windows of size B.

Formally, return an array of size N-B+1 where i'th element in this array contains number of distinct elements in sequence Ai, Ai+1 ,..., Ai+B-1.

NOTE:  if B > N, return an empty array.



Input Format
First argument is an integer array A

Second argument is an integer B.



Output Format
Return an integer array.



Example Input
Input 1:

 A = [1, 2, 1, 3, 4, 3]
 B = 3
Input 2:

 A = [1, 1, 2, 2]
 B = 1


Example Output
Output 1:

 [2, 3, 3, 2]
Output 2:

 [1, 1, 1, 1]


Example Explanation
Explanation 1:

 A=[1, 2, 1, 3, 4, 3] and B = 3
 All windows of size B are
 [1, 2, 1]
 [2, 1, 3]
 [1, 3, 4]
 [3, 4, 3]
 So, we return an array [2, 3, 3, 2].
Explanation 2:

 Window size is 1, so the output array is [1, 1, 1, 1].","vector<int> Solution::dNums(vector<int> &A, int B) {
      assert(B<=A.size());
    int n=A.size();
    vector<int> ret;
    unordered_map <int, int> m;
    for(int i=0; i<n; i++){
        //increase key
        m[A[i]]++;
        if(i-B+1>=0){

            //decrease key
            ret.push_back(m.size());
            m[A[i-B+1]]--;

            //remove if count becomes 0
            if(m[A[i-B+1]]==0)m.erase(A[i-B+1]);
        }
    }
    return ret;

}"
Invert the Binary Tree,https://www.interviewbit.com/problems/invert-the-binary-tree/,Google,Tree Data Structure,easy,"Problem Description

Given a binary tree A, invert the binary tree and return it. 

 Inverting refers to making left child as the right child and vice versa.



Problem Constraints
1 <= size of tree <= 100000



Input Format
First and only argument is the head of the tree A.



Output Format
Return the head of the inverted tree.



Example Input
Input 1:

 
     1
   /   \
  2     3
Input 2:

 
     1
   /   \
  2     3
 / \   / \
4   5 6   7


Example Output
Output 1:

 
     1
   /   \
  3     2
Output 2:

 
     1
   /   \
  3     2
 / \   / \
7   6 5   4


Example Explanation
Explanation 1:

Tree has been inverted.
Explanation 2:

Tree has been inverted.","class Solution {
    public:
        TreeNode* invertTree(TreeNode *root) {
            if (!root) return root;
            root->left = invertTree(root->left);
            root->right = invertTree(root->right);
            TreeNode *temp = root->left;
            root->left = root->right;
            root->right = temp;
            return root;
        }
};"
Kth Smallest Element In Tree,https://www.interviewbit.com/problems/kth-smallest-element-in-tree/,Amazon,Tree Data Structure,medium,"Problem Description
 
 

Given a binary search tree, write a function to find the kth smallest element in the tree.
NOTE: You may assume 1 <= k <= Total number of nodes in BST


Input Format
The first argument is the root node of the binary tree.
The second argument B is an integer equal to the value of k.


Output Format
Return the value of the kth smallest node.


Example Input
  2
 / \
1   3


and k = 2



Example Output
2


Example Explanation
As 2 is the second smallest element in the tree.","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

bool helper( TreeNode* node, int &k, int &result )
{
    if( node == NULL )
        return false;
        
    if( helper( node->left, k, result ) == true )
        return true;
    
    if( --k == 0 )
    {
        result = node->val;
        return true;
    }
    
    return helper( node->right, k, result );
}

int Solution::kthsmallest(TreeNode* root, int k)
{
    int result = 0;
    
    helper( root, k, result );
    
    return result;
}"
2-Sum Binary Tree,https://www.interviewbit.com/problems/2sum-binary-tree/,Amazon,Tree Data Structure,hard,"Problem Description

Given a binary search tree A, where each node contains a positive integer, and an integer B, you have to find whether or not there exist two different nodes X and Y such that X.value + Y.value = B.

Return 1 to denote that two such nodes exist. Return 0, otherwise.



Problem Constraints
1 <= size of tree <= 100000

1 <= B <= 109



Input Format
First argument is the head of the tree A.

Second argument is the integer B.



Output Format
Return 1 if such a pair can be found, 0 otherwise.



Example Input
Input 1:

         10
         / \
        9   20


B = 19

Input 2:

 
          10
         / \
        9   20


B = 40



Example Output
Output 1:

 1
Output 2:

 0


Example Explanation
Explanation 1:

 10 + 9 = 19. Hence 1 is returned.
Explanation 2:

 No such pair exists.","class BST{
    public:
        stack<TreeNode*> mys1,mys2;
        TreeNode * cur1, * cur2;

        BST(TreeNode *root) {
            cur1=cur2=root;
        }
        bool hasNext() {
            if(cur1==NULL and mys1.empty())return false;
            return true;
        }
        bool hasPrev() {
            if(cur2==NULL and mys2.empty())return false;
            return true;
        }
        int next(){
            if(cur1!=NULL){
                mys1.push(cur1);
                cur1=cur1->left;
                next();
            }
            else{
                if(not mys1.empty()){
                    cur1=mys1.top();
                    int ans=cur1->val;
                    mys1.pop();
                    cur1=cur1->right;
                    return ans;
                }
            }
        }
        int prev(){
            if(cur2!=NULL){
                mys2.push(cur2);
                cur2=cur2->right;
                prev();
            }
            else{
                if(not mys2.empty()){
                    cur2=mys2.top();
                    int ans=cur2->val;
                    mys2.pop();
                    cur2=cur2->left;
                    return ans;
                }
            }
        }
};

int Solution::t2Sum(TreeNode* A, int B) {
    BST a(A);
    int x1=a.next();
    int x2=a.prev();
    while(x1<x2){
        if(x1+x2==B)return 1;
        if(x1+x2<B)
            x1=a.next();
        else x2=a.prev();
    }
    return 0;
}"
Rod Cutting,https://www.interviewbit.com/problems/rod-cutting/,Google,Dynamic Programming,medium,"Problem Description
 
 

There is a rod of length N lying on the x-axis with its left end at x = 0 and right end at x = N. Now, there are M weak points on this rod denoted by positive integer values(all less than N) A1, A2, ..., AM. You have to cut the rod at all these weak points. You can perform these cuts in any order. After a cut, the rod gets divided into two smaller sub-rods. The cost of making a cut is the length of the sub-rod in which you are making a cut.

Your aim is to minimize this cost. Return an array denoting the sequence in which you will make cuts. If two different sequences of cuts give the same cost, return the lexicographically smallest.

Notes:
Sequence a1, a2 ,..., an is lexicographically smaller than b1, b2 ,..., bm, if and only if at the first i where ai and bi differ, ai < bi, or if no such i found, then n < m.
N can be up to 109.


Problem Constraints
0 <= A <= 109
1 <= |B| <= 100


Input Format
The first argument is an integer A, representing the value of N.
The second argument is an integer array B, representing the weak points of rod.


Output Format
Return an array denoting the sequence in which you will make cuts.


Example Input
A = 6
B = [1, 2, 5]


Example Output
[2, 1, 5]


Example Explanation
N = 6
A = [1, 2, 5]


If we make cuts in order [1, 2, 5], let us see what total cost would be.
For first cut, the length of rod is 6.
For second cut, the length of sub-rod in which we are making cut is 5(since we already have made a cut at 1).
For third cut, the length of sub-rod in which we are making cut is 4(since we already have made a cut at 2).
So, total cost is 6 + 5 + 4.



Cut order          | Sum of cost
(lexicographically | of each cut
 sorted)           |
________________|____________
[1, 2, 5]          | 6 + 5 + 4 = 15
[1, 5, 2]          | 6 + 5 + 4 = 15
[2, 1, 5]          | 6 + 2 + 4 = 12
[2, 5, 1]          | 6 + 4 + 2 = 12
[5, 1, 2]          | 6 + 5 + 4 = 15
[5, 2, 1]          | 6 + 5 + 2 = 13



So, we return [2, 1, 5].","long long int n;
long long int a[110];
long long int dp[110][110];

long long int rec(long long int l,long long int r,long long int lend,long long int rend){
    if(l>r){
        return 0;
    }
    if(l==r){
        return dp[l][r]=rend-lend;
    }
    if(dp[l][r]!=-1){
        return dp[l][r];
    }
    long long int ans=1e15;
    for(int i=l;i<=r;i++){
        ans=min(ans,rec(l,i-1,lend,a[i])+rec(i+1,r,a[i],rend)+rend-lend);
    }
    dp[l][r]=ans;
    return dp[l][r];
}

vector<int> func(long long int l,long long int r,long long int lend,long long int rend,long long int req){
    if(l>r){
        vector<int>tt;
        return tt;
    }
    if(l==r){
        vector<int>tt;
        tt.push_back(a[l]);
        return tt;
    }
    vector<int>cos;
    for(int i=l;i<=r;i++){
        long long int v1=0;
        if(i!=l){
            v1=dp[l][i-1];
        }
        long long int v2=0;
        if(i!=r){
            v2=dp[i+1][r];
        }
        if(v1+v2==req-(rend-lend)){
            vector<int>t1=func(l,i-1,lend,a[i],v1);
            vector<int>t2=func(i+1,r,a[i],rend,v2);
            cos.push_back(a[i]);
            for(auto x : t1){
                cos.push_back(x);
            }
            for(auto x : t2){
                cos.push_back(x);
            }
            break;
        }
    }
    return cos;
}

vector<int> Solution::rodCut(int A, vector<int> &B) {
    n=B.size();
    sort(B.begin(),B.end());
    for(int i=0;i<n;i++){
        a[i]=B[i];
    }
    memset(dp,-1,sizeof(dp));
    long long int val=rec(1ll*0,1ll*(n-1),1ll*0,1ll*A);
    vector<int>temp;
    temp=func(1ll*0,1ll*(n-1),1ll*0,1ll*A,1ll*val);
    return temp;
}"
Smallest Multiple With 0 and 1,https://www.interviewbit.com/problems/smallest-multiple-with-0-and-1/,Amazon,Graph Data Structure & Algorithms,medium,"Problem Description
 
 

You are given an integer A. You have to find the smallest multiple of A which consists of digits 0 and 1 only. Since this multiple could be large, return it in form of a string.
Note: Returned string should not contain leading zeroes.


Problem Constraints
1 <= A <= 105


Input Format
The first argument is an integer A.


Output Format
Return a string equal to the smallest multiple of A which consists of digits 0 and 1 only


Example Input
Input 1:
55
Input 2:
2


Example Output
Output 1:
110
Output 2:
10


Example Explanation
Explanation 1:
110 is the smallest integer which is divisible by 55 and contains 0 and 1 only
Explanation 2:
10 is the smallest integer which is divisible by 2 and contains 0 and 1 only","string Solution::multiple(int N) {
    if(N==1) return ""1"";
    vector<int> p(N,-1);//parent state
    vector<int> s(N,-1);//step from parent to current
    //BFS
    int steps[2] = {0,1};
    queue<int> q;
    q.push(1);
    while(!q.empty()){
        int curr = q.front();
        q.pop();
        if(curr==0) break;
        for(int step: steps){
            int next = (curr*10+step)%N;
            if(p[next]==-1){
                p[next]=curr;
                s[next]=step;
                q.push(next);
            }
        }
    }
    //build reversed string
    string number;
    for(int it=0; it!=1; it=p[it])
        number.push_back('0'+s[it]);
    number.push_back('1');
    //return the reverse if it
    return string(number.rbegin(), number.rend());
}"
Intersecting Chords in a Circle,https://www.interviewbit.com/problems/intersecting-chords-in-a-circle/,"Directi, Google",Dynamic Programming,medium,"Given a number A, return number of ways you can draw A chords in a circle with 2 x A points such that no 2 chords intersect.

Two ways are different if there exists a chord which is present in one way and not in other.

Return the answer modulo 109 + 7.



Input Format:

The first and the only argument contains the integer A.
Output Format:

Return an integer answering the query as described in the problem statement.
Constraints:

1 <= A <= 1000
Examples:

Input 1:
    A = 1

Output 1:
    1

Explanation 1:
    If points are numbered 1 to 2 in clockwise direction, then different ways to draw chords are:
    {(1-2)} only.
    So, we return 1.

Input 2:
    A = 2

Output 2:
    2

Explanation 2:
    If points are numbered 1 to 4 in clockwise direction, then different ways to draw chords are:
    {(1-2), (3-4)} and {(1-4), (2-3)}.
    So, we return 2.","#define MOD 1000000007ll
typedef long long LL;
LL dp[1009];
LL rec(int n){
    if(n==0)return 1;
    LL &ret=dp[n];
    if(ret!=-1)return ret;
    ret=0;
    for(int i=0; i<n; i++){
        ret += (rec(i)*rec(n-i-1))%MOD;
        if(ret>=MOD)ret-=MOD;
    }
    return ret;
}

int Solution::chordCnt(int A) {
    assert(A>=1 && A<=1000);
    memset(dp,-1,sizeof(dp));
    return (int)rec(A);
}"
Count Permutations of BST,https://www.interviewbit.com/problems/count-permutations-of-bst/,N/A,Dynamic Programming,medium,"You are given two positive integers A and B. For all permutations of [1, 2, …, A], we create a BST. Count how many of these have height B.

Notes:

Values of a permutation are sequentially inserted into the BST by general rules i.e in increasing order of indices.
Height of BST is maximum number of edges between root and a leaf.
Return answer modulo 109 + 7.
Expected time complexity is worst case O(N4).
1 ? N ? 50
For example,

A = 3, B = 1

Two permutations [2, 1, 3] and [2, 3, 1] generate a BST of height 1.
In both cases the BST formed is

    2
   / \
  1   3  


Another example,
A = 3, B = 2
Return 4.

Next question, can you do the problem in O(N3)?","class Solution:
	# @param A : integer
	# @param B : integer
	# @return an integer
	def cntPermBST(self, A, B):"
Find Permutation,https://www.interviewbit.com/problems/find-permutation/,Amazon,Arrays,medium,"Given a positive integer n and a string s consisting only of letters D or I, you have to find any permutation of first n positive integer that satisfy the given input string.

D means the next number is smaller, while I means the next number is greater.

Notes

Length of given string s will always equal to n - 1
Your solution should run in linear time and space.
Example :

Input 1:

n = 3

s = ID

Return: [1, 3, 2]","
vector<int> Solution::findPerm(const string A, int B) {
    
    vector<int> ans;
    int l=1,r=B;
    for(int i=0;i<A.length();i++)
    {
       if(A[i]=='I') {ans.push_back(l);l++;}
       else {ans.push_back(r);r--;} 
    }
    ans.push_back(r);
    
    return ans;
    
}"
Maximum Absolute Difference,https://www.interviewbit.com/problems/maximum-absolute-difference/,Amazon,Arrays,medium,"Problem Description
 
 

You are given an array of N integers, A1, A2 ,..., AN. Return maximum value of f(i, j) for all 1 ? i, j ? N. f(i, j) is defined as |A[i] - A[j]| + |i - j|, where |x| denotes absolute value of x.


Problem Constraints
1 <= |A| <= 105
-109 <= Ai <= 109


Input Format
The first argument is an integer array A.


Output Format
Return an integer equal to the maximum value of f(i, j)


Example Input
A = [1, 3, -1]


Example Output
5


Example Explanation
Given A = [1, 3, -1], 
f(1, 1) = f(2, 2) = f(3, 3) = 0
f(1, 2) = f(2, 1) = |1 - 3| + |1 - 2| = 3
f(1, 3) = f(3, 1) = |1 - (-1)| + |1 - 3| = 4
f(2, 3) = f(3, 2) = |3 - (-1)| + |2 - 3| = 5
The maximum value is 5, which is of f(2, 3)","int Solution::maxArr(vector<int> &A) {
    int ans = 0, n = A.size(); 
    
    int max1 = INT_MIN, max2 = INT_MIN;
    int min1 = INT_MAX, min2 = INT_MAX;
    
    for(int i = 0; i < n; i++){
        max1 = max(max1, A[i] + i);
        max2 = max(max2, A[i] - i);
        min1 = min(min1, A[i] + i);
        min2 = min(min2, A[i] - i);
    }   
    ans = max(ans, max2 - min2);
    ans = max(ans, max1 - min1);
    return ans;
}"
Matrix Median,https://www.interviewbit.com/problems/matrix-median/,Amazon,Binary Search,medium,"Problem Description
 
 

Given a matrix of integers A of size N x M in which each row is sorted.

Find and return the overall median of matrix A.

NOTE: No extra memory is allowed.

NOTE: Rows are numbered from top to bottom and columns are numbered from left to right.



Problem Constraints
1 <= N, M <= 10^5

1 <= N*M <= 10^6

1 <= A[i] <= 10^9

N*M is odd



Input Format
The first and only argument given is the integer matrix A.



Output Format
Return the overall median of matrix A.



Example Input
Input 1: 

A = [   [1, 3, 5],
        [2, 6, 9],
        [3, 6, 9]   ] 
Input 2: 

A = [   [5, 17, 100]    ]


Example Output
Output 1: 

 5 
Output 2: 

 17


Example Explanation
Explanation 1: 

A = [1, 2, 3, 3, 5, 6, 6, 9, 9]
Median is 5. So, we return 5. 
Explanation 2:

Median is 17.","int Solution::findMedian(vector<vector<int> > &A) {
    int l = 0, r = INT_MAX;
    int mid, req = (int)A.size() * (int)A[0].size();
    assert(A.size()*A[0].size()<=1000000);
    assert(req % 2);
    while(r - l > 1){
        mid = l + (r - l) / 2;
        int cnt = 0;
        for(auto &i: A){ 
            //using upper bound in a sorted array to count number of elements smaller than mid
            int p = upper_bound(i.begin(), i.end(), mid) - i.begin();
            cnt += p;
        }
        if(cnt >= (req/2 +1)) r = mid;
        else l = mid;
    }   
    return r;
}


// int Solution::findMedian(vector<vector<int> > &A) {

    
//         vector<int> v;
//         for(int i=0;i<A.size();i++)
//         {
//             for(int j=0;j<A[0].size();j++)
//             {
//                 v.push_back(A[i][j]);
//             }
//         }
        
//         sort(v.begin(), v.end());
//         return v[v.size()/2];
// }"
Largest Coprime Divisor,https://www.interviewbit.com/problems/largest-coprime-divisor/,N/A,Math,medium,"Problem Description
 
 

You are given two positive numbers A and B. You need to find the maximum valued integer X such that:

X divides A i.e. A % X = 0
X and B are co-prime i.e. gcd(X, B) = 1
For example,

A = 30
B = 12
We return
X = 5


Problem Constraints
1<=A,B<=1e9


Input Format
First argument is A.
Second argument is B.


Output Format
Find the maximum valued integer X which satisfies the above properties.","int Solution::cpFact(int A, int B) {
    int ans = 0;
    for( int i = 1; i <= A; i++ ) {
        if(  A%i == 0 && __gcd(i,B) == 1) ans = i;
    }
    return ans;
}"
Maximum Unsorted Subarray,https://www.interviewbit.com/problems/maximum-unsorted-subarray/,"Amazon, Microsoft",Arrays,medium,"Problem Description
 
 

Given an array A of non-negative integers of size N. Find the minimum sub-array Al, Al+1 ,..., Ar such that if we sort(in ascending order) that sub-array, then the whole array should get sorted.
If A is already sorted, output -1.



Problem Constraints
1 <= N <= 1000000

1 <= A[i] <= 1000000



Input Format
First and only argument is an array of non-negative integers of size N.



Output Format
Return an array of length two where the first element denotes the starting index(0-based) and the second element denotes the ending index(0-based) of the sub-array. If the array is already sorted, return an array containing only one element i.e. -1.



Example Input
Input 1:

A = [1, 3, 2, 4, 5]
Input 2:

A = [1, 2, 3, 4, 5]


Example Output
Output 1:

[1, 2]
Output 2:

[-1]


Example Explanation
Explanation 1:

If we sort the sub-array A1, A2, then the whole array A gets sorted.
Explanation 2:

A is already sorted.","vector<int> Solution::subUnsort(vector<int> &A){
	vector<int> ans;
	int n = A.size();
	int i = 0, j = n-1;
	while(i< n - 1 and A[i] <= A[i + 1]){
		i++;
	}
	while(j > 0 and A[j] >= A[j - 1]){
		j--;
	}
	if(i == n - 1){ // if array is already sorted, output -1
		ans.push_back(-1);
		return ans;
	}
	int mn = A[i + 1], mx = A[i + 1];
	for(int k = i; k <= j; k++){
		mx = max(mx, A[k]);
		mn = min(mn, A[k]);
	}
	int l = 0, r = n - 1;
	while(A[l] <= mn and l <= i){
	   	l++;
	}
	while(A[r] >= mx and r >= j){
		r--;
	}
	ans.push_back(l);
	ans.push_back(r);
	return ans;
}"
Counting Triangles,https://www.interviewbit.com/problems/counting-triangles/,N/A,Two Pointers,medium,"Problem Description
 
 

You are given an array of N non-negative integers, A0, A1,..., AN-1.
Considering each array element Ai as the edge length of some line segment, count the number of triangles that you can form using these array values.

Notes:
You can use any value only once while forming each triangle. The order of choosing the edge lengths doesn't matter. Any triangle formed should have a positive area.
Return answer modulo 109 + 7.


Problem Constraints
1 <= |A| <= 103
0 <= Ai <= 106


Input Format
The first argument is an integer array A.


Output Format
Return an integer equal to the count of the number of triangles that you can form.


Example Input
A = [1, 1, 1, 2, 2]


Example Output
4","int Solution::nTriang(vector<int> &A) {
        int n=A.size();
        if(n<3)return 0;
        // now n>=3
        sort(A.begin(),A.end());
        int ans=0;

        for(int en=(n-1);en>=2;--en){
            // for this c, i need to find pairs(a,b) whose sum greater than c
            for(int be=0,mid=(en-1);be<mid;){
                if(A.at(be)+A.at(mid) > A.at(en)){
                    ans+=(mid-be)%(1000000007); //cout<<ans<<endl;
                    --mid; 
                }
                else{
                    ++be;
                }
            }
        }
        return (ans%(1000000007));
}"
Queen Attack,https://www.interviewbit.com/problems/queen-attack/,N/A,Dynamic Programming,medium,"Problem Description
 
 

On an N * M chessboard, where rows are numbered from 1 to N and columns from 1 to M, there are queens at some cells. Return an N * M array A, where A[i][j] is the number of queens that can attack cell (i, j). While calculating the answer for cell (i, j), assume there is no queen at that cell.

Notes:
Queen is able to move any number of squares vertically, horizontally, or diagonally on a chessboard. A queen cannot jump over another queen to attack a position.
You are given an array of N strings, each of size M. Each character is either a 1 or 0 denoting if there is a queen at that position or not, respectively.
Expected time complexity in worst-case O(N*M).


Problem Constraints
1 <= N <= 500
1 <= M <= 500


Input Format
The first argument is an array of strings.


Output Format
Return an N * M array of integers.


Example Input
A = [""010"",
     ""100"",
     ""001""]


Example Output
[[3, 1, 2]
 [1, 3, 3]
 [2, 3, 0]]


Example Explanation
The chessboard is,
[0 1 0]
[1 0 0]
[0 0 1]


where a 1 denotes a queen at that position.



Cell (1, 1) is attacked by queens at (2, 1), (1,2) and (3,3).
Cell (1, 2) is attacked by queen at (2, 1). Note that while calculating this, we assume that there is no queen at (1, 2).
Cell (1, 3) is attacked by queens at (3, 3) and (1, 2).
and so on...



Finally, we return matrix
[3, 1, 2]
[1, 3, 3]
[2, 3, 0]

","//dp array
int dp[8][1009][1009];
//checks if cell (i, j) is valid or not
bool valid(int i, int j, int n, int m){
    if(i < 0 or i >= n or j < 0 or j >= m)return false;
    return true;
}

//direction vectors
int dir1[8] = {-1, -1, 0, 1, 1, 1, 0, -1};
int dir2[8] = {0, 1, 1, 1, 0, -1, -1, -1};

//returns dp(i, j, k) as 02222 in hint
int rec(int i, int j, int k, vector<string> & A, int n, int m){

    //memoisation
    int &ret = dp[k][i][j];
    if(ret != -1)return ret;
    
    ret=0;
    
    //new positions
    int ni = i + dir1[k];
    int nj = j + dir2[k];
    
    //if valid
    if(valid(ni, nj, n, m)){
        if(A[ni][nj] == '1') ret++;
        else ret += rec(ni, nj, k, A, n, m);
    }
    
    return ret;
}

vector<vector<int> > Solution::queenAttack(vector<string> &A) {
    //init dp array
    int n = A.size(), m = A[0].size();
    assert(n<=500 && m<=500);
    memset(dp,-1,sizeof(dp));

    vector< vector<int> > ret(n, vector<int>(m, 0));

    //calculate dp for all positions
    for(int k = 0; k < 8; k++)
        for(int i = 0; i < n; i++)
            for(int j = 0; j < m; j++){
                ret[i][j] += rec(i, j, k, A, n, m);
            }
    return ret;
}"
Magician and Chocolates,https://www.interviewbit.com/problems/magician-and-chocolates/,N/A,Heaps And Maps,medium,"Problem Description
 
 

Given N bags, each bag contains Bi chocolates. There is a kid and a magician. In one unit of time, kid chooses a random bag i, eats Bi chocolates, then the magician fills the ith bag with floor(Bi/2) chocolates.

Find the maximum number of chocolates that kid can eat in A units of time.

NOTE: 

floor() function returns the largest integer less than or equal to a given number.
Return your answer modulo 109+7


Problem Constraints
1 <= A <= 105
1 <= |B| <= 105
1 <= Bi <= INT_MAX


Input Format
First argument is an integer A.

Second argument is an integer array B of size N.



Output Format
Return an integer denoting the maximum number of chocolates that kid can eat in A units of time.



Example Input
Input 1:

 A = 3
 B = [6, 5]
Input 2:

 A = 5
 b = [2, 4, 6, 8, 10]


Example Output
Output 1:

 14
Output 2:

 33


Example Explanation
Explanation 1:

 At t = 1 kid eats 6 chocolates from bag 0, and the bag gets filled by 3 chocolates. 
 At t = 2 kid eats 5 chocolates from bag 1, and the bag gets filled by 2 chocolates. 
 At t = 3 kid eats 3 chocolates from bag 0, and the bag gets filled by 1 chocolate. 
 so, total number of chocolates eaten are 6 + 5 + 3 = 14","long long int mod = 1000000007;
int Solution::nchoc(int A, vector<int> &B) {
	int N = B.size();
	int K = A;
	long long int ans = 0;
	priority_queue<int> heap(B.begin(),B.end());
	while(K--){
		long long int max_elem = heap.top();
		ans += max_elem;
		ans = ans % mod;
		heap.pop();
		heap.push((int)(max_elem/2));
	}   
	return ans;
}"
Minimum Characters required to make a String Palindromic,https://www.interviewbit.com/problems/minimum-characters-required-to-make-a-string-palindromic/,"Amazon, Microsoft",Strings,medium,"Problem Description
 
 

Given a string A. The only operation allowed is to insert characters at the beginning of the string.
Find how many minimum characters are needed to be inserted to make the string a palindrome string.


Problem Constraints
1 <= |A| <= 106


Input Format
The only argument given is string A.


Output Format
Return the minimum characters that are needed to be inserted to make the string a palindrome string.


Example Input
Input 1:
A = ""ABC""
Input 2:
A = ""AACECAAAA""


Example Output
Output 1:
2
Output 2:
2


Example Explanation
Explanation 1:
Insert 'B' at beginning, string becomes: ""BABC"".
Insert 'C' at beginning, string becomes: ""CBABC"".
Explanation 2:
Insert 'A' at beginning, string becomes: ""AAACECAAAA"".
Insert 'A' at beginning, string becomes: ""AAAACECAAAA"".","vector<int> computeLPSArray(string str) {
    int M = str.length();
    vector<int> lps(M);
    int len = 0;
    lps[0] = 0;
    int i = 1;
    while (i < M) {
        if (str[i] == str[len]) {
            len++;
            lps[i] = len;
            i++;
        }
        else {
            if (len != 0) {
                len = lps[len-1];

            }
            else {
                lps[i] = 0;
                i++;
            }
        }
    }
    return lps;
}

int Solution::solve(string str) {
    assert(str.size() >= 1 && str.size() <= 1e6); 
    string revStr = str;
    reverse(revStr.begin(), revStr.end());
    string concat = str + ""$"" + revStr;
    vector<int> lps = computeLPSArray(concat);
    return (str.length() - lps.back());
}"
Longest Arithmetic Progression,https://www.interviewbit.com/problems/longest-arithmetic-progression/,Microsoft,Dynamic Programming,medium,"Problem Description
 
 

Find the longest Arithmetic Progression in an integer array A of size N, and return its length.

More formally, find longest sequence of indices, 0 < i1 < i2 < … < ik < ArraySize(0-indexed) such that sequence A[i1], A[i2], …, A[ik] is an Arithmetic Progression.

Arithmetic Progression is a sequence in which all the differences between consecutive pairs are the same, i.e sequence B[0], B[1], B[2], …, B[m - 1] of length m is an Arithmetic Progression if and only if B[1] - B[0] == B[2] - B[1] == B[3] - B[2] == … == B[m - 1] - B[m - 2]

Note: The common difference can be positive, negative, or 0.


Problem Constraints
1 <= N <= 1000
1 <= A[i] <= 1e9


Input Format
The first and only argument of input contains an integer array, A.


Output Format
Return an integer, representing the length of the longest possible arithmetic progression.


Example Input
Input 1:
 A = [3, 6, 9, 12]
Input 2:
 A = [9, 4, 7, 2, 10]


Example Output
Output 1:
4
Output 2:
3


Example Explanation
Explanation 1:
[3, 6, 9, 12] form an arithmetic progression.
Explanation 1:
[4, 7, 10] form an arithmetic progression.","//For searching some numbers in the prefix lets use some data structure.
// Lets store associative array [number, position].

int Solution::solve(const vector<int> &A) {

	int n = A.size();

	if (n < 3) return n;

	vector<vector<int> > dp(n, vector<int>(n, -1));

	map<int, int> pos;

	for (int i = 0; i < n; i++) {

		for (int j = i + 1; j < n; j++) {

			dp[i][j] = 2;

			int dif = A[j] - A[i];

			int need = 2 * A[i] - A[j];

			if (pos.count(need) == 0) continue;

			dp[i][j] = max(dp[i][j], dp[pos[need]][i] + 1);

		}
		pos[A[i]] = i;

	}

	int ans = 2;

	for (int i = 0; i < n; i++) {

		for (int j = i + 1; j < n; j++) {

			ans = max(ans, dp[i][j]);

		}

	}

	return ans;
}


//it’s O(n ^ 2 * log(n)) solution. 
//Also we can use unordered map(hash map) here,
// but its running time is undetermined
//(it's **O(1)** in average, but constant might be too big)."
Ways to form Max Heap,https://www.interviewbit.com/problems/ways-to-form-max-heap/,Directi,Heaps And Maps,medium,"Problem Description
 
 

Max Heap is a special kind of complete binary tree in which for every node the value present in that node is greater than the value present in it’s children nodes.

Find the number of distinct Max Heap can be made from A distinct integers.

In short, you have to ensure the following properties for the max heap :

Heap has to be a complete binary tree ( A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.)
Every node is greater than all its children.
NOTE:  If you want to know more about Heaps, please visit this link. Return your answer modulo 109 + 7.



Problem Constraints
1 <= A <= 100



Input Format
First and only argument is an integer A.



Output Format
Return an integer denoting the number of distinct Max Heap.



Example Input
Input 1:

 A = 4
Input 2:

 A = 10


Example Output
Output 1:

 3
Output 2:

 3360


Example Explanation
Explanation 1:

 Let us take 1, 2, 3, 4 as our 4 distinct integers
 Following are the 3 possible max heaps from these 4 numbers :
      4           4                     4
    /  \         / \                   / \ 
   3    2   ,   2   3      and        3   1
  /            /                     /

 1            1                     2
Explanation 2:

 Number of distinct heaps possible with 10 distinct integers = 3360.","int Solution::solve(int A) {
}"
Sum of pairwise Hamming Distance,https://www.interviewbit.com/problems/sum-of-pairwise-hamming-distance/,Google,Math,medium,"Problem Description

Hamming distance between two non-negative integers is defined as the number of positions at which the corresponding bits are different.

Given an array A of N non-negative integers, find the sum of hamming distances of all pairs of integers in the array. Return the answer modulo 1000000007.



Problem Constraints
1 <= |A| <= 200000

1 <= A[i] <= 109



Input Format
First and only argument is array A.



Output Format
Return one integer, the answer to the problem.



Example Input
Input 1:

 A = [1]
Input 2:

 A = [2, 4, 6]


Example Output
Output 1:

 0
Output 2:

 8


Example Explanation
Explanation 1:

 No pairs are formed.
Explanation 2:

 We return, f(2, 2) + f(2, 4) + f(2, 6) + f(4, 2) + f(4, 4) + f(4, 6) + f(6, 2) + f(6, 4) + f(6, 6) = 8","int Solution::hammingDistance(const vector<int> &A) {
    int inputSize = A.size();
    int mod = 1000000007;
    int sum = 0;
    for (int bitPosition = 0; bitPosition < 31; bitPosition++) {
        int cntBitOne = 0, cntBitZero = 0;
        for(int i = 0; i < inputSize; i++) {
            if (A[i] & (1 << bitPosition)) cntBitOne++;
            else cntBitZero++;
        }
        sum = sum + ((2LL * cntBitOne * cntBitZero) % mod);
        if (sum >= mod) sum = sum - mod;
    }
    return sum;
}"
Sub Matrices with sum Zero,https://www.interviewbit.com/problems/sub-matrices-with-sum-zero/,Google,Dynamic Programming,medium,"Given a 2D matrix, find the number non-empty sub matrices, such that the sum of the elements inside the sub matrix is equal to 0. (note:  elements might be negative).

Example:

Input

-8 5  7
3  7 -8
5 -8  9
Output

2

Explanation

-8 5 7

3 7 -8

5 -8 9

-8 5 7

3 7 -8

5 -8 9","int Solution::solve(vector<vector<int> > &A) {
	int r = A.size();
	if(!r) return 0;
	int c = A[0].size();
	if(!c) return 0;

	vector<vector<int> > pre;

	pre.resize(r, vector<int>(c, 0));

	for(int i = 0; i < r; ++i) {
		for(int j = 0; j < c; ++j) {
			pre[i][j] = A[i][j];
			if(i) pre[i][j] += pre[i - 1][j];
			if(j) pre[i][j] += pre[i][j - 1];
			if(i && j) pre[i][j] -= pre[i - 1][j - 1];
		}
	}
	int ans = 0;
	for(int r1 = 0; r1 < r; ++r1) {
		for(int r2 = r1; r2 < r; ++r2) {
			unordered_map<int, int> count;
			count[0] = 1;
			for(int j = 0; j < c; ++j) {
				int val = pre[r2][j];
				if(r1) val -= pre[r1 - 1][j];
				ans += count[val];
				count[val]++;
			}
		}
	}

	return ans;
}"
N digit numbers with digit sum S,https://www.interviewbit.com/problems/n-digit-numbers-with-digit-sum-s-/,N/A,Dynamic Programming,medium,"Find out the number of N digit numbers, whose digits on being added equals to a given number S. Note that a valid number starts from digits 1-9 except the number 0 itself. i.e. leading zeroes are not allowed.

Since the answer can be large, output answer modulo 1000000007

N = 2, S = 4 
 Valid numbers are {22, 31, 13, 40} 
 Hence output 4.","int rec(vector<vector<int > > &dp, int id, int sum) {
    if(sum < 0) return 0;
    if(id == 0 && sum == 0) return 1;
    if(id == 0) return 0;

    if(dp[id][sum] != -1) return dp[id][sum];

    int ans = 0;
    for(int i = 0; i < 10; i++) {
        ans += rec(dp,id - 1, sum - i);
        ans %= 1000000007;
    }
    return dp[id][sum] = ans;
}

int Solution::solve(int A, int B) {
        int ans = 0;
        vector<vector<int> > dp;
        dp.resize(A+1);
        for(int i = 0; i <= A; i++) {
            dp[i].resize(B+1);
            for(int j=0;j<=B;j++)
                  dp[i][j] = -1;
       }
        for(int i = 1; i < 10; i++) {
            ans += rec(dp, A-1, B-i);
            ans %= 1000000007;
        }
    return ans;
}"
Largest Distance between nodes of a Tree,https://www.interviewbit.com/problems/largest-distance-between-nodes-of-a-tree/,"Facebbok, Google",Graph Data Structure & Algorithms,medium,"Problem Description

Given an arbitrary unweighted rooted tree which consists of N nodes.

The goal of the problem is to find largest distance between two nodes in a tree.

Distance between two nodes is a number of edges on a path between the nodes (there will be a unique path between any pair of nodes since it is a tree).

The nodes will be numbered 0 through N - 1.

The tree is given as an array A, there is an edge between nodes A[i] and i (0 <= i < N). Exactly one of the i's will have A[i] equal to -1, it will be root node.



Problem Constraints
1 <= N <= 40000



Input Format
First and only argument is an integer array A of size N.



Output Format
Return a single integer denoting the largest distance between two nodes in a tree.



Example Input
Input 1:

 A = [-1, 0, 0, 0, 3]


Example Output
Output 1:

 3


Example Explanation
Explanation 1:

 node 0 is the root and the whole tree looks like this: 
          0
       /  |  \
      1   2   3
               \
                4

 One of the longest path is 1 -> 0 -> 3 -> 4 and its length is 3, thus the answer is 3.","const int maxn=40009;
vector<int>adj[maxn];
pair<int,int> bfs(int s,int n)
{
    int dist[n];
    for(int i=0;i<n;i++)
        dist[i]=-1;
    dist[s]=0;
    int maxDist=0;
    int maxDistNode=s;
    queue<int>q;
    q.push(s);
    while(q.empty()==false)
    {
        int temp=q.front();
        q.pop();
        for(int v:adj[temp])
        {
            if(dist[v]==-1)
            {
                dist[v]=dist[temp]+1;
                q.push(v);
                if(dist[v]>maxDist)
                {
                    maxDist=dist[v];
                    maxDistNode=v;
                }
            }
        }
    }
    return {maxDistNode,maxDist};
}
int Solution::solve(vector<int> &A) {
    int root;
    int n=A.size();
    assert(n>=1 && n<=40000);
    int flag=0;
    for(int a:A)
    {
        if(a==-1)flag++;
        else assert(a>=0 && a<n);
    }
    assert(flag==1);
    for(int i=0;i<n;i++)
        adj[i].clear();
    for(int i=0;i<A.size();i++)
    {
        if(A[i]==-1)
        {
            root=i;
            continue;
        }
        else
        {
            adj[i].push_back(A[i]);
            adj[A[i]].push_back(i);
        }
    }
    pair<int,int> a = bfs(root,n);
    pair<int,int> b = bfs(a.first,n);
    return b.second;
}"
Length of Longest Subsequence,https://www.interviewbit.com/problems/length-of-longest-subsequence/,"Microsoft, Directi, Facebook",Dynamic Programming,medium,"Problem Description
 
 

Given a 1D integer array A of length N, find the length of the longest subsequence which is first increasing (strictly) and then decreasing (strictly).



Problem Constraints
0 <= N <= 3000

 -107 <= A[i] <= 107



Input Format
The first and the only argument contains an integer array A.



Output Format
Return an integer representing the answer as described in the problem statement.



Example Input
Input 1:

 A = [1, 2, 1]
Input 2:

 A = [1, 11, 2, 10, 4, 5, 2, 1]


Example Output
Output 1:

 3
Output 2:

 6


Example Explanation
Explanation 1:

 [1, 2, 1] is the longest subsequence.
Explanation 2:

 [1 2 10 4 2 1] is the longest subsequence.","int Solution::longestSubsequenceLength(const vector<int> &A) {
	int n = A.size();
	assert(n>=0 && n<=3000);
	for(int a:A)
	    assert(a>=-10000000 && a<=10000000);
	int inc[n];
	int dec[n];
	int ct = 0;

	inc[0] = 1;
	for(int i=1; i<n; i++)
	{
		inc[i] = 1;
		for(int j=i-1; j>=0; j--)
		{
			if(A[i] > A[j] && inc[i] < inc[j] + 1)
				inc[i] = inc[j] + 1;
		}
	}

	dec[n-1] = 1;
	for(int i=n-2; i>=0; i--)
	{
		dec[i] = 1;
		for(int j=i+1; j<n; j++)
		{
			if(A[i] > A[j] && dec[i] < dec[j] + 1)
				dec[i] = dec[j] + 1;
		}
	}

	int mx = 0;
	for(int i=0; i<n; i++)
		mx = max(mx, inc[i] + dec[i] - 1);

	return mx;
}"
Shortest common superstring,https://www.interviewbit.com/problems/shortest-common-superstring/,Google,Dynamic Programming,medium,"Problem Description
 
 

Given a set of strings, A of length N.

Return the length of the smallest string which has all the strings in the set as substrings.


Problem Constraints
1 <= N <= 18
1 <= A[i] <= 100


Input Format
The first and the only argument has an array of strings, A.


Output Format
Return an integer representing the minimum possible length of the resulting string.


Example Input
Input 1:
A = [""aaaa"", ""aa""]
Input 2:
    

A = [""abcd"", ""cdef"", ""fgh"", ""de""]


Example Output
Output 1:
4
Output 2:
    

8


Example Explanation
Explanation 1:
Shortest string: ""aaaa""
Explanation 2:

Shortest string: ""abcdefgh""","#define INF 1<<20
#define N 18

//Set the global variables
int targetMask;
int nonOverlapLen[N+2][N+2];
int dp[N][(1<<N) + 10];

// This can be done faster using KMP algorithm
//and some preprocessing
int combineString(vector<string> &words, int a, int b){
	/*
	Let's say s1 = words[a] and s1 = words[b].
	
	If we append string s2 to the solution, then as string s1 is already
	added, we would need to add only the characters of string words[b] that are
	not overlapping with the solution.
	lenToADD = len(s2)-len(suffix of s1 which is also a prefix of s2);
	
	e.g.: s1 = ""lara"", s2 = ""raghav""
	      Now in the previous step, we added s1 to solution and let's say our solution
	      at the time looks like ""brilara"" [made from strings ""brila"" and ""lara""],
	      if we add ""raghav"" to the solution, the only characters to be added are ""ghav""
	      and new solution = ""brilaraghav""
	*/
	
	//Only 1 string in the mask 
	if(a == -1){
		return words[b].size();
	}
  	
  	//Check if already calculated the ans
	if(nonOverlapLen[a][b] != -1){
		return nonOverlapLen[a][b];
	}
  	
  	//Calculate the answer if not already calculated
	for(int i=0; i<words[a].size(); ++i){
		bool suffix = true;
		for(int j=0; j<words[b].size()&& i+j<words[a].size() && suffix; ++j){
			if(words[a][i+j] != words[b][j]) suffix = false;
		}
		
		if(suffix){
			int overlap = words[a].size()-i;
			nonOverlapLen[a][b] = words[b].size() - overlap;
			return nonOverlapLen[a][b];
		}
	}
	
	nonOverlapLen[a][b] = words[b].size();
	return nonOverlapLen[a][b];
}

//Main function to find the optimal solution
int findOptimal(vector<string> &words, int last, int mask){
	//mask --> Set of strings that are considered for the solution.
	//last --> String that we added into the mask the last time
	//dp[i][mask] --> optimal answer for set of strings corresponding to mask(1's in mask) if the
	// last added string in mask is i-th string
	
	if(mask == targetMask){
		//We considered all strings into the solution
		dp[last+1][mask] = 0;
		return dp[last+1][mask];
	}
	
	//Check if we solved this sub problem before
 	if(dp[last + 1][mask] != -1){
 		return dp[last+1][mask];
 	}
	
	// Calculate the answer if not already calculated
	int ans = INF;
	
	for(int i=0; i<words.size(); ++i){
		//Check if i-th word is already considered or not
		if(!((mask>>i)&1)){
			ans = min(ans, findOptimal(words, i, mask|(1<<i)) + combineString(words, last, i));
		}
	}
    
    //Memoization step
    dp[last + 1][mask] = ans;
    
    return ans;
}

int Solution::solve(vector<string>& A){
	int n = A.size();
	
	// Check the strings which are completely overlapping with some other string
	for(int i=0; i<n; i++){
		for(int j=0; j<n; j++){
			if(i!=j && A[i].find(A[j]) != string::npos) A[j] = """";
		}
	}
	
	//Make a new vector of only the strings which are not completely overlapping
	//with some other string

 	vector<string> newA;
 	for(int i=0; i<n; i++){
 		if(A[i] != """") newA.push_back(A[i]);
 	}
  
  	//initialize the required arrays
	memset(nonOverlapLen, -1, sizeof(nonOverlapLen));
	memset(dp, -1, sizeof(dp));
	  
	//Set the mask initially to all 0's
    int mask = 0;
	
	//Set the target mask
    targetMask = (1<<newA.size())-1;
    
    //Find the length of optimal solution
    int ans = findOptimal(newA, -1, mask);
    
    return ans;
}"
Noble Integer,https://www.interviewbit.com/problems/noble-integer/,N/A,Arrays,easy,"Problem Description
 
 

Given an integer array A, find if an integer p exists in the array such that the number of integers greater than p in the array equals to p.



Problem Constraints
1 <= |A| <= 106
-109 <= Ai <= 109


Input Format
First and only argument is an integer array A.



Output Format
Return 1 if any such integer p is found else return -1.



Example Input
Input 1:

 A = [3, 2, 1, 3]
Input 2:

 A = [1, 1, 3, 3]


Example Output
Output 1:

 1
Output 2:

 -1


Example Explanation
Explanation 1:

 For integer 2, there are 2 greater elements in the array. So, return 1.
Explanation 2:

 There is no such integer exists.","int Solution::solve(vector<int> &A) {
	sort(A.begin(), A.end()) ;
	int size = A.size();
	for(int i=0;i<size;i++){
		while(i+1<size && A[i]==A[i+1])
			i++;
		if(A[i]==size-1-i)
			return 1;
	}
	return -1;
}"
Flip Array,https://www.interviewbit.com/problems/flip-array/,N/A,Dynamic Programming,medium,"Problem Description
 
 

Given an array A of positive elements, you have to flip the sign of some of its elements such that the resultant sum of the elements of array should be minimum non-negative(as close to zero as possible).

Return the minimum number of elements whose sign needs to be flipped such that the resultant sum is minimum non-negative.



Problem Constraints
1 <= length of(A) <= 100

Sum of all the elements will not exceed 10,000.



Input Format
First and only argument is an integer array A.



Output Format
Return an integer denoting the minimum number of elements whose sign needs to be flipped.



Example Input
Input 1:

 A = [15, 10, 6]
Input 2:

 A = [14, 10, 4]


Example Output
Output 1:

 1
Output 2:

 1


Example Explanation
Explanation 1:

 Here, we will flip the sign of 15 and the resultant sum will be 1.
Explanation 2:

 Here, we will flip the sign of 14 and the resultant sum will be 0.
 Note that flipping the sign of 10 and 4 also gives the resultant sum 0 but flippings there sign are not minimum.","// dp[i][j] = optimal solution for filling a knapsack of capacity j 
//using elements A[1,2,....,i]
//Optimal solution --> knapsack should be filled upto the capacity using least number of elements
struct node{
	int items;
	int weight;
}dp[105][10005];

int Solution::solve(const vector<int>& A){
	int n = A.size();
	int sum = 0;
	
	for(int i=0; i<n; i++) sum+=A[i];
	
	//knapsack algorithm for capacity sum/2
	int temp = sum/2;
	
	for(int i=0; i<=n; i++){
		for(int j=0; j<=temp; j++){
			if(i==0 || j==0) dp[i][j] = {0, 0};
			else{
				int prev_items = dp[i-1][j].items;
				int prev_weight = dp[i-1][j].weight;
				
				if(j-A[i-1] >= 0){
					int curr_weight = dp[i-1][j-A[i-1]].weight + A[i-1];
					int curr_items = dp[i-1][j-A[i-1]].items + 1;
					
					if((curr_weight>prev_weight) || ((curr_weight==prev_weight) && (curr_items<prev_items))){
						dp[i][j] = {curr_items, curr_weight};
					}
					else{
						dp[i][j] = dp[i-1][j];
					}
				} 
				else{
					dp[i][j] = dp[i-1][j];
				}
			}
		}
	}
	

	return dp[n][temp].items;
}"
Triplets with Sum between given range,https://www.interviewbit.com/problems/triplets-with-sum-between-given-range/,N/A,Arrays,medium,"Problem Description
 
 

Given an array of real numbers greater than zero in form of strings. Find if there exists a triplet (a,b,c) such that 1 < a+b+c < 2. Return 1 for true or 0 for false.
O(n) solution is expected.
Note: You can assume the numbers in strings don't overflow the primitive data type and there are no leading zeroes in numbers. Extra memory usage is allowed.


Problem Constraints
1 <= |A| <= 106


Input Format
The first argument is an array of strings A.


Output Format
Return an integer, 1 for true or 0 for false.


Example Input
A = [""0.6"", ""0.7"", ""0.8"", ""1.2"", ""0.4""]


Example Output
1


Example Explanation
Given [0.6, 0.7, 0.8, 1.2, 0.4],
You should return 1
as
0.6+0.7+0.4=1.7
1<1.7<2

Hence, the output is 1.","double min_element(vector<double> A) { // return minimum element
    double min = A[0];
    for (int i = 0; i < A.size(); i++) {
        if (A[i] < min) {
            min = A[i];
        }
    }
    return min;
}
int Solution::solve(vector<string> &a) {
    vector<double> A, B, C;

    for (int i = 0; i < a.size(); i++) {
        char b[20];
        for (int j = 0; j < a[i].length(); j++) {
            b[j] = a[i][j];
        }
        if (0.0 < atof(b) &&
            atof(b) < ((double)2.0 / (double)3.0)) // atof converts string to double
        {
            A.push_back(atof(b));

        } else if ((double)2.0 / (double)3.0 <= atof(b) && atof(b) <= 1.0) {
            B.push_back(atof(b));

        } else if (1.0 < atof(b) && atof(b) < 2.0) {
            C.push_back(atof(b));
        }
    }

    // 1
    int res = 0;

    if (A.size() >= 3) {
        priority_queue<double> q(
            A.begin(),
            A.end()); // priority queue used to get max 3 elements in O(logn) time
        double m = 0;
        for (int i = 0; i <= 2; i++) {
            m += q.top();
            q.pop();
        }

        if (m > 1.0) {
            res = 1;
            return res;
        }
    }
    // 2
    if (A.size() >= 2 && B.size() >= 1) {
        priority_queue<double> q1(
            A.begin(),
            A.end()); // priority queue used to get max 2 elements in O(logn) time

        double m1 = 0;
        for (int i = 0; i <= 1; i++) {
            m1 += q1.top();
            q1.pop();
        }

        for (int i = 0; i < B.size(); i++) {
            if (1 - m1 < B[i] && B[i] < 2 - m1) {
                res = 1;
                return res;
            }
        }
    }

    // 3
    if (A.size() >= 2 && C.size() >= 1) {
        priority_queue<double, std::vector<double>, std::greater<double>> q2(
            A.begin(),
            A.end()); // priority queue used to get min 2 elements in O(logn) time
        double m2 = 0;
        for (int i = 0; i <= 1; i++) {
            m2 += q2.top();
            q2.pop();
        }

        double min = min_element(C);

        if (m2 + min < 2.0) {
            res = 1;
            return res;
        }
    }

    // 4
    if (B.size() >= 2 && A.size() >= 1) {
        priority_queue<double, std::vector<double>, std::greater<double>> q3(
            B.begin(),
            B.end()); // priority queue used to get min 2 elements in O(logn) time

        double m3 = 0;
        for (int i = 0; i <= 1; i++) {
            m3 += q3.top();
            q3.pop();
        }

        for (int i = 0; i < A.size(); i++) {
            if (A[i] < 2 - m3) {
                res = 1;
                return res;
            }
        }
    }

    // 5
    if (A.size() >= 1 && B.size() >= 1 && C.size() >= 1) {
        int res3 = 0;
        double min1 = min_element(A);
        double min2 = min_element(B);
        double min3 = min_element(C);
        if (min1 + min2 + min3 < 2 && min1 + min2 + min3 > 1) {
            res = 1;
            return res;
        }
    }

    return res;
    // Time complexity =O(logn)+O(n)
    // hence,Time complexity=O(n)
}"
Smallest sequence with given Primes,https://www.interviewbit.com/problems/smallest-sequence-with-given-primes/,"Microsoft, Directi",Dynamic Programming,medium,"Problem Description
 
 

Given three prime numbers A, B and C and an integer D.

You need to find the first(smallest) D integers which only have A, B, C or a combination of them as their prime factors.



Input Format
First argument is an integer A.

Second argument is an integer B.

Third argument is an integer C.

Fourth argument is an integer D.



Output Format
Return an array of size D denoting the first smallest D integers which only have A, B, C or a combination of them as their prime factors.

NOTE: You need to return the array sorted in ascending order.



Example Input
Input 1:

 A = 2
 B = 3
 C = 5
 D = 5


Example Output
Output 1:

 [2, 3, 4, 5, 6]


Example Explanation
Explanation 1:

 4 = A * A i.e ( 2 * 2 ) 
 6 = A * B i.e ( 2 * 3 )","vector<int> Solution::solve(int p1, int p2, int p3, int k) {
               vector<int>ans;
		int c1=0,c2=0,c3=0;
		int np1=p1,np2=p2,np3=p3;
		int temp[k+1];
		for(int i=1;i<=k;i++)
		{
			int min=std::min(std::min(np1,np2),np3);
			ans.push_back(min);
			temp[i]=min;
			if(min==np1) {
				c1++;
				np1=p1*temp[c1];
			}
			 if(min==np2) {
				c2++;
				np2=p2*temp[c2];
			}
			if(min==np3)
			{
				c3++;
				np3=p3*temp[c3];
			}
		}
		return ans;
}"
Commutable Islands,https://www.interviewbit.com/problems/commutable-islands/,Amazon,Graph Data Structure & Algorithms,medium,"There are A islands and there are M bridges connecting them. Each bridge has some cost attached to it.

We need to find bridges with minimal cost such that all islands are connected.

It is guaranteed that input data will contain at least one possible scenario in which all islands are connected with each other.

Input Format:

The first argument contains an integer, A, representing the number of islands.
The second argument contains an 2-d integer matrix, B, of size M x 3:
    => Island B[i][0] and B[i][1] are connected using a bridge of cost B[i][2].
Output Format:

Return an integer representing the minimal cost required.
Constraints:

1 <= A, M <= 6e4
1 <= B[i][0], B[i][1] <= A
1 <= B[i][2] <= 1e3
Examples:

Input 1:
    A = 4
    B = [   [1, 2, 1]
            [2, 3, 4]
            [1, 4, 3]
            [4, 3, 2]
            [1, 3, 10]  ]

Output 1:
    6

Explanation 1:
    We can choose bridges (1, 2, 1), (1, 4, 3) and (4, 3, 2), where the total cost incurred will be (1 + 3 + 2) = 6.

Input 2:
    A = 4
    B = [   [1, 2, 1]
            [2, 3, 2]
            [3, 4, 4]
            [1, 4, 3]   ]

Output 2:
    6

Explanation 2:
    We can choose bridges (1, 2, 1), (2, 3, 2) and (1, 4, 3), where the total cost incurred will be (1 + 2 + 3) = 6.","#define N 100005

int n,m,p[N],rank11[N];
vector<pair<int,pair<int,int> > > v;

void create_set() {
    for(int i = 1; i <= n; i++) {
        p[i] = i,rank11[i] = 0;
    }
}

int find_set(int u) {
    int x = p[u];
    if(x != u)
        x = find_set(x);
    return x;
}
void merge_set(int u,int v) {
    int s1 = find_set(u);
    int s2 = find_set(v);
    if(rank11[s1] > rank11[s2])
        p[s2] = s1;
    else 
        p[s1] = s2;
    if(rank11[s1] == rank11[s2])
        rank11[s2] += 1;
}
int kruskal() {
    create_set();
    int res = 0;
    for(int i = 0; i < v.size() ; i++) {
        int v1 = v[i].second.first;
        int v2 = v[i].second.second;
        if(find_set(v1) != find_set(v2)) {
            res += v[i].first;
            merge_set(v1,v2);
        }
    }
    return res;
}


int Solution::solve(int A, vector<vector<int> > &B) {
	n = A;
	m = (int)B.size();
	v.clear();
	for (int i = 0; i < m; i++) {
		int x, y, cost;
		x = B[i][0];                  // As each row has 3 columns.
		y = B[i][1];
		cost = B[i][2];
		v.push_back(make_pair(cost,make_pair(x,y)));
	}
	sort(v.begin(),v.end());
	return kruskal();
}"
Possibility of finishing all courses given pre-requisites,https://www.interviewbit.com/problems/possibility-of-finishing-all-courses-given-prerequisites/,"Amazon, Flipkart, Zenefits",Graph Data Structure & Algorithms,medium,"Problem Description
 
 

There are a total of A courses you have to take, labeled from 1 to A.
Some courses may have prerequisites, for example to take course 2 you have to first take course 1, which is expressed as a pair: [1,2].
The pairs are given as two arrays B and C, where [B[i], C[i]] form a pair.

Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?
Return 1 if it is possible to finish all the courses, or 0 if it is not possible to finish all the courses.


Problem Constraints
1 <= A <= 105
1 <= length(B) = length(C) <= 105
1 <= B[i], C[i] <= A


Input Format
The first argument of input contains an integer A, representing the number of courses.
The second argument of input contains an integer array, B.
The third argument of input contains an integer array, C.


Output Format
Return a boolean value:
1 : If it is possible to complete all the courses.
0 : If it is not possible to complete all the courses.


Example Input
Input 1:
A = 3
B = [1, 2]
C = [2, 3]
Input 2:

A = 2
B = [1, 2]
C = [2, 1]


Example Output
Output 1:
1
Output 2:

0


Example Explanation
Explanation 1:
It is possible to complete the courses in the following order:
1 -> 2 -> 3
Explanation 2:

It is not possible to complete all the courses.","void topo_dfs(bool &is_cycle,unordered_map<int,vector<int>> &m,vector<int> &res,stack<int>& st,int j){
    
    // if(is_cycle) return ;
    res[j]=1;
    for(int i=0;i<m[j].size();i++){
        int sub=m[j][i];
        
        
        if(res[sub]==1) {
            is_cycle=true;   
        }
        
        else if(res[sub]==0){
                topo_dfs(is_cycle,m,res,st,sub);
        }
        // else if(res[sub]==2) do nothing
        
    }
    // cout<<"" putting ""<<j<<"" in stack\t"";
    st.push(j);
    res[j]=2;
    
    
}


int Solution::solve(int A, vector<int> &B, vector<int> &C) {
    
    int n=A;
    
    unordered_map<int,vector<int>> m; for(int i=0;i<B.size();i++) m[B[i]-1].push_back(C[i]-1);
    stack<int> st;
    vector<int> vis(A,0);
    vector<int> res(A,0); bool is_cycle=false;
    for(int i=0;i<A;i++){
        
        // if(is_cycle)return 0;
        
        if(res[i]==0){
            vis[i]=1; res[i]=1;
            topo_dfs(is_cycle,m,res,st,i);
        }
        // res[i]=2;
    }
    
    if(st.size()==A && !is_cycle) return 1;
    return 0;
    
    
    
}"
Vertical Order traversal of Binary Tree,https://www.interviewbit.com/problems/vertical-order-traversal-of-binary-tree/,"Amazon, Microsoft",Tree Data Structure,easy,"Problem Description
 
 

Given a binary tree A consisting of N nodes, return a 2-D array denoting the vertical order traversal of A.

Go through the example and image for more details.

NOTE:

If 2 or more Tree Nodes shares the same vertical level then the one with earlier occurence in the level-order traversal of tree comes first in the output.
Row 1 of the output array will be the nodes on leftmost vertical line similarly last row of the output array will be the nodes on the rightmost vertical line.


Problem Constraints
0 <= N <= 104



Input Format
First and only argument is an pointer to root of the binary tree A.



Output Format
Return a 2D array denoting the vertical order traversal of A.



Example Input
Input 1:

      6
    /   \
   3     7
  / \     \
 2   5     9
Input 2:

           1
         /   \
        2     3
       / \
      4   5


Example Output
Output 1:

 [
    [2],
    [3],
    [6, 5],
    [7],
    [9]
 ]
Output 2:

 [
    [4],
    [2],
    [1, 5],
    [3]
 ]


Example Explanation
Explanation 1:

 
 Nodes on Vertical Line 1: 2
 Nodes on Vertical Line 2: 3
 Nodes on Vertical Line 3: 6, 5
    As 6 and 5 are on the same vertical level but as 6 comes first in the level-order traversal of the tree so we will output 6 before 5.
 Nodes on Vertical Line 4: 7
 Nodes on Vertical Line 5: 9
Explanation 2:

 Nodes on Vertical Line 1: 4
 Nodes on Vertical Line 2: 2
 Nodes on Vertical Line 3: 1, 5
 Nodes on Vertical Line 4: 3","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
vector<vector<int> > Solution::verticalOrderTraversal(TreeNode* root) {
    // Base case 
  vector<vector<int> >ans;
  if(root==NULL)return ans;
    // Create a map and store vertical oder in 
    // map using function getVerticalOrder() 
    map < int,vector<int> > m; 
    int hd = 0; 
  
    // Create queue to do level order traversal. 
    // Every item of queue contains node and 
    // horizontal distance. 
    queue<pair<TreeNode*, int> > que; 
    que.push(make_pair(root, hd)); 
  
     while (!que.empty()) 
     { 
        // pop from queue front 
        pair<TreeNode *,int> temp = que.front(); 
        que.pop(); 
        hd = temp.second; 
        TreeNode* node = temp.first; 
  
        // insert this node's data in vector of hash 
        m[hd].push_back(node->val); 
  
        if (node->left != NULL) 
            que.push(make_pair(node->left, hd-1)); 
        if (node->right != NULL) 
            que.push(make_pair(node->right, hd+1)); 
    } 
  
    // Traverse the map and print nodes at 
    // every horigontal distance (hd) 
    map< int,vector<int> > :: iterator it;
    for (it=m.begin(); it!=m.end(); it++) 
    { 
        ans.push_back(it->second);
    } 
    return ans;
}"
Numbers of length N and value less than K,https://www.interviewbit.com/problems/numbers-of-length-n-and-value-less-than-k/,N/A,Math,easy,"Problem Description
 
 

Given a set of digits (A) in sorted order, find how many numbers can be formed using these digits such that its length is B and whose value is less than the number C.
NOTE: All numbers can only have digits from the given set. 



Problem Constraints
0 <= |A| <= 10
1 <= B <= 9
0 <= C <= 1e9
0 <= A[i] <= 9


Input Format
The first argument is an integer array A.
The second argument is an integer B.
The third argument is an integer C.


Output Format
Return an integer.


Example Input
Input 1:
A = [0, 1, 5]
B = 1
C = 2
Input 2:
A = [0, 1, 2, 5]
B = 2
C = 21


Example Output
Output 1:
2
Output 2:
5


Example Explanation
Explanation 1:
0 and 1 are possible 
Explanation 2:
10, 11, 12, 15, 20 are possible","vector<int> numToVec(int N) {   
    vector<int> digit;
    while(N != 0) {
        digit.push_back(N % 10);
        N = N / 10;
    }

    if(digit.size() == 0)
        digit.push_back(0);
        reverse(digit.begin(), digit.end());
        return digit;
}

int Solution:: solve(vector<int> &A, int B, int C) {
    vector<int> digit;
    int  d, d2;
    // Convert number to digit array
    digit = numToVec(C);
    d = A.size();

    //Case 1
    if(B > digit.size()  || d == 0)
        return 0;

    // Case 2
    else if(B < digit.size()) {
        // contain 0 
        if(A[0] == 0 && B != 1)
            return (d - 1) * pow(d, B - 1);
        else 
            return pow(d, B);
    }

    //Case 3
    else {
      int dp[B + 1], lower[11];
      for(int i = 0; i <= B; i++)
          dp[i] = 0;
      for(int i = 0; i <= 10; i++)
           lower[i] = 0;
      for(int i = 0; i < d; i++)
          lower[A[i] + 1] = 1;

      for(int i = 1; i <= 10; i++)
          lower[i] = lower[i-1] + lower[i]; 

      bool flag = true;
      dp[0] = 0;
      for(int i = 1; i <= B; i++) {

          d2 = lower[digit[i-1]];
          dp[i] = dp[i-1] * d;

          // For first index we can't use 0
          if(i == 1 &&  A[0] == 0 && B != 1)
              d2 = d2 - 1;

          //Whether (i-1) digit of generated number can be equal to (i - 1) digit of C.
          if(flag)
              dp[i] += d2;
          //Is digit[i - 1] present in A ?
          flag = flag & (lower[digit[i-1] + 1] == lower[digit[i-1]] + 1);
        }
        return dp[B];                   
    }
}"
K reverse linked list,https://www.interviewbit.com/problems/k-reverse-linked-list/,"Microsoft, Amazon",Linked Lists,medium,"Given a singly linked list and an integer K, reverses the nodes of the

list K at a time and returns modified linked list.

NOTE : The length of the list is divisible by K

Example :

Given linked list 1 -> 2 -> 3 -> 4 -> 5 -> 6 and K=2,

You should return 2 -> 1 -> 4 -> 3 -> 6 -> 5

Try to solve the problem using constant extra space.","/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
ListNode* reverse(ListNode* A) {
    if (!A -> next)
        return A;
    ListNode *next = A -> next;
    A -> next = NULL;
    ListNode *reversed = reverse(next);
    next -> next = A;
    return reversed;
}

ListNode* Solution::reverseList(ListNode* A, int K) {
    ListNode *reversedFirst = A;
    for (int i = 1; i < K; i += 1) {
        reversedFirst = reversedFirst -> next;
    }

    // prev is the last element of the previous bucket
    // first is the first element of the current bucket
    // last is the last element of the current bucket
    ListNode *prev = new ListNode(0);
    ListNode *first;
    prev -> next = A;
    ListNode *last = prev;
    
    while (last -> next) {
        // Find the current bucket
        for (int i = 1; i <= K; i += 1) {
            last = last -> next;
        }
        first = prev -> next;
        // Unlink the bucket from the list and reverse it
        prev -> next = NULL;
        ListNode *next = last -> next;
        last -> next = NULL;
        reverse(first);
        // Attack the reversed bucket to the list
        // After the bucket is reversed, first and last are reversed
        prev -> next = last;
        first -> next = next;
        prev = last = first;
    }
    return reversedFirst;
}"
Ways to color a 3xN Board,https://www.interviewbit.com/problems/ways-to-color-a-3xn-board/,Codenation,Dynamic Programming,medium,"Given a 3 x A board,  find the number of ways to color it using at most 4 colors such that no 2 adjacent boxes have same color.

Diagonal neighbors are not treated as adjacent boxes.

Return the ways modulo 109 + 7 as the answer grows quickly.

Input Format:

The first and the only argument contains an integer, A.
Output Format:

Return an integer representing the number of ways to color the board.
Constraints:

1 <= A < 100000
Examples:

Input 1:
    A = 1

Output 1:
    36

Input 2:
    A = 2

Output 2:
    588","#define mod 1000000007
#define ll long long

struct triplet{
	int x, y, z;
};

vector<triplet> trip;  //vector of 36 triplets

void fillTriplets(){
	//trip vector contain the triplets of color that can be used to paint a certain column
       trip.clear();
	for(int i=0; i<4; i++){
		for(int j=0; j<4; j++){
			for(int k=0; k<4; k++){
				if(i!=j && j!=k) trip.push_back({i,j,k});
			}
		}
	}
}

int dp[4][4][4][100005];


bool isCompatible(const triplet& t1,  const triplet& t2){
	//check if triplets t1 and t2 are compatible
	if(t1.x==t2.x || t1.y==t2.y || t1.z==t2.z ){
		return 0;
	}
	return 1;
}

int Solution::solve(int n){
        fillTriplets();
	if(n<=0) return -1;
	
       //Bottom-up dp
	for(int i=1; i<=n; i++){
		for(int j=0; j<36; j++){
			if(i==1) dp[trip[j].x][trip[j].y][trip[j].z][i] = 1;
			else{
				ll temp = 0;
				
				for(int k=0; k<36; k++){
					if(isCompatible(trip[j], trip[k])){
						temp += dp[trip[k].x][trip[k].y][trip[k].z][i-1];
						temp %= mod;
					}
				}
				dp[trip[j].x][trip[j].y][trip[j].z][i] = temp;
			}
		}
	}
	
	ll ans = 0;
	for(int i=0; i<trip.size(); i++){
		ans = (ans + dp[trip[i].x][trip[i].y][trip[i].z][n])%mod;
	}
        int res = ans;

	return res;
}"
FizzBuzz,https://www.interviewbit.com/problems/fizzbuzz/,N/A,Math,easy,"Fizzbuzz is one of the most basic problems in the coding interview world. Try to write a small and elegant code for this problem.

Given a positive integer A, return an array of strings with all the integers from 1 to N. 

But for multiples of 3 the array should have “Fizz” instead of the number. 

For the multiples of 5, the array should have “Buzz” instead of the number. 

For numbers which are multiple of 3 and 5 both, the array should have “FizzBuzz” instead of the number.

Look at the example for more details.

Example

A = 5
Return: [1 2 Fizz 4 Buzz]","vector<string> Solution::fizzBuzz(int A) {
	vector<string> ans;
	for (int num = 1; num <= A; num++) {
		if ((num % 3 == 0) && (num % 5 == 0)) {
			ans.push_back(""FizzBuzz"");
		} else if(num % 3 == 0) {
			ans.push_back(""Fizz"");
		} else if(num % 5 == 0) {
			ans.push_back(""Buzz"");
		} else {
			// convert the integer 'num' into string here
			string numStr;
			for(int i = num; i > 0; i /= 10) {
				numStr = char((i % 10) + '0') + numStr;
			}
			ans.push_back(numStr);
		}
	}
	return ans;
}"
Min XOR value,https://www.interviewbit.com/problems/min-xor-value/,N/A,Bit Manipulation,medium,"Given an integer array A of N integers, find the pair of integers in the array which have minimum XOR value. Report the minimum XOR value.

Input Format:

    First and only argument of input contains an integer array A
Output Format:

    return a single integer denoting minimum xor value
Constraints:

2 <= N <= 100 000  
0 <= A[i] <= 1 000 000 000
For Examples :

Example Input 1:
    A = [0, 2, 5, 7]
Example Output 1:
    2
Explanation:
    0 xor 2 = 2
Example Input 2:
    A = [0, 4, 7, 9]
Example Output 2:
    3","int Solution::findMinXor(vector<int> &numbers) {
    sort(numbers.begin(), numbers.end());
    int smallestXor = numbers[0] ^ numbers[1];
    for (int i = 2; i < numbers.size(); i ++) {
        smallestXor = min(smallestXor, numbers[i - 1] ^ numbers[i]);
    }
    return smallestXor;
}"
Tushar's Birthday Bombs,https://www.interviewbit.com/problems/tushars-birthday-bombs/,N/A,Dynamic Programming,medium,"Problem Description
 
 

It’s Tushar’s birthday today and he has N friends.

Friends are numbered [0, 1, 2, ...., N-1] and ith friend have a positive strength B[i].

Today being his birthday, his friends have planned to give him birthday bombs (kicks).

Tushar's friends know Tushar's pain bearing limit and would hit accordingly.

If Tushar’s resistance is denoted by A (>=0) then find the lexicographically smallest order of friends to kick Tushar so that the cumulative kick strength (sum of the strengths of friends who kicks) doesn’t exceed his resistance capacity and total no. of kicks hit are maximum.

Also note that each friend can kick an unlimited number of times (If a friend hits x times, his strength will be counted x times)

Return the lexicographically smallest array of maximum length where the ith index represents the index of the friend who will hit.

NOTE:

[a1, a2, ...., am] is lexicographically smaller than [b1, b2, .., bm] if a1 < b1 or (a1 = b1 and a2 < b2) ... .
Input cases are such that the length of the answer does not exceed 100000.


Problem Constraints
1 <= N <= 100

1 <= A <= 15 * 106

1 <= B[i] <= 105



Input Format
The first argument contains an integer, A of length N.

The second argument contains an array of integers B.



Output Format
Return an array of integer, as described in the problem statement.



Example Input
Input 1: 

 A = 12
 B = [3, 4]
Input 2:

 A = 11
 B = [6, 8, 5, 4, 7]


Example Output
Output 1: 

 [0, 0, 0, 0]
Output 2:

 [0, 2]


Example Explanation
Explanation 1:
The first friend with the index value 0 and strength 3 can hit 4 times, 
providing the lexicographically smallest array of maximum length 
Explanation 1:
The first friend with the index value 0 and strength 6 can only hit once, 
making the Tushar's resistance to 5, now the third friend with the index value 2 can hit once, 
providing the lexicographically smallest array of maximum length.","#define F first
#define S second

vector<int> Solution::solve(int A, vector<int>& B){
	// newB -> only those strengths which are useful
	// pair {i,j} -> i = original index of the person, j = strength
	vector<pair<int, int> > newB;
	assert(A>=1 && A<=15000000);
	assert(B.size()>=1 && B.size()<=100);
	for(int a:B)
	    assert(a>=1 && a<=100000);
	int prev = INT_MAX;
	for(int i=0; i<B.size(); i++){
		if(B[i] < prev){
			newB.push_back({i, B[i]});
			prev = B[i];
		} 
	}
	
	int n = newB.size();
	
	vector<int> ans;
	
	int R = A;
	int temp = newB[n-1].second;   //smallest strength
	int i=0;
	
	
	while(i<n){
		// check if the current person can hit and if he can hit
		// would he change the answer or not
		if(R >= newB[i].S && (1 + (R-newB[i].S)/temp) == R/temp){
			ans.push_back(newB[i].F);
			R -= newB[i].S;
		} 
		else i++;
	}
	
	return ans;
}"
Tushar's Birthday Party,https://www.interviewbit.com/problems/tushars-birthday-party/,Snapdeal,Dynamic Programming,medium,"Problem Description
 
 

As it is Tushar's Birthday on March 1st, he decided to throw a party to all his friends at TGI Fridays in Pune. Given are the eating capacity of each friend, the filling capacity of each dish and the cost of each dish. A friend is satisfied if the sum of the filling capacity of dishes he ate is equal to his capacity. Find the minimum cost such that all of Tushar's friends are satisfied (reached their eating capacity).

NOTE:
Each dish is supposed to be eaten by only one person. Sharing is not allowed.
Each friend can take any dish an unlimited number of times.
There always exists a dish with a filling capacity of 1 so that a solution always exists.


Problem Constraints
1 <= Capacity of friend <= 1000
1 <= No. of friends <= 1000
1 <= No. of dishes <= 1000


Input Format
Friends: A: List of integers denoting eating capacity of friends separated by space.
Capacity: B: List of integers denoting filling capacity of each type of dish.
Cost: C: List of integers denoting cost of each type of dish.


Example Input
A = [4, 6]
B = [1, 3]
C = [5, 3]


Example Output
14


Example Explanation
The first friend will take 1st and 2nd dish, the second friend will take 2nd dish twice. Thus, total cost = (5+3)+(3*2)= 14","#define INF 10000000

int dp[1005][1005];

int Solution::solve(const vector<int> &A,  const vector<int> &B, const vector<int> &C){
	// vector of pair {dish_items, dish_cost}
	vector<pair<int,int> > dish;
	int n = C.size();	
	for(int i=0; i<n; i++)	dish.push_back(make_pair(B[i],C[i]));
	
	//maximum capacity among friends
	int m = -1;
	for(int i=0; i<A.size(); i++){
		m = max(m, A[i]);
	}
	
	// dp[highest capacity][no. of dishes]
	for(int i=0; i<=m; i++){
		for(int j = 0; j<=n; j++){
			//if capacity of friend is 0
			if(i == 0) dp[i][j] = 0;
			//if no dish is remaining to choose from
			else if(j==0) dp[i][j] = INF;
			else{
				//if i-th person can eat jth dish
				if(i >= dish[j-1].first) dp[i][j] = min(dp[i][j-1], dp[i-dish[j-1].first][j] + dish[j-1].second);
				else dp[i][j] = dp[i][j-1];
			} 
		}	
	}
	
	// Add for each friend independently
	int ans=0;
	for(int i=0; i<A.size(); i++){
		ans += dp[A[i]][n];
	}
	
	return ans;
}"
Kth Manhattan Distance Neighbourhood,https://www.interviewbit.com/problems/kth-manhattan-distance-neighbourhood/,N/A,Dynamic Programming,medium,"Given a matrix M of size nxm and an integer K, find the maximum element in the K manhattan distance neighbourhood for all elements in nxm matrix. 

In other words, for every element M[i][j] find the maximum element M[p][q] such that abs(i-p)+abs(j-q) <= K.

Note: Expected time complexity is O(N*N*K)

Constraints:

1 <= n <= 300
1 <= m <= 300
1 <= K <= 300
0 <= M[i][j] <= 1000
Example:

Input:
M  = [[1,2,4],[4,5,8]] , K = 2

Output:
ans = [[5,8,8],[8,8,8]]","bool check(int i, int j, int n, int m){
	//Check if (i,j) are with in matrix dimensions
	if(i >= 0 && j >=0 && i < n && j < m) return 1;
	return 0;
}

vector<vector<int> > Solution::solve(int A, vector<vector<int> > &B) {
	// DP can be optimized to be of N*N size as we need only dp[k-1][n][n] for dp[k][n][n]
	int n = B.size();
	int m = B[0].size();
	
	vector<vector<vector<int> > > dp(2);
	dp[0] = dp[1] = B;
	
	int rplus[4] = {1,0,0,-1};
	int cplus[4] = {0,-1,1,0};
	
	for(int k=0; k <= A; k++){
		for(int i=0; i<n; i++){
			for(int j=0; j<m; j++){
				//base case
				if( k== 0) dp[k][i][j] = B[i][j];
				//dp[k][i][j] = max(dp[k-1][i-1][j],dp[k-1][i+1][j],dp[k-1][i][j-1],
				 //                                   dp[k-1][i][j+1],dp[k-1][i][j])
				else{
					int ans = dp[(k-1)%2][i][j];
					for(int p = 0; p < 4; p++){
						int temp_i = i+rplus[p];
						int temp_j = j+cplus[p];
						if(check(temp_i, temp_j, n, m)) ans = max(ans, dp[(k-1)%2][temp_i][temp_j]);
					}
					dp[k%2][i][j] = ans;
	
				}
			}
		}
	}
	
	return dp[A%2];
}"
N max pair combinations,https://www.interviewbit.com/problems/n-max-pair-combinations/,N/A,Heaps And Maps,medium,"Problem Description
 
 

Given two integers arrays A and B of size N each.

Find the maximum N elements from the sum combinations (Ai + Bj) formed from elements in array A and B.



Problem Constraints
1 <= N <= 2 * 105

-1000 <= A[i], B[i] <= 1000



Input Format
First argument is an integer array A.

Second argument is an integer array B.



Output Format
Return an intger array denoting the N maximum element in descending order.



Example Input
Input 1:

 A = [1, 4, 2, 3]
 B = [2, 5, 1, 6]
Input 2:

 A = [2, 4, 1, 1]
 B = [-2, -3, 2, 4]


Example Output
Output 1:

 [10, 9, 9, 8]
Output 2:

 [8, 6, 6, 5]


Example Explanation
Explanation 1:

 4 maximum elements are 10(6+4), 9(6+3), 9(5+4), 8(6+2).
Explanation 2:

 4 maximum elements are 8(4+4), 6(4+2), 6(4+2), 5(4+1).","vector<int> Solution::solve(vector<int> &A, vector<int> &B) {
	priority_queue<pair<int, pair<int, int> > > hp;
	set<pair<int, int> > S;
	int n = A.size();
	sort(A.begin(), A.end());
	sort(B.begin(), B.end());

	hp.push(make_pair(A[n-1]+B[n-1], make_pair(n-1, n-1)));
	S.insert(make_pair(n-1, n-1));

	vector<int> ans;
	int k=n;
	while(k--){
		pair<int, pair<int, int> > top = hp.top();
		hp.pop();
		ans.push_back(top.first);
		int L = top.second.first;
		int R = top.second.second;
		
		if( R>0 && L>=0  && S.find(make_pair(L,R-1)) == S.end() ){
			hp.push(make_pair(A[L]+B[R-1], make_pair(L,R-1)));
			S.insert(make_pair(L,R-1));
		}
		if( R>=0  && L>0 && S.find(make_pair(L-1, R))==S.end()){
			hp.push(make_pair(A[L-1]+B[R], make_pair(L-1,R)));
			S.insert(make_pair(L-1, R));
		}
	}
	return ans;
}"
Valid Path,https://www.interviewbit.com/problems/valid-path/,"Amazon, Codenation, Directi",Graph Data Structure & Algorithms,medium,"Problem Description
 
 

There is a rectangle with the left top as (0, 0) and the right bottom as (x, y). There are N circles such that their centers are inside the rectangle. The radius of each circle is R. Now we need to find out if it is possible that we can move from (0, 0) to (x, y) without touching any circle.

Note :
We can move from any cell to any of its 8 adjacent neighbors and we cannot move outside the boundary of the rectangle at any point of time.
A circle doesn't touch a cell (i,j) if the distance from its center to the cell (i,j) is less than R.


Problem Constraints
0 <= x, y, R <= 100
1 <= N <= 1000
The Center of each circle would lie within the grid


Input Format
1st argument given is an Integer x.
2nd argument given is an Integer y.
3rd argument given is an Integer N, the number of circles.
4th argument given is an Integer R, the radius of each circle.
5th argument given is an Array A of size N, where A[i] = x coordinate of the ith circle
6th argument given is an Array B of size N, where B[i] = y coordinate of the ith circle


Output Format
Return YES or NO depending on weather it is possible to reach cell (x,y) or not starting from (0,0).


Example Input
x = 2
y = 3
N = 1
R = 1
A = [2]
B = [3]


Example Output
NO


Example Explanation
There is NO valid path in this case","#include <bits/stdc++.h>
#define MAX 105
int mat[MAX][MAX];
int visited[MAX][MAX];
int max_x, max_y;
bool dist(int x, int y , int x1 , int y1 , int r) {
    if((x - x1) * (x - x1) + (y - y1 ) * (y - y1 ) <= r*r) {
        return true;
    }
    return false;
}
bool valid(int x, int y) {
    if(x >= 0 && x <= max_x  && y >= 0 && y <= max_y && mat[x][y] == 0 && visited[x][y] == 0) {
        return true;
    }
    return false;
}

string Solution::solve(int x, int y, int N , int R , vector<int> &X_cord, vector<int> &Y_cord) {
    memset(mat, 0 , sizeof(mat));
    memset(visited, 0 , sizeof(visited));
    max_x = x;
    max_y = y;
    vector<pair<int, int> > v;
    for(int i = 0; i < N; i++) {
        v.push_back(make_pair(X_cord[i], Y_cord[i]));
    }
    for(int i = 0; i <= x+ 1; i++) {
       for(int j = 0; j <= y+1; j++) {
            bool flag = true;
            for(int k = 0; k < N; k++) {
                if(dist(i, j , v[k].first , v[k].second, R)) {
                    flag = false;
                    break;
                }
            }
            if(flag) {
                mat[i][j] = 0;
            } else {
                mat[i][j] = 1;
            }
       }
    }
   // cout << mat[x][y] <<"" "" << dist(x, y, x, y, R) << endl;
    if(mat[0][0] == 1 || mat[x][y] == 1) {
        string ret = ""NO"";
        return ret;
    } else {
        visited[0][0] = 1;

        queue<pair<int , int> >q ;
        q.push(make_pair(0, 0));
        int dest1 = x;
        int dest2 = y;
        while(!q.empty()){
            pair<int , int > p1 = q.front();
            q.pop();
            int x  = p1.first;
            int y  = p1.second;
            if(x == dest1 && y == dest2) {
                string ret = ""YES"";
                return ret;
            }
            if(valid(x-1, y)) {
                visited[x-1][y] = 1;
                q.push(make_pair(x-1 , y));
            }
            if(valid(x, y-1)) {
                visited[x][y-1] = 1;
                q.push(make_pair(x , y-1));
            }
            if(valid(x+1, y)) {
                visited[x+1][y] = 1;
                q.push(make_pair(x+1 , y));
            }
            if(valid(x, y+1)) {
                visited[x][y+1] = 1;
                q.push(make_pair(x , y+1));
            }
            if(valid(x+1, y+1)) {
                visited[x+1][y+1] = 1;
                q.push(make_pair(x+1 , y+1));
            }
            if(valid(x+1, y-1)) {
                visited[x+1][y-1] = 1;
                q.push(make_pair(x+1 , y-1));
            }
            if(valid(x-1, y+1)) {
                visited[x-1][y+1] = 1;
                q.push(make_pair(x-1 , y+1));
            }
            if(valid(x-1, y-1)) {
                visited[x-1][y-1] = 1;
                q.push(make_pair(x-1 , y-1));
            }
        }
        string ret = ""NO"";
        return ret;
    }

}"
Minimize the absolute difference,https://www.interviewbit.com/problems/minimize-the-absolute-difference/,Microsoft,Two Pointers,medium,"Given three sorted arrays A, B  and Cof not necessarily same sizes.

Calculate the minimum absolute difference between the maximum and minimum number from the triplet a, b, c such that a, b, c belongs arrays A, B, C respectively.

i.e. minimize | max(a,b,c) - min(a,b,c) |.

Example :

Input:

A : [ 1, 4, 5, 8, 10 ]
B : [ 6, 9, 15 ]
C : [ 2, 3, 6, 6 ]
Output:

1
Explanation: We get the minimum difference for a=5, b=6, c=6 as | max(a,b,c) - min(a,b,c) | = |6-5| = 1.","int Solution::solve(vector<int> &A, vector<int> &B, vector<int> &C) {
    int ans = INT_MAX;
    int i=A.size()-1,j=B.size()-1,k=C.size()-1;
    while(i>=0 and j>=0 and k>=0)
    {
        int maxe = max(A[i], max(B[j],C[k]));
        int mine = min(A[i], min(B[j],C[k]));
        ans = min(ans, maxe - mine);
        if(A[i]==maxe) i--;
        else if(B[j]==maxe) j--;
        else if(C[k]==maxe) k--;
    }
    return ans;
}"
Largest area of rectangle with permutations,https://www.interviewbit.com/problems/largest-area-of-rectangle-with-permutations/,Directi,Dynamic Programming,medium,"Problem Description
 
 

Given a binary grid A of size N x M consisting of 0's and 1's, find the area of the largest rectangle inside the grid such that all the cells inside the chosen rectangle should have 1 in them.

You are allowed to permutate the columns matrix i.e. you can arrange each of the column in any order in the final grid.

Please follow the sample input and explanation for more clarity.



Problem Constraints
1 <= N, M <= 103


Input Format
First and only argument is an 2D binary array A.



Output Format
Return a single integer denoting the area of the largest rectangle inside the grid such that all the cells inside the chosen rectangle should have 1 in them.



Example Input
Input 1:

 A = [  [1, 0, 1]
        [0, 1 ,0]
        [1, 0, 0]
    ]


Example Output
Output 1:

 2


Example Explanation
Explanation 1:

    1 0 1
    0 1 0
    1 0 0


At present we can see that max rectangle satisfying the criteria mentioned in the problem
 is of 1 * 1 = 1 area i.e either of the 4 cells which contain 1 in it.



Now since we are allowed to permutate the columns of the given matrix, we can take column 1
 and column 3 and make them neighbours. One of the possible configuration of the grid can be:
 1 1 0
 0 0 1
 1 0 0



Now In this grid, first column is column 1, second column is column 3 and third column
 is column 2 from the original given grid.



Now, we can see that if we calculate the max area rectangle, we get max area as 1 * 2 = 2
 which is bigger than the earlier case. Hence 2 will be the answer in this case.

","int Solution::solve(vector<vector<int> > &A) {
	int n, m, res = 0;
	n = A.size();
	m = A[0].size();
	int dp[n+1][m+1];
	memset(dp, 0, sizeof(dp));
	for (int i = 1; i <= m; ++i) {
		for (int j = 1; j <= n; ++j) {
			if(A[j-1][i-1] == 0) {
				dp[j][i] = 0;
			}
			else {
				dp[j][i] += dp[j-1][i] + 1;
			}
		}
	}
	for (int i = 1; i <= n; ++i) {
		int arr[n + 1], cnt = 0;
		memset(arr, 0, sizeof(arr));
		for (int j = 1; j <= m; ++j) {
			arr[dp[i][j]] ++;
		}
		for (int j = n; j >= 0; --j) {
			cnt += arr[j];
			res = max(res, cnt * j);
		}
	}
	return res;
}"
Hotel Reviews,https://www.interviewbit.com/problems/hotel-reviews/,Fab,Tree Data Structure,medium,"Problem Description
 
 

Given a set of reviews provided by the customers for different hotels and a string containing Good Words, you need to sort the reviews in descending order according to their Goodness Value (Higher goodness value first). We define the Goodness Value of a string as the number of Good Words in that string.

NOTE: Sorting should be stable. If review i and review j have the same Goodness Value then their original order would be preserved.

You are expected to use Trie in an Interview for such problems



Problem Constraints
1 <= No.of reviews <= 200
1 <= No. of words in a review <= 1000
1 <= Length of an individual review <= 10,000
1 <= Number of Good Words <= 10,000
1 <= Length of an individual Good Word <= 4
All the alphabets are lower case (a - z)


Input Format
First argument is a string A containing ""Good Words"" separated by ""_"" character

Second argument is a vector B of strings containing Hotel Reviews. Review strings are also separated by ""_"" character.



Output Format
Return a vector of integers which contain the original indexes of the reviews in the sorted order of reviews.



Example Input
Input 1:

 A = ""coolicewifi""
 B = [""wateriscool"", ""coldicedrink"", ""coolwifispeed""]


Example Output
Output 1:

 [2, 0, 1]


Example Explanation
Explanation 1:

 sorted reviews are [""coolwifispeed"", ""wateriscool"", ""coldicedrink""]","#define F first
#define S second


bool cmp(const pair<int, int>& a, const pair<int, int>& b){
    if(a.F == b.F) return a.S < b.S;
	return a.F > b.F;	
}

//Trie node
struct node{
	bool exist;
	node* arr[26];
	node(bool bul=false){
		exist = bul;
		for(int i=0; i<26; i++)	arr[i] = NULL;
	}
};

void add(string s,node* trie){
    //add a node to the trie
	int n = s.size();
	for(int i=0; i<n; i++){
		if(trie->arr[s[i]-'a']==NULL)	trie->arr[s[i]-'a'] = new node();
		trie = trie->arr[s[i]-'a'];
	}
	trie->exist=true;
	return;
}

bool search(string s,node* trie){
    //search for a node in the trie
	for(int i=0; i<s.size(); i++){
		if(trie->arr[s[i]-'a']==NULL)	return false;
		trie = trie->arr[s[i]-'a'];
	}
	return trie->exist;
}

void convert(string &str){
    //Convert _ to spaces
	for(int i=0; i<str.size(); i++)	if(str[i]=='_')	str[i]=' ';
	return;
}

vector<int> Solution::solve(string good, vector<string>& review){
	convert(good);
	node* trie = new node();
	string word;
	stringstream ss;
	ss<<good;
	while(ss>>word)	add(word,trie);
	int n = review.size();
	int k;
	vector<pair<int,int> > rating(n);
	for(int i=0; i<n; i++){
		convert(review[i]);
		ss.clear();
		ss<<review[i];
		k=0;
		while(ss>>word)	if(search(word,trie))	k++;
		rating[i].first = k;	rating[i].second = i;
	}
	sort(rating.begin(),rating.end(),cmp);
	vector<int> ans(n);
	for(int i=0; i<n; i++)	ans[i] = rating[i].second;
	return ans;
}"
Good Graph,https://www.interviewbit.com/problems/good-graph/,Paypal,Graph Data Structure & Algorithms,medium,"Problem Description
 
 

Given a directed graph of N nodes where each node is pointing to any one of the N nodes (can possibly point to itself). Ishu, the coder, is bored and he has discovered a problem out of it to keep himself busy.

The problem is as follows:

A node is 'good' if it satisfies one of the following:
It is the special node (marked as node 1)
It is pointing to the special node (node 1)
It is pointing to a good node.

Ishu is going to change the pointers of some nodes to make them all 'good'. You have to find the min. the number of pointers to change in order to make all the nodes good (Thus, a Good Graph).

Note: Resultant Graph should hold the property that all nodes are good and each node must point to exactly one node.


Problem Constraints
1 <= N <= 100,000


Input Format
A vector of N integers containing N numbers all between 1 to N, where i-th number is the number of node that i-th node is pointing to.


Output Format
An Integer denoting min. number of pointer changes.


Example Input
Input 1:
A = [1, 2, 1, 2]
Input 2:
A = [3, 1, 3, 1]


Example Output
Output 1:
1
Output 2:
1


Example Explanation
Explanation 1:
Pointer of node 2 is made to point to node 1
Explanation 2:
Pointer of node 3 is made to point to node 1","int Solution::solve(vector<int> &A) {
    
    int n = A.size();
    bool good[n];
    good[0] = true;
    for(int i = 1; i < n; i += 1){
        good[i] = false;
    }
    bool visited[n];
    for(int i = 0; i < n; i += 1){
        visited[i] = false;
    }
    int curr, next;
    vector<int> make_good;
    int ans = 0, c = 0;
    int color[n];
    for(int i = 0; i < n; i += 1) {
        if(visited[i] == false){
            curr = i;
            visited[i] = true;
            next = A[curr] - 1;
            color[curr] = c;
            while(visited[next] == false){
                good[curr] = true;
                visited[next] = true;
                color[next] = c;
                curr = next;
                next = A[curr] - 1;
            }
            if(color[next] == c && next != 0 ){
                ans += 1;
            }
            c += 1;
        }
    }
    return ans;
}"
Kingdom War,https://www.interviewbit.com/problems/kingdom-war/,N/A,Dynamic Programming,medium,"Two kingdoms are on a war right now, kingdom X and kingdom Y. As a war specialist of kingdom X, you scouted kingdom Y area.

A kingdom area is defined as a N x M grid with each cell denoting a village.

Each cell has a value which denotes the strength of each corresponding village.

The strength can also be negative, representing those warriors of your kingdom who were held hostages.

There’s also another thing to be noticed.

The strength of any village on row larger than one (2<=r<=N) is stronger or equal to the strength of village which is exactly above it.
The strength of any village on column larger than one (2<=c<=M) is stronger or equal to the strength of vilage which is exactly to its left.
(stronger means having higher value as defined above).
So your task is, find the largest sum of strength that you can erase by bombing one sub-matrix in the grid.

Input format:

First line consists of 2 integers N and M denoting the number of rows and columns in the grid respectively.
The next N lines, consists of M integers each denoting the strength of each cell.

1 <= N <= 1500
1 <= M <= 1500
-200 <= Cell Strength <= 200
Output:

The largest sum of strength that you can get by choosing one sub-matrix.
Example:

Input:
3 3
-5 -4 -1
-3 2 4
2 5 8

Output:
19

Explanation:
Bomb the sub-matrix from (2,2) to (3,3): 2 + 4 + 5 + 8 = 19","int Solution::solve(vector<vector<int> > &A) {
    int mx = -2000000000;
    int n = A.size();
    int m = A[0].size();
    assert(n>=1 && n<=1500);
    assert(m>=1 && m<=1500);
    for(auto a:A)
        for(auto b:a)
            assert(b>=-100 && b<=100);
	for(int i=n-1;i>=0;i--){
		for(int j=m-1;j>=0;j--){
			if(i<n-1) A[i][j] += A[i+1][j];
			if(j<m-1) A[i][j] += A[i][j+1];
			if(i<n-1 && j<m-1) A[i][j] -= A[i+1][j+1];
			mx = max(mx, A[i][j]);
		}
	}
	return mx;
}"
Convert the amount in number to words,https://www.interviewbit.com/problems/convert-the-amount-in-number-to-words/,"Paypal, Directi",Strings,medium,"Problem Description
 
 

Our company wants to create a data entry verification system. Given an amount in words and an amount indicated by data entry person in numbers, you have to detect whether the amounts are the same or not.

Note:
There are a lot of corner cases to be considered. The interviewer expects you to take care of them.
Every word needs to be separated using ""-"" rather than a space character https://en.wikipedia.org/wiki/Indian_numbering_system
""Use Expected Output option"" to clear further doubts.


Problem Constraints
1 <= |A| <= 9
1 <= |B| <= 100


Input Format
String num: Amount written in digits as a string. This string will be an integer number without having any commas in between the digits.
String words: Amount written in words according to Indian Numbering System.


Output Format
An integer
1: Values match
0: Otherwise


Example Input
String num = ""1234""
String words = ""one-thousand-two-hundred-and-thirty-four""


Example Output
1
","// strings at index 0 is not used
// to make indexing simple
//Please note we will add space after every word
string one[] = { """", ""one-"", ""two-"", ""three-"", ""four-"",
                 ""five-"", ""six-"", ""seven-"", ""eight-"",
                 ""nine-"", ""ten-"", ""eleven-"", ""twelve-"",
                 ""thirteen-"", ""fourteen-"", ""fifteen-"",
                 ""sixteen-"", ""seventeen-"", ""eighteen-"",
                 ""nineteen-""
               };
 
// strings at index 0 and 1 are not used
//to make array indexing simple
string ten[] = { """", """", ""twenty-"", ""thirty-"", ""forty-"",
                 ""fifty-"", ""sixty-"", ""seventy-"", ""eighty-"",
                 ""ninety-""
               };
 
// n is 1- or 2-digit number
string numToWords(int n, string s)
{
    string str = """";
    // if n is more than 19, divide it
    if (n > 19)
        str += ten[n / 10] + one[n % 10];
    else
        str += one[n];
 
    // if n is non-zero
    if (n)
        str += s;
 
    return str;
}
 
// Function to print a given number in words
string convertToWords(int n)
{
    // stores word representation of given number n
    string out;
 
    // handles digits at ten crore and crore places (if any)
    out += numToWords((n / 10000000), ""crore-"");
 
    // handles digits at ten lakh and lakh places (if any)
    out += numToWords(((n / 100000) % 100), ""lakh-"");
 
    // handles digits at thousands and tens thousands
    // places (if any)
    out += numToWords(((n / 1000) % 100), ""thousand-"");
 
    // handles digit at hundreds places (if any)
    out += numToWords(((n / 100) % 10), ""hundred-"");
 
    // we need to add ""and"" if the number is more than hundred and contains digit at ten's or one's place
    if (n > 100 && n % 100)
        out += ""and-"";
 
    // handles digits at ones and tens places (if any)
    out += numToWords((n % 100), """");
    out = out.substr(0, out.size()-1); // to remove the last trailing ""-""
    return out;
}
int Solution::solve(const string A, const string B) {
    int n = stoi(A);
    string y = convertToWords(n);
    if(y.compare(B)==0)
        return 1;
    return 0;
}"
MAXSPPROD,https://www.interviewbit.com/problems/maxspprod/,N/A,Stacks And Queues,medium,"Problem Description
 
 

You are given an array A containing N integers. The special product of each ith integer in this array is defined as the product of the following:

 

 

LeftSpecialValue: For an index i, it is defined as the index j such that A[j]>A[i] and (i>j). If multiple A[j]'s are present in multiple positions, the LeftSpecialValue is the maximum value of j. Here LeftSpecialValue is the index j and not A[j].
RightSpecialValue: For an index i, it is defined as the index j such that A[j]>A[i] and (j>i). If multiple A[j]'s are present in multiple positions, the RightSpecialValue is the minimum value of j. Here RightSpecialValue is the index j and not A[j].
Write a program to find the maximum special product of any integer in the array. In other words you have to find the maximum for all i (0<i<n-1) of product of l and r such that l is the LeftSpecialValue and r is the RightSpecialValue of an index i. 

Note that the array A is zero indexed.

NOTE:  As the answer can be large, output your answer modulo 109 + 7.

 

 



Problem Constraints
1 <= N <= 105
 
1 <= A[i] <= 109



Input Format
First and only argument is an integer array A.



Output Format
Return an integer denoting the maximum special product of any integer.



Example Input
Input 1:

 A = [1, 4, 3, 4]
Input 2:

 A = [10, 7, 100]


Example Output
Output 1:

 3
Output 2:

 0


Example Explanation
Explanation 1:

 For A[2] = 3, LeftSpecialValue is 1 and RightSpecialValue is 3.
 So, the ans is 1*3 = 3.
 
Explanation 2:

 There is not any integer having maximum special product > 0. So, the ans is 0.","int Solution::maxSpecialProduct(vector<int> &A) {
	int n = A.size();
	vector<int> LeftSpecialValue(n,0),RightSpecialValue(n,0);
	stack<int> leftCalc;
	leftCalc.push(0);
	LeftSpecialValue[0]=0;
	for(int i=1;i<n;i++){
		while(!leftCalc.empty()){
			if(A[leftCalc.top()]>A[i]) break;
			leftCalc.pop();
		}
		LeftSpecialValue[i] = (leftCalc.empty())?0:leftCalc.top();
		leftCalc.push(i);
	}
	stack<int> rightCalc;
	rightCalc.push(n-1);
	RightSpecialValue[n-1]=0;
	for(int i=n-2;i>=0;i--){
		while(!rightCalc.empty()){
			if(A[rightCalc.top()]>A[i]) break;
			rightCalc.pop();
		}
		RightSpecialValue[i] = (rightCalc.empty())?0:rightCalc.top();
		rightCalc.push(i);
	}
	long long mx = -1;
	for(int i=0;i<n;i++){
		mx=max(mx,LeftSpecialValue[i]*1LL*RightSpecialValue[i]);
	}
	return mx%1000000007;
}"
Sample Question,https://www.interviewbit.com/problems/sample-question/,N/A,Math,easy,"Problem Description

Given two integers A and B. Find the sum of these integers as a modulo of 107.



Problem Constraints

0 <= A, B <= 109



Input Format

First argument is an integer A.

Second argument is an integer B.



Output Format

Return an integer denoting the sum of A and B as a modulo of 107.



Example Input

Input 1:

 A = 2
 B = 3
Input 2:

 A = 10000000
 B = 0


Example Output

Output 1:

 5
Output 2:

 0


Example Explanation

Explanation 1:

 (2 + 3) % 10000000 = 5
Explanation 2:

 (10000000 + 0) % 10000000 = 10000000 % 10000000 = 0","int Solution::solve(int A, int B) {
    int k=A+B;
    return k%10000000;
}"
Lines in a given range,https://www.interviewbit.com/problems/lines-in-a-given-range/,N/A,Basic Shell Commands,easy,"Write a bash script to print all the lines of the input which are in the given range.

The first line of the input contains two integers l and r separated by space.

You have to print all the lines of the file input which are in the range of [l, r].

Example:

Assume that the input has the following content.

10 15
Line 2
Line 3
Line 4
Line 5
Line 6
Line 7
Line 8
Line 9
Line 10
Line 11
Line 12
Line 13
Line 14
Line 15
Line 16
Line 17
Line 18
Line 19
Line 20
Your bash script should output the following

Line 10
Line 11
Line 12
Line 13
Line 14
Line 15","#!/bin/bash

l=$(cat $f| head -n 1 | awk '{print $1}')
r=$(cat $f| head -n 1 | awk '{print $2}')
cat input | head -n $r | tail -n $((r-l+1))"
Valid phone number,https://www.interviewbit.com/problems/valid-phone-number/,N/A,Basic Shell Commands,medium,"Given a text file input that contains list of phone numbers (one per line).

Write a bash script to print all valid phone numbers.You may assume that a valid phone number must appear in one of the following two formats:

(xxx) xxx-xxxx
xxx-xxx-xxxx
You may also assume each line in the text file must not contain leading or trailing white spaces.

Sample Input

987-123-4567
123 456 7890
(123) 456-7890
Sample output

987-123-4567
(123) 456-7890",cat input | grep -Eo '^(\([0-9]{3}\) ){1}[0-9]{3}-[0-9]{4}$|^([0-9]{3}-){2}[0-9]{4}$'
Find Fibonacci,https://www.interviewbit.com/problems/find-fibonacci/,N/A,Basic Shell Commands,easy,"You are given an input file called input.

The first line of the file contains a positive integer **T**, denoting number of test cases
Each of the next **T** lines contains a positive integer **N**
For each N, you are supposed to echo the Nth fibonacci number on a new line.

The first fibonacci number F1 = 1  

The first fibonacci number F2 = 1  

The nth fibonacci number Fn = Fn-1 + Fn-2 (n > 2)

Constraints:

1 <= T <= 50
1 <= N <= 50
Example:

Input file:
3
1
2
3

Output:
1
1
2","#!/bin/bash
# Incase you have to take input, please take it from file named 'input' (without quotes) [E.g. grep input OR cat input]
# Print you final output to console, do not redirect to another file
# E.g. Suppose the question is to print the content of a file.
#      Your solution should be 'cat input'(without quotes) instead of 'cat input > output'. That's it!
# Your code starts from here...

#!/bin/sh

eof=1   #denotes if end of file has been reached or not, 0 denotes end of file
while [ $eof -eq 1 ]
do
	eof=$((eof-1))  #we will be reading the whole file inside the loop
	read num_test_cases      #first line of input denotes test cases
	while [ $num_test_cases -gt 0 ]     #loop while num_test_cases is greater than 0
	do
		read n      #read the number N
		a=1     
		b=1
		c=$((a + b))
		if [ $n -eq 1 ]     #if n is 1, echo 1
		then
			echo 1
		elif [ $n -eq 2 ]	#if n is 2, echo 1
		then
			echo 1
		elif [ $n -eq 3 ]   #if n is 3, echo 2 (c is 2)
		then
			echo $c
		else
			n=$((n - 3))    #as n = 1, 2 and 3 is handled, we don't need to loop over them
			while [ $n -gt 0 ]
			do
				a=$((b))
				b=$((c))
				c=$((a + b))
				n=$((n - 1))
			done
			echo $c         #final answer is c
		fi      #end of id statements
		num_test_cases=$((num_test_cases - 1))        #decrement number of test cases
	done
done < input        #read from file ""input"""
Swap Forward And Backward Slash,https://www.interviewbit.com/problems/swap-forward-and-backward-slash/,N/A,Regex and Functions,medium,"Write a bash script to replace all the occurrences of / with \ and \ with / in a text file named input.

For simplicity sake, you may assume:

input contains only either forward slash / or backward slash \
Example:

Assume that input has the following content:

\\//
Your script should output the following:

//\\","#!/bin/bash

cat input | sed 's/\\/\#/g' | sed 's/\//\\/g' | sed 's/\#/\//g'"
Convert Integer To Roman Number,https://www.interviewbit.com/problems/convert-integer-to-roman-number/,N/A,Regex and Functions,medium,"Write a bash script to convert a given integer to its corresponding roman number.

For simplicity sake, you may assume:

input contains only one integer in each line
Every integer is in the range of [1, 4999] inclusive of 1 and 4999.
Example:

Assume that input has the following content:

1
2
3
4
5
Your script should output the following:

I
II
III
IV
V
Note:

Check out the Online Converter if you have any doubts.","#!/bin/bash

A[0]=""Z""
A[1]=""I""
A[2]=""II""
A[3]=""III""
A[4]=""IV""
A[5]=""V""
A[6]=""VI""
A[7]=""VII""
A[8]=""VIII""
A[9]=""IX""

B[0]=""Z""
B[1]=""X""
B[2]=""XX""
B[3]=""XXX""
B[4]=""XL""
B[5]=""L""
B[6]=""LX""
B[7]=""LXX""
B[8]=""LXXX""
B[9]=""XC""

C[0]=""Z""
C[1]=""C""
C[2]=""CC""
C[3]=""CCC""
C[4]=""CD""
C[5]=""D""
C[6]=""DC""
C[7]=""DCC""
C[8]=""DCCC""
C[9]=""CM""

D[0]=""Z""
D[1]=""M""
D[2]=""MM""
D[3]=""MMM""
D[4]=""MMMM""

while read num
do
  	if [ $num -ge 1000 ]
  	then
  		th=`expr $num / 1000`
  		echo -n ""${D[$th]}""
  	fi

  	num=`expr $num % 1000`
  	
  	if [ $num -ge 100 ]
  	then
  		h=`expr $num / 100`
  		echo -n ""${C[$h]}""
  	fi

  	num=`expr $num % 100`

  	if [ $num -ge 10 ]
  	then
  		t=`expr $num / 10`
  		echo -n ""${B[$t]}""
  	fi

  	num=`expr $num % 10`
  	if [ $num -ge 1 ]
  	then
  		echo -n ""${A[$num]}""
  	fi
  	echo
done < input"
Transform CSV,https://www.interviewbit.com/problems/transform-csv/,N/A,Regex and Functions,medium,"Given a csv file(with , as a delimiter) named input with the following fields:

FirstName
LastName
Address
City
CountryCode
Email
PhoneNumber
Write a bash script to combine both CountryCode and PhoneNumber with a - and add a + before country code and remove country codes from the csv file

Example:

Assume that input has the following content:

Lotty,Kilner,08 Boyd Place,Jiangqiao,04,lkilner0@epa.gov,433-447-7966
Benoite,Ducket,9 Harper Alley,Tenenkou,22,bducket1@friendfeed.com,724-995-7769
Your script should output the following:

Lotty,Kilner,08 Boyd Place,Jiangqiao,lkilner0@epa.gov,+04-433-447-7966
Benoite,Ducket,9 Harper Alley,Tenenkou,bducket1@friendfeed.com,+22-724-995-7769
Note:

Note that the given csv file does not contain headers i.e., only data is present.","#!/bin/bash

while IFS=',' read -r f1 f2 f3 f4 f5 f6 f7
do
echo ""$f1,$f2,$f3,$f4,$f6,+$f5-$f7""
done < input"
Sort by Frequency,https://www.interviewbit.com/problems/sort-by-frequency/,N/A,Regex and Functions,medium,"In the given file named input, find the frequency of all the words and print as per the following format.

The first column of each line of the output should be the frequency of the word followed by all the words of that frequency arranged in lexicographical order separated with space “ ”

Sort the words in the ascending order of frequency.




For simplicity, assume that

Words are case sensitive, i.e. The and the are treated as different words.



Example:

Assume that input has following content:

the day is sunny 
it is the sunny day
we can go out
Your script should output the following, sorted by the ascending frequency:

1 can go it out we
2 day is sunny the","#!/bin/bash
# Incase you have to take input, please take it from file named 'input' (without quotes) [E.g. grep input OR cat input]
# Print you final output to console, do not redirect to another file
# E.g. Suppose the question is to print the content of a file.
#      Your solution should be 'cat input'(without quotes) instead of 'cat input > output'. That's it!
# Your code starts from here...

cat input| tr -s "" "" ""\n"" | sort | uniq -c | tr -s [:space:] | sort | awk -F' ' '$1==last {printf "" %s"",$2; next} NR>1 {print """";} {last=$1; printf ""%s"",$0;} END{print """";}'"
Valid Email Address,https://www.interviewbit.com/problems/valid-email-address/,N/A,Regex and Functions,medium,"Write a bash script that finds all the invalid email addresses.

For simplicity, assume that a vaild email addresses has the following rules-

Email should be of the form local@domain.com
There can only be alphanumberic characters in the local part email address.
The following characters are valid in the local part of the email as long as they are not the first character.

  -, _, +, .

Email address can not start with a number.
Domain name can only contain alphanumeric characters and -.
com part can have atmost one ., for e.g. co.uk or co.in is valid but as.df.gh is invalid
Example:

Assume that input has the following content:

abc@example.co.uk
abc@example.com
abc<>@example.com
abc@example@gmail.com
Your script should output the following:

abc<>@example.com
abc@example@gmail.com","cat input | grep -xv ""^[A-Za-z][-_\.\+A-Za-z0-9]*[@][-A-Za-z0-9]*[\.][A-Za-z]*"" | grep -xv ""^[A-Za-z][-_\.\+A-Za-z0-9]*[@][-A-Za-z0-9]*[\.][A-Za-z]*[\.][A-Za-z]*"""
Remove Punctuations,https://www.interviewbit.com/problems/remove-punctuations/,N/A,Basic Shell Commands,medium,"Write a bash script that removes all the punctuations in the given file named input

For this question, assume that all of the following symbols are punctuations:

! @ # $ % ^ & * ( ) _ - + = { } [ ] ; : ' "" ` / > ? . , < ~ | \

Example:

Assume that input has the following content:

This's the sunny day.
It is the sunny day, we can go out.
Your script should output the following:

Thiss the sunny day
It is the sunny day we can go out","#!/bin/bash
# Incase you have to take input, please take it from file named 'input' (without quotes) [E.g. grep input OR cat input]
# Print you final output to console, do not redirect to another file
# E.g. Suppose the question is to print the content of a file.
#      Your solution should be 'cat input'(without quotes) instead of 'cat input > output'. That's it!
# Your code starts from here...
cat input | tr -d '[:punct:]'"
Grep,https://www.interviewbit.com/problems/grep/,N/A,Basic Shell Commands,medium,"The following command prints all the lines of the file input which contains a number

cat input | grep '[0-9]*'

Example:

Assume that the input has the following content:

axes12
w143th
qwer
Then the given command prints the following ouput:

axes12
w143th


Now change the command slighly so that it prints only the number part of the lines.




Example:

Assume that the input has the following content:

axes12
w143th
qwer
Then your new command should ouput the following content

12
143",cat input | grep -o '[0-9]*'
Grep Log,https://www.interviewbit.com/problems/grep-log/,N/A,Basic Shell Commands,medium,"Given a log file named input. You have to write a bash script which prints all the lines which contains mysql commands.

Note

Assume that all the mysql commands start with mysql::.
Example:

Assume that the input has the following content:

mysql:: SELECT * FROM courses;
rails:: Course.all
mysql:: SELECT id FROM courses;
rails:: Course.pluck(:id)
Then your bash script should output the following:

mysql:: SELECT * FROM courses;
mysql:: SELECT id FROM courses;
Our engineers were able to write this much code, can you complete it for us?

cat input | grep ",cat input | grep 'mysql::'
Tenth Line,https://www.interviewbit.com/problems/tenth-line/,N/A,Basic Shell Commands,medium,"The following command prints the top 10 lines of file named input

cat input | head -n 10

The following command prints the bottom 10 lines of file named input

cat input | tail -n 10

Can you somehow use the above information to print the 10th line of the file named input ?

Example:

Assume that the input contains the following:

Line 1
Line 2
Line 3
Line 4
Line 5
Line 6
Line 7
Line 8
Line 9
Line 10
Line 11
Line 12
Line 13
Line 14
Line 15
Your bash script should output the following:

Line 10","#!/bin/bash
# Incase you have to take input, please take it from file named 'input' (without quotes) [e.g. cat input]
# Print your final output to console. Do not redirect to another file.
# E.g. Suppose the question is to print the content of a file.
#      Your solution should be 'cat input'(without quotes) instead of 'cat input > output'. That's it!
# Your code starts from here...
cat input | head -n 10 | tail -n 1"
Amazing Subarrays,https://www.interviewbit.com/problems/amazing-subarrays/,N/A,Strings,easy,"Problem Description
 
 

You are given a string A, and you have to find all the amazing substrings of A.
An amazing Substring is one that starts with a vowel (a, e, i, o, u, A, E, I, O, U).
Note: Take the mod of the answer with 10003.


Problem Constraints
1 <= |S| <= 106
S can have special characters


Input Format
Only argument given is string S.


Output Format
Return a single integer X mod 10003, where X is the number of Amazing Substrings in the given string.


Example Input
ABEC


Example Output
6


Example Explanation
Amazing substrings of the given string are :
1. A
2. AB
3. ABE
4. ABEC
5. E
6. EC
here the number of substrings is 6 and 6 % 10003 = 6.","int Solution::solve(string s) {
    
    map<char, bool> m;
    m['a'] = m['e'] = m['i'] = m['o'] = m['u'] = 1;
    m['A'] = m['E'] = m['I'] = m['O'] = m['U'] = 1;
    
    int n = s.length();
    long long ans = 0;
    for(int i = 0; i < n; i += 1) {
        if(m[s[i]])
            ans += (n - i);
    }
    return ans % 10003;
}"
Partitions,https://www.interviewbit.com/problems/partitions/,N/A,Arrays,medium,"Problem Description

You are given a 1D integer array B containing A integers.

Count the number of ways to split all the elements of the array into 3 contiguous parts so that the sum of elements in each part is the same.

Such that : sum(B[1],..B[i]) = sum(B[i+1],...B[j]) = sum(B[j+1],...B[n]) 



Problem Constraints
1 <= A <= 105

-109 <= B[i] <= 109



Input Format
First argument is an integer A.

Second argument is an 1D integer array B of size A.



Output Format
Return a single integer denoting the number of ways to split the array B into three parts with the same sum.



Example Input
Input 1:

 A = 5
 B = [1, 2, 3, 0, 3]
Input 2:

 A = 4
 B = [0, 1, -1, 0]


Example Output
Output 1:

 2
Output 2:

 1


Example Explanation
Explanation 1:

 There are no 2 ways to make partitions -
 1. (1,2)+(3)+(0,3).
 2. (1,2)+(3,0)+(3).
Explanation 2:

 There is only 1 way to make partition -
 1. (0)+(-1,1)+(0).","// Function to count the no of ways 
int countways(int n,vector<int>& a) 
{
    int pre[n];
    pre[0]=a[0];
    for(int i=1;i<n;i++) pre[i]=pre[i-1]+a[i];
    if(pre[n-1]%3) return 0;
    int req=pre[n-1]/3;
    int cnt=0;
    int ans=0;
    for(int i=0;i<n-1;i++)
    {
        if(pre[i]==2*req) ans+=cnt;
        cnt+=(pre[i]==req);
    }
    return ans;
} 
int Solution::solve(int A, vector<int> &B) {
    assert(A>=1 && A<=100000 && A==B.size());
    for(int a:B)assert(a>=-1000000000 && a<=1000000000);
    return countways(A,B);
}"
Neutral Reviewers,https://www.interviewbit.com/problems/neutral-reviewers/,N/A,SQL Programming,easy,"Write a SQL Query to find the name of all reviewers who have rated their ratings with a NULL value.

Output Schema:

reviewer_name
NOTE: Output column name has to match the given output schema.

Example Output:

reviewer_name
MaxPlank
NeilsBohr
Schrodinger
Schema Design:

Schema Description","select reviewer_name 
from reviewers ,ratings 
where (ratings.reviewer_id=reviewers.reviewer_id and ratings.reviewer_stars is NULL)"
Movie Character,https://www.interviewbit.com/problems/movie-character/,N/A,SQL Programming,medium,"Write a SQL Query to find the movie_title and name of director (first and last names combined) who directed a movie that casted a role as ‘SeanMaguire’.

Output Schema:

director_name,movie_title
NOTE:

Output column name has to match the given output schema.
Any name is the concatenation(without any delimiter) of first and last name if present
(E.g. if director_first_name is ‘Alfred’ and director_last_name is ‘Hitchcock’ then director_name is ‘AlfredHitchcock’)
Example Output:

director_name,movie_title
AlfredHitchcock,Vertigo
Schema Design:

Schema Description",N/A
Short Films,https://www.interviewbit.com/problems/short-films/,N/A,SQL Programming,medium,"Write a SQL Query to find those lowest duration movies along with the year, director’s name(first and last name combined), actor’s name(first and last name combined) and his/her role in that production.

Output Schema:

movie_title,movie_year,director_name,actor_name,role
NOTE:

Output column name has to match the given output schema.
Any name is the concatenation(without any delimiter) of first and last name if present
(E.g. if director_first_name is ‘Alfred’ and director_last_name is ‘Hitchcock’ then director_name is ‘AlfredHitchcock’)
Example Output:

movie_title,movie_year,director_name,actor_name,role
Vertigo,1958,AlfredHitchcock,JamesStewart,JohnFerguson
Schema Design:

Schema Description",N/A
Actors and their Movies,https://www.interviewbit.com/problems/actors-and-their-movies/,N/A,SQL Programming,medium,"Write a SQL Query to find the name of those movies where one or more actors acted in two or more movies.

Output Schema:

movie_title
NOTE:

Output column name has to match the given output schema.
Any name is the concatenation(without any delimiter) of first and last name if present
(E.g. if director_first_name is ‘Alfred’ and director_last_name is ‘Hitchcock’ then director_name is ‘AlfredHitchcock’)
Example Output:

movie_title
Vertigo
Schema Design:

Schema Description",N/A
Stringoholics,http://interviewbit.com/problems/stringoholics/,N/A,Strings,hard,"Problem Description
 
 

You are given an array A consisting of strings made up of the letters 'a' and 'b' only.
Each string goes through a number of operations, where:

1.  At time 1, you circularly rotate each string by 1 letter.
2.  At time 2, you circularly rotate the new rotated strings by 2 letters.
3.  At time 3, you circularly rotate the new rotated strings by 3 letters.
4.  At time i, you circularly rotate the new rotated strings by i % length(string) letters.


Eg: String is ""abaa""




 At time 1, string is ""baaa"", as 1 letter is circularly rotated to the back

 At time 2, string is ""aaba"", as 2 letters of the string ""baaa"" is circularly rotated to the back

 At time 3, string is ""aaab"", as 3 letters of the string ""aaba"" is circularly rotated to the back

 At time 4, string is again ""aaab"", as 4 letters of the string ""aaab"" is circularly rotated to the back

 At time 5, string is ""aaba"", as 1 letters of the string ""aaab"" is circularly rotated to the back
After some units of time, a string becomes equal to its original self.
Once a string becomes equal to itself, it's letters start to rotate from the first letter again (process resets). So, if a string takes t time to get back to the original, at time t+1 one letter will be rotated and the string will be its original self at 2t time.
You have to find the minimum time, where maximum number of strings are equal to their original self.
As this time can be very large, give the answer modulo 109+7.

Note: Your solution will run on multiple test cases so do clear global variables after using them.



Problem Constraints
1 <= |A| <= 100


Input Format
A: Array of strings.



Output Format
Minimum time, where maximum number of strings are equal to their original self.



Example Input
Input 1:

  A: [a, ababa, aba]
Input 2:

  A : [a, aa]


Example Output
Output 1:

  4
Output 2:

  1


Example Explanation
Explanation 1:

  String 'a' is it's original self at time 1, 2, 3 and 4.
String 'ababa' is it's original self only at time 4. (ababa => babaa => baaba => babaa => ababa)
String 'aba' is it's original self at time 2 and 4. (aba => baa => aba)
Hence, 3 strings are their original self at time 4.
Explanation 2:

  Both strings are their original self at time 1.","#define pb push_back
#define mp make_pair
#define fi first.first
#define se first.second
#define MOD 1000000007
#define ms(s, n) memset(s, n, sizeof(s))
#define prec(n) fixed<<setprecision(n)
#define eps 0.000001
#define all(v) v.begin(), v.end()
#define bolt ios::sync_with_stdio(0)
#define forr(i,p,n) for(ll i=p;i<n;i++)
typedef long long ll;

ll mult(ll a,ll b, ll p=MOD){return ((a%p)*(b%p))%p;}
ll add(ll a, ll b, ll p=MOD){return (a%p + b%p)%p;}
ll fpow(ll n, ll k, ll p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n%p; n = n * n%p;} return r;}
ll inv(ll a, ll p = MOD) {return fpow(a, p - 2, p);}

ll com(string s){
	ll lps[100003]={0};
    lps[0]=0;
    ll len=0;
    ll p=1;
    while(p<s.length()){
        if(s[p]==s[len]){
            len++;
            lps[p]=len;
            p++;
        }else{
            if(len!=0){
                len=lps[len-1];
            }else{
                lps[p]=0;
                p++;
            }
        }
    }
    len=lps[s.length()-1];
    if(s.length()%(s.length()-len)==0){
		return s.length()-len;
    }else return s.length();
}

ll spf[300003];

void spff(){
	spf[1] = 1;
    for (ll i=2;i<300003;i++)
    	spf[i] = i;

    for (ll i=4; i<300003; i+=2)
        spf[i] = 2;

    for (ll i=3; i*i<300003; i++)
    {
        if (spf[i] == i)
        {
            for (ll j=i*i; j<300003; j+=i)
                if (spf[j]==j)
                    spf[j] = i;
        }
    }
}

int Solution::solve(vector<string> &s) {
    spff();
    ll n=s.size();
    assert(n >= 1 && n <= 100); 
	ll maxx=0;
    ll res[200003]={0};
	for(ll i=0;i<n;i++){
		ll len=com(s[i]);
        for(ll i=1;;i++){
            if(((i*(i+1))/2)%len==0){
				ll temp=i;
				while(temp!=1){
					ll r=spf[temp];
					ll cnt=0;
					while(temp%r==0){
						cnt++;
						temp/=r;
					}
					res[r]=max(res[r],cnt);
				}
				break;
            }
        }
	}
	ll ans=1;
	for(ll i=1;i<=200000;i++){
		ans=mult(ans,fpow(i,res[i]));
	}
	return ans;
}"
Simple Queries,https://www.interviewbit.com/problems/simple-queries/,N/A,Binary Search,medium,"Problem Description
 
 

You are given an array A having N integers.

You have to perform the following steps in a given order.

1) generate all subarrays of A.

2) take the maximum element from each subarray of A and insert it into a new array G.

3) replace every element of G with the product of their divisors mod 1e9 + 7.

4) sort G in descending order

You now need to perform Q queries

In each query, you are given an integer K, where you have to find the Kth element in G.

NOTE : Your solution will run on multiple test cases so do clear global variables after using them.



Problem Constraints
1 <= N <= 1e5

1 <= A[i] <= 1e5

1 <= Q <= 1e5

1 <= k <= (N * (N + 1))/2 



Input Format
The first argument given is an Array A, having N integers.

The second argument given is an Array B, where B[i] is the ith query.



Output Format
Return an Array X, where X[i] will have the answer for the ith query.



Example Input
Input 1:

 A = [1, 2, 4]
B = [1, 2, 3, 4, 5, 6]
Input 2:

 A = [1, 3]
B = [1]


Example Output
Output 1:

 [8, 8, 8, 2, 2, 1]
Output 2:

 [3]


Example Explanation
Explanation 1:

 subarrays of A    maximum element
[1] 1
[1, 2] 2
[1, 2, 4] 4
[2] 2
[2, 4] 4
[4] 4
original
G = [1, 2, 4, 2, 4, 4]

after changing every element of G with product of their divisors
G = [1, 2, 8, 2, 8, 8]

after sorting G in descending order
G = [8, 8, 8, 2, 2, 1]



Explanation 2:

 Just perform given query.
","#define ll long long int
const int mn = 1e5 + 5;
const ll mod = 1e9 + 7;
ll power(ll a, ll g) {ll ag = 1; while(g){if(g&1) ag = (ag%mod * a%mod)%mod; a = (a%mod * a%mod)%mod; g >>= 1;} return ag;}

ll p[mn];

void pre_compute_product_of_divisors() {
    p[0] = 0; p[1] = 1;
    if(p[2] != 0) return;
    for(ll i = 2; i < mn; i += 1) {
        if(p[i] == 0) {
            p[i] = 2;
            for(ll j = i+i; j < mn; j += i) {
                if(p[j] == 0) p[j] = 1;
                ll tmp = j;
                ll cnt = 0;
                while(tmp % i == 0) {
                    cnt += 1;
                    tmp /= i;
                }
                p[j] *= (cnt + 1);
            }
        }
    }
    for(int i = 2; i < mn; i += 1) {
        p[i] = (power(i, p[i]/2)%mod * (p[i]&1 ? (ll)sqrt(i) : 1)%mod)%mod;
    }
}

// comparator to sort in descending order
bool compare(pair<int, long long int> a, pair<int, long long int> g) {
    if(a.first == g.first)
        return a.second < g.second;
    else
        return a.first > g.first;
}

vector<int> Solution::solve(vector<int> &A, vector<int> &B) {
    
    pre_compute_product_of_divisors();
    
    int n = (int)A.size();
    // create arrays to store length of longest segment in which ith element is greater
    long long int l[n], r[n], lr[n];
    // initialize elements array equal to 1.
    for(int i = 0; i < n; i += 1) {
        l[i] = r[i] = 1;
    }
    // find next greater element to the left of the current element
    for(int i = 1; i < n; i += 1) {
        int last = i-1;
        while(last >= 0 and A[i] > A[last]) {
            l[i] += l[last];
            last -= l[last];
        }
    }
    // find next greater element to the right of the current element
    for(int i = n-2; i >= 0; i -= 1) {
        int last = i+1;
        while(last < n and A[i] >= A[last]) {
            r[i] += r[last];
            last += r[last];
        }
    }
    // The number of subarrays in which current element will be the greater
    for(int i = 0; i < n; i += 1) {
        lr[i] = l[i] * r[i];
    }
    // Sort elements in descending order according to there value
    pair<int, long long int> ag[n];
    for(int i = 0; i < n; i += 1) {
        ag[i] = {p[A[i]], lr[i]};
    }
    sort(ag, ag + n, compare);

    // Take Prefix Sum of frequencies of elements
    long long pre[n];
    pre[0] = ag[0].second;
    for(int i = 1; i < n; i += 1) {
        pre[i] = pre[i-1] + ag[i].second;
    }
    
    // do Binary search for each query
    int q = (int)B.size();
    vector<int> ans(q);
    for(int i = 0; i < q; i += 1) {
        auto id = lower_bound(pre, pre + n, B[i]) - pre;
        ans[i] = ag[id].first;
    }
    // return the ans array
    return ans;
}"
City Tour,https://www.interviewbit.com/problems/city-tour/,N/A,Math,hard,"Problem Description
 
 

There are A cities numbered from 1 to A. You have already visited M cities, the indices of which are given in an array B of M integers.

 

If a city with index i is visited, you can visit either the city with index i-1 (i >= 2) or the city with index i+1 (i < A) if they are not already visited. Eg: if N = 5 and array M consists of [3, 4], then in the first level of moves, you can either visit 2 or 5.

You keep visiting cities in this fashion until all the cities are not visited. Find the number of ways in which you can visit all the cities modulo 10^9+7. 



Problem Constraints
1 <= A <= 1000
1 <= M <= A
1 <= B[i] <= A


Input Format
The 1st argument given is an integer A, i.e total number of cities.
The 2nd argument given is an integer array B, where B[i] denotes ith city you already visited.


Output Format
Return an Integer X % (1e9 + 7), the number of ways in which you can visit all the cities.


Example Input
A = 5
B = [2, 5]


Example Output
6


Example Explanation
All possible ways to visit remaining cities are :
1. 1 -> 3 -> 4
2. 1 -> 4 -> 3
3. 3 -> 1 -> 4
4. 3 -> 4 -> 1
5. 4 -> 1 -> 3
6. 4 -> 3 -> 1","typedef long long int lint;

const lint modulo=1000000007;
const int tope=1001;

lint combi[tope][tope];
lint expo[tope];
bool flag;

void precompute() {
    if(flag) return;
    flag = 1;
    for(int n = 0; n < tope; n += 1) {
        for(int k = 0; k <= n; k += 1) {
	        if (k == 0 or k == n) {
	            combi[n][k] = 1;
	        }
	        else {
	            combi[n][k] = (combi[n-1][k] + combi[n-1][k-1]) % modulo;
	        }
        }
    }
    expo[0] = 1;
    for (int i = 1; i < tope; i += 1) {
        expo[i] = (2 * expo[i-1]) % modulo;
    }
}

int Solution::solve(int n, vector<int> &v) {
    precompute();
    int m = v.size();
    lint ans=1;
    sort(v.begin(), v.end());
    int ant = v[0]-1;
    for (int i = 1; i < m; i += 1) {
        int k = v[i] - v[i-1] - 1;
        if (k > 0) {
          lint act = expo[k-1];
          ans = ((act * ans)%modulo * combi[ant+k][k]%modulo) % modulo;
          ant += k;
        }
    }
    ans = (ans * combi[ant+n-v[m-1]][n-v[m-1]])%modulo;
    return (int)ans;
}"
Multiple left rotations of the array,https://www.interviewbit.com/problems/multiple-left-rotations-of-the-array/,N/A,Arrays,easy,"Problem Description
 
 

Given an array of integers A and multiple values in B, which represents the number of times array A needs to be left rotated.

Find the rotated array for each value and return the result in the from of a matrix where ith row represents the rotated array for the ith value in B.



Problem Constraints
1 <= |A|, |B| <= 2000
-109 <= A[i] <= 109
0 <= B[i] <= 2000


Input Format
The first argument given is the integer array A.
The second argument given is the integer array B.


Output Format
Return the resultant matrix.


Example Input
Input 1:
 
    A = [1, 2, 3, 4, 5]
    B = [2, 3]
Input 2:


    A = [5, 17, 100, 11]
    B = [1]


Example Output
Output 1:
 [ [3, 4, 5, 1, 2]
   [4, 5, 1, 2, 3] ]
Output 2:
[ [17, 100, 11, 5] ]


Example Explanation
for input 1 -> B[0] = 2 which requires 2 times left rotations

     1: [2, 3, 4, 5, 1]

     2: [3, 4, 5, 1, 2]

B[1] = 3 which requires 3 times left rotation 

     1: [2, 3, 4, 5, 1]

     2: [3, 4, 5, 1, 2]

     2: [4, 5, 1, 2, 3]

","vector<vector<int> > Solution::solve(vector<int> &a, vector<int> &b) {
    int n = a.size(), m = b.size();
    vector<vector<int>> ans(m, vector<int>(n));
    for(int i = 0; i < m; i++) {
        for(int j = 0; j < n; j++)  ans[i][j] = a[(b[i] + j) % n];
    }
    return ans;
}"
Find a peak element,https://www.interviewbit.com/problems/find-a-peak-element/,Google,Binary Search,medium,"Given an array of integers A, find and return the peak element in it.

An array element is peak if it is NOT smaller than its neighbors. 

For corner elements, we need to consider only one neighbor. 

For example, for input array {5, 10, 20, 15}, 20 is the only peak element.

Following corner cases give better idea about the problem.

1) If input array is sorted in strictly increasing order, the last element is always a peak element. 
For example, 5 is peak element in {1, 2, 3, 4, 5}.
2) If input array is sorted in strictly decreasing order, the first element is always a peak element. 
10 is the peak element in {10, 9, 8, 7, 6}.
Note: It is guranteed that the answer is unique.




Input Format

The only argument given is the integer array A.
Output Format

Return the peak element.
Constraints

1 <= length of the array <= 100000
1 <= A[i] <= 10^9 
For Example

Input 1:
    A = [1, 2, 3, 4, 5]
Output 1:
    5

Input 2:
    A = [5, 17, 100, 11]
Output 2:
    100","int Solution::solve(vector<int> &a) {
    int n = a.size();
    int l = 0, r = n - 1, ans = -1;
    while(l <= r) {
        int m = (l + r) >> 1;
        if((m == 0 || a[m] >= a[m-1]) && (m == n-1 || a[m] >= a[m+1])) {
            ans = a[m]; break;
        }
        if((m == 0 || a[m] >= a[m-1])) {
            l = m+1;
        } else {
            r = m-1;
        }
    }
    return ans;
}"
First non-repeating character in a stream of characters,https://www.interviewbit.com/problems/first-non-repeating-character-in-a-stream-of-characters/,"Amazon, Facebook",Stacks And Queues,medium,"Problem Description

Given a string A denoting a stream of lowercase alphabets. You have to make new string B.

B is formed such that we have to find first non-repeating character each time a character is inserted to the stream and append it at the end to B. If no non-repeating character is found then append '#' at the end of B.



Problem Constraints
1 <= length of the string <= 100000



Input Format
The only argument given is string A.



Output Format
Return a string B after processing the stream of lowercase alphabets A.



Example Input
Input 1:

 A = ""abadbc""
Input 2:

 A = ""abcabc""


Example Output
Output 1:

 ""aabbdd""
Output 2:

 ""aaabc#""


Example Explanation
Explanation 1:

    ""a""      -   first non repeating character 'a'
    ""ab""     -   first non repeating character 'a'
    ""aba""    -   first non repeating character 'b'
    ""abad""   -   first non repeating character 'b'
    ""abadb""  -   first non repeating character 'd'
    ""abadbc"" -   first non repeating character 'd'
Explanation 2:

    ""a""      -   first non repeating character 'a'
    ""ab""     -   first non repeating character 'a'
    ""abc""    -   first non repeating character 'a'
    ""abca""   -   first non repeating character 'b'
    ""abcab""  -   first non repeating character 'c'
    ""abcabc"" -   no non repeating character so '#'","class Solution: 
    def solve(self, A):
        st = []
        d = {}
        ans = ''
        for i in A:
            if i in d:
                if i in st:
                    st.remove(i)
            else:
                st.append(i)
                d[i] = 0
            if st:
                ans += st[0]
            else:
                ans +='#'
        return ans"
Longest Common Subsequence,https://www.interviewbit.com/problems/longest-common-subsequence/,N/A,Dynamic Programming,easy,"Problem Description

Given two strings A and B. Find the longest common sequence ( A sequence which does not need to be contiguous), which is common in both the strings.

You need to return the length of such longest common subsequence.



Problem Constraints
1 <= |A|, |B| <= 1005



Input Format
First argument is an string A.

Second argument is an string B.



Output Format
Return the length of such longest common subsequence between string A and string B.



Example Input
Input 1:

 A = ""abbcdgf""
 B = ""bbadcgf""


Example Output
Output 1:

 5


Example Explanation
Explanation 1:

 The longest common subsequence is ""bbcgf"", which has a length of 5","int Solution::solve(string A, string B) {
   int m = A.size(), n = B.size();
   int L[m+1][n+1]; 
   int i, j; 
   
   for (i=0; i<=m; i++) 
   { 
     for (j=0; j<=n; j++) 
     { 
       if (i == 0 || j == 0) 
         L[i][j] = 0; 
   
       else if (A[i-1] == B[j-1]) 
         L[i][j] = L[i-1][j-1] + 1; 
   
       else
         L[i][j] = max(L[i-1][j], L[i][j-1]); 
     } 
   } 
     
   return L[m][n]; 
}"
Longest Palindromic Subsequence,https://www.interviewbit.com/problems/longest-palindromic-subsequence/,Linkedin,Dynamic Programming,medium,"Problem Description
 
 

Given a string A, find the common palindromic sequence ( A sequence which does not need to be contiguous and is a pallindrome), which is common in itself.

You need to return the length of longest palindromic subsequence in A.

NOTE:

Your code will be run on multiple test cases (<=10). Try to come up with an optimised solution.


Problem Constraints
 1 <= |A| <= 1005



Input Format
First and only argument is an string A.



Output Format
Return a integer denoting the length of longest palindromic subsequence in A.



Example Input
Input 1:

 A = ""bebeeed""


Example Output
Output 1:

 4


Example Explanation
Explanation 1:

 The longest common pallindromic subsequence is ""eeee"", which has a length of 4","int Solution::solve(string A) {
  int n = A.size();
  assert(n>=1 && n<=1005);
  for(char a:A)
    assert(a>='a' && a<='z');
  int i, j, cl;
  int L[n][n]; // Create a table to store results of subproblems 

  // Strings of length 1 are palindrome of lentgh 1 
  for (i = 0; i < n; i++)
    L[i][i] = 1;

  for (cl = 2; cl <= n; cl++) {
    for (i = 0; i < n - cl + 1; i++) {
      j = i + cl - 1;
      if (A[i] == A[j] && cl == 2)
        L[i][j] = 2;
      else if (A[i] == A[j])
        L[i][j] = L[i + 1][j - 1] + 2;
      else
        L[i][j] = max(L[i][j - 1], L[i + 1][j]);
    }
  }

  return L[0][n - 1];
}"
Find Rectangle in binary matrix,https://www.interviewbit.com/problems/find-rectangle-in-binary-matrix/,N/A,Heaps And Maps,easy,"Problem Description

Given a binary matrix of integers A of size N x M consisting of only 0 or 1. you need to check whether there exists a square or rectangle in a square whose all four corners are 1. All four corners need to be distinct.

If there exists such rectangle or square return 1, else return 0.

Input Format

The first argument given is the integer matrix A.
Output Format

Return 1 if there exists such rectangle/square whose all four corners are 1 else return 0.
Constraints

1 <= N, M <= 200
0 <= A[i] <= 1
For Example

Input 1:
    A = [   [0, 1, 1]
            [0, 1, 1]
            [0, 1, 0]   ]


Output 1: 1



Explanation 1:
[ [1, 1]
  [1, 1] ]
There exists a square whose all corners are 1.



Input 2:
    A = [   [0, 1, 1]
            [0, 0, 1]
            [0, 1, 0]   ]



Output 2: 0

","int isRectangle(const vector<vector<int> >& matrix) {
    int rows = matrix.size();
    if (rows == 0)
        return 0;

    int columns = matrix[0].size();
    unordered_map<int, unordered_set<int> > table;

    for (int i = 0; i < rows; ++i) {
     for (int j = 0; j < columns - 1; ++j) {
        for (int k = j + 1; k < columns; ++k) {
          if (matrix[i][j] == 1 && matrix[i][k] == 1) {
            if (table.find(j) != table.end() && table[j].find(k) != table[j].end())
                        return 1;
            if (table.find(k) != table.end() && table[k].find(j) != table[k].end())
                        return 1;
            table[j].insert(k);
            table[k].insert(j);
          }
        }
      }
    }
    return 0;
}


int Solution::solve(const vector<vector<int> > &A) {
    return isRectangle(A);
}"
Best Time to Buy and Sell Stock atmost B times,https://www.interviewbit.com/problems/best-time-to-buy-and-sell-stock-atmost-b-times/,N/A,Dynamic Programming,medium,"Problem Description

Given an array of integers A of size N in which ith element is the price of the stock on day i.

You can complete atmost B transactions.

Find the maximum profit you can achieve.

NOTE: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).



Problem Constraints
1 <= N <= 500

0 <= A[i] <= 106

0 <= B <= 109



Input Format
The First argument given is the integer array A.

The Second argument is integer B.



Output Format
Return the maximum profit you can achieve by doing atmost B transactions.



Example Input
Input 1:

 A = [2, 4, 1]
 B = 2
Input 2:

 A = [3, 2, 6, 5, 0, 3]
 B = 2


Example Output
Output 1:

 2
Output 2:

 7


Example Explanation
Explanation 1:

 Buy on day 1 (price = 2) and sell on day 2 (price = 4), 
 Profit = 4 - 2 = 2
Explanation 2:

 Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6 - 2 = 4.
 Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3 - 0 = 3.","int maxProfit(vector < int > & prices, int k) {
  if (k == 0 || prices.size() == 0)
    return 0;
  int max_profit = 0;
  if (k >= prices.size() / 2) {
    for (int i = 1; i < prices.size(); i++) {
      max_profit += max(prices[i] - prices[i - 1], 0);
    }
    return max_profit;
  }
  vector < vector < int >> dp(k + 1, vector < int > (prices.size() + 1, 0));

  for (int i = 1; i <= k; i++) {
    int maxDiff = -prices[0];
    for (int j = 2; j <= prices.size(); j++) {
      dp[i][j] = max(dp[i][j - 1], prices[j - 1] + maxDiff);
      maxDiff = max(maxDiff, dp[i - 1][j] - prices[j - 1]);
    }
  }
  return dp[k][prices.size()];
}

int Solution::solve(vector < int > & A, int B) {
    assert(A.size()>=1 && A.size()<=500);
    for(int a:A)
        assert(a>=0 && a<=1e6);
    assert(B>=0 && B<=1e9);
  return maxProfit(A, B);
}"
Meeting rooms,http://interviewbit.com/problems/meeting-rooms/,"Amazon, Apple, Fab, Facebook, Microsoft",Greedy Algorithm,medium,"Problem Description
 
 

Given an 2D integer array A of size N x 2 denoting time intervals of different meetings.

 

Where:

 

A[i][0] = start time of the ith meeting.
A[i][1] = end time of the ith meeting.
 

Find the minimum number of conference rooms required so that all meetings can be done.

Note :- If a meeting ends at time t, another meeting starting at time t can use the same conference room

 



Problem Constraints
1 <= N <= 105

 

0 <= A[i][0] < A[i][1] <= 2 * 109

 



Input Format
The only argument given is the matrix A.



Output Format
Return the minimum number of conference rooms required so that all meetings can be done.



Example Input
Input 1:

 A = [      [0, 30]
            [5, 10]
            [15, 20]
     ]

Input 2:

 A =  [     [1, 18]
            [18, 23]
            [15, 29]
            [4, 15]
            [2, 11]
            [5, 13]
      ]


Example Output
Output 1:

 2
Output 2:

 4


Example Explanation
Explanation 1:

 Meeting one can be done in conference room 1 form 0 - 30.
 Meeting two can be done in conference room 2 form 5 - 10.
 Meeting three can be done in conference room 2 form 15 - 20 as it is free in this interval.
Explanation 2:

 Meeting one can be done in conference room 1 from 1 - 18.
 Meeting five can be done in conference room 2 from 2 - 11.
 Meeting four can be done in conference room 3 from 4 - 15.
 Meeting six can be done in conference room 4 from 5 - 13.
 Meeting three can be done in conference room 2 from 15 - 29 as it is free in this interval.
 Meeting two can be done in conference room 4 from 18 - 23 as it is free in this interval.","int solve2(vector<vector<int> > &A){
    int n=A.size();
    sort(A.begin(),A.end());
        
        priority_queue<int, vector<int>, greater<int>> heap;
        int rooms = 0;
        heap.push(A[0][1]);
        rooms++;
        for (int i = 1; i < n; i++) {
            if (A[i][0] < heap.top()) {
                rooms++;
            } else {
                heap.pop();
            }
            heap.push(A[i][1]);
        }
        return rooms;
}

int solve1(vector<vector<int> > &A){
    int n=A.size();
    assert(1 <= n && n<= 100000);
     int start[n];
     int end[n];
     for (int i=0; i<n; i++) {
       start[i]=A[i][0];
       end[i]=A[i][1];
     }
     sort(start,start+n);
     sort(end,end+n);
     int i=0, j=0, res=0;
     while (i<n) {
       if (start[i]<end[j])
        i++;
       else if (start[i]>end[j])
        j++;
       else {
         i++;
         j++;
       }
       res=max(res,i-j);
     }
     return res;
}

int Solution::solve(vector<vector<int> > &A) {
    return solve1(A);
}"
Right view of Binary tree,https://www.interviewbit.com/problems/right-view-of-binary-tree/,N/A,Tree Data Structure,medium,"Problem Description

Given a binary tree A of integers. Return an array of integers representing the right view of the Binary tree.

Right view of a Binary Tree: is a set of nodes visible when the tree is visited from Right side.



Problem Constraints
1 <= Number of nodes in binary tree <= 105

0 <= node values <= 109 



Input Format
First and only argument is an pointer to the root of binary tree A.



Output Format
Return an integer array denoting the right view of the binary tree A.



Example Input
Input 1:

        1
      /   \
     2    3
    / \  / \
   4   5 6  7
  /
 8 
Input 2:

    1
   /  \
  2    3
   \
    4
     \
      5


Example Output
Output 1:

 [1, 3, 7, 8]
Output 2:

 [1, 3, 4, 5]","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
 

vector<int> rightview(TreeNode *root){
    vector<int> ans;
    queue< TreeNode * , int > q;  // which stores the Node and its level
    bool lev[100000];               
    memset(lev,false,sizeof lev); // initialising the lev array to false
    if(root==NULL)
        return ans;
    q.push(root);
    q.push(NULL);
    while(!q.empty()){
        TreeNode *temp=q.front();
        if(temp){
            ans.push_back(temp->val);
            while(q.front()!=NULL){
                if(temp->right)
                    q.push(temp->right);
                if(temp->left)
                    q.push(temp->left);
                q.pop();
                temp=q.front();
            }
            q.push(NULL);
        }
    q.pop();
    }
return ans;
}
vector<int> Solution::solve(TreeNode* A) {
    return rightview(A);
}"
Valid BST from Preorder,https://www.interviewbit.com/problems/valid-bst-from-preorder/,Unbxd Inc.,Tree Data Structure,medium,"Problem Description
 
 

You are given a preorder traversal A, of a Binary Search Tree.

Find if it is a valid preorder traversal of a BST.

Note: Binary Search Tree by definition has distinct keys and duplicates in binary search tree are not allowed.



Problem Constraints
1 <= A[i] <= 106

1 <= |A| <= 105



Input Format
First and only argument is an integer array A denoting the pre-order traversal.



Output Format
Return an integer:

0 : Impossible preorder traversal of a BST
1 : Possible preorder traversal of a BST


Example Input
Input 1:

A = [7, 7, 10, 10, 9, 5, 2, 8]


Example Output
Output 1:

 0","bool canRepresentBST(vector<int>& pre, int n) 
{ 
    // Create an empty stack 
    stack<int> s; 
  
    // Initialize current root as minimum possible 
    // value 
    int root = INT_MIN; 
  
    // Traverse given array 
    for (int i=0; i<n; i++) 
    { 
        // If we find a node who is on right side 
        // and smaller than root, return false 
        if (pre[i] < root) 
            return false; 
  
        // If pre[i] is in right subtree of stack top, 
        // Keep removing items smaller than pre[i] 
        // and make the last removed item as new 
        // root. 
        while (!s.empty() && s.top()<pre[i]) 
        { 
            root = s.top(); 
            s.pop(); 
        } 
  
        // At this point either stack is empty or 
        // pre[i] is smaller than root, push pre[i] 
        s.push(pre[i]); 
    } 
    return true; 
} 
int Solution::solve(vector<int> &A) {
    assert(A.size()>=1 && A.size()<=100000);
    set<int>s;
    for(int a:A){
        assert(a>=1 && a<=1000000);
        s.insert(a);
    }
    if(s.size() != A.size()){
        return 0;
    }
    if(canRepresentBST(A,A.size()))
        return 1;
    return 0;
}"
Diagonal Traversal,https://www.interviewbit.com/problems/diagonal-traversal/,Amazon,Tree Data Structure,medium,"Problem Description

Consider lines of slope -1 passing between nodes.

Given a Binary Tree A containing N nodes, return all diagonal elements in a binary tree belonging to same line.

NOTE:

See Sample Explanation for better understanding.
Order does matter in the output.
To get the same order as in the output traverse the tree same as we do in pre-order traversal.


Problem Constraints
 0 <= N <= 105 



Input Format
First and only Argument represents the root of binary tree A.



Output Format
Return a 1D array denoting the diagonal traversal of the tree.



Example Input
Input 1:

            1
          /   \
         4      2
        / \      \
       8   5      3
          / \    /
         9   7  6
Input 2:

             11
          /     \
         20      12
        / \       \
       1   15      13
          /  \     /
         2    17  16
          \   /
          22 34


Example Output
Output 1:

 [1, 2, 3, 4, 5, 7, 6, 8, 9]
Output 2:

 [11, 12, 13, 20, 15, 17, 16, 1, 2, 22, 34]


Example Explanation
Explanation 1:

 
 1) Diagonal 1 contains [1, 2, 3]
 2) Diagonal 2 contains [4, 5, 7, 6]
 3) Diagonal 3 contains [8, 9]


NOTE:
The order in the output matters like for Example:
6 and 7 belong to same diagonal i.e diagonal 2 but as 7 comes before 6 in pre-order traversal so 7 will be added to answer array first.



So concantenate all the array as return it as a single one.
 Final output: [1, 2, 3, 4, 5, 7, 6, 8, 9]

Explanation 2:

 
 1) Diagonal 1 contains [11, 12, 13]
 2) Diagonal 2 contains [20, 15, 17, 16]
 3) Diagonal 2 contains [1, 2, 22, 34]


So concantenate all the array as return it as a single one.
 Final output: [11, 12, 13, 20, 15, 17, 16, 1, 2, 22, 34]
","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
vector<int> diagonalPrint(TreeNode* root) 
{ 
    vector<int>ans;
  
    // inbuilt queue of Treenode 
    queue<TreeNode*> q; 
  
    // push root 
    q.push(root); 
  
    // push delimiter 
    q.push(NULL); 
  
    while (!q.empty()) { 
        TreeNode* temp = q.front(); 
        q.pop(); 
  
        // if current is delimiter then insert another 
        // for next diagonal and cout nextline 
        if (temp == NULL) { 
  
            // if queue is empty return 
            if (q.empty()) 
                break; 
            // push delimiter again 
            q.push(NULL); 
        } 
        else { 
            while (temp) { 
                ans.push_back(temp->val);
                // if left child is present  
                // push into queue 
                if (temp->left) 
                    q.push(temp->left); 
  
                // current equals to right child 
                temp = temp->right; 
            } 
        } 
    } 
    return ans;
} 
vector<int> Solution::solve(TreeNode* A) {
    vector<int>temp=diagonalPrint(A);
    return temp;
}"
Maximum Sum Combinations,https://www.interviewbit.com/problems/maximum-sum-combinations/,Amazon,Heaps And Maps,medium,"Problem Description
 
 

Given two equally sized 1-D arrays A, B containing N integers each.

A sum combination is made by adding one element from array A and another element of array B.

Return the maximum C valid sum combinations from all the possible sum combinations.



Problem Constraints
1 <= N <= 105

1 <= A[i] <= 105

1 <= C <= N



Input Format
First argument is an one-dimensional integer array A of size N.

Second argument is an one-dimensional integer array B of size N.

Third argument is an integer C.



Output Format
Return a one-dimensional integer array of size C denoting the top C maximum sum combinations.

NOTE:

The returned array must be sorted in non-increasing order.



Example Input
Input 1:

 A = [3, 2]
 B = [1, 4]
 C = 2
Input 2:

 A = [1, 4, 2, 3]
 B = [2, 5, 1, 6]
 C = 4


Example Output
Output 1:

 [7, 6]
Output 1:

 [10, 9, 9, 8]


Example Explanation
Explanation 1:

 7     (A : 3) + (B : 4)
 6     (A : 2) + (B : 4)
Explanation 2:

 10   (A : 4) + (B : 6)
 9   (A : 4) + (B : 5)
 9   (A : 3) + (B : 6)
 8   (A : 3) + (B : 5)
","vector<int> KMaxCombinations(vector<int>& A,vector<int>& B, int K)
{
    // sort both arrays A and B
    sort(A.begin(), A.end());
    sort(B.begin(), B.end());
    vector<int>ans;
    int N = A.size();

    // Max heap which contains tuple of the format
    // (sum, (i, j)) i and j are the indices
    // of the elements from array A
    // and array B which make up the sum.
    priority_queue<pair<int, pair<int, int> > > pq;

    // my_set is used to store the indices of
    // the  pair(i, j) we use my_set to make sure
    // the indices doe not repeat inside max heap.
    set<pair<int, int> > my_set;

    // initialize the heap with the maximum sum
    // combination ie (A[N - 1] + B[N - 1])
    // and also push indices (N - 1, N - 1) along
    // with sum.
    pq.push(make_pair(A[N - 1] + B[N - 1],
                      make_pair(N-1, N-1)));

    my_set.insert(make_pair(N - 1, N - 1));

    // iterate upto K
    for (int count=0; count<K; count++) {

        // tuple format (sum, (i, j)).
        pair<int, pair<int, int> > temp = pq.top();
        pq.pop();

        ans.push_back(temp.first);

        int i = temp.second.first;
        int j = temp.second.second;

        if(i-1>=0)
        {
            int sum = A[i - 1] + B[j];

        // insert (A[i - 1] + B[j], (i - 1, j))
        // into max heap.
        pair<int, int> temp1 = make_pair(i - 1, j);

        // insert only if the pair (i - 1, j) is
        // not already present inside the map i.e.
        // no repeating pair should be present inside
        // the heap.
        if (my_set.find(temp1) == my_set.end()) {
            pq.push(make_pair(sum, temp1));
            my_set.insert(temp1);
        }
        }

        // insert (A[i] + B[j - 1], (i, j - 1))
        // into max heap
        if(j-1>=0)
        {
        int sum = A[i] + B[j - 1];
        pair<int,int>temp1 = make_pair(i, j - 1);

        // insert only if the pair (i, j - 1)
        // is not present inside the heap.
        if (my_set.find(temp1) == my_set.end()) {
            pq.push(make_pair(sum, temp1));
            my_set.insert(temp1);
        }
        }
    }
    return ans;
}
vector<int> Solution::solve(vector<int> &A, vector<int> &B, int C) {
    vector<int>temp=KMaxCombinations(A,B,C);
    return temp;
}"
Maximum Path in Triangle,https://www.interviewbit.com/problems/maximum-path-in-triangle/,Amazon,Dynamic Programming,easy,"Problem Description

Given a 2D integer array A of size  N * N   representing a triangle of numbers.

Find the maximum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.

NOTE:

Adjacent cells to cell (i,j) are only (i+1,j) and (i+1,j+1)
Row i contains i integer and n-i zeroes for all i in [1,n] where zeroes represents empty cells.


Problem Constraints
 0 <= N <= 1000 

 0 <= A[i][j] <= 1000 



Input Format
First and only argument is an 2D integer array A of size N * N.



Output Format
Return a single integer denoting the maximum path sum from top to bottom in the triangle.



Example Input
Input 1:

 A = [
        [3, 0, 0, 0]
        [7, 4, 0, 0]
        [2, 4, 6, 0]
        [8, 5, 9, 3]
     ]
Input 2:

 A = [
        [8, 0, 0, 0]
        [4, 4, 0, 0]
        [2, 2, 6, 0]
        [1, 1, 1, 1]
     ]


Example Output
Output 1:

 23
Output 2:

 19


Example Explanation
Explanation 1:

 Given triangle looks like:  3
                             7 4
                             2 4 6
                             8 5 9 3
        So max path is (3 + 7 + 4 + 9) = 23
Explanation 1:

 Given triangle looks like:  8
                             4 4
                             2 2 6
                             1 1 1 1
        So max path is (8 + 4 + 6 + 1) = 19
","int Solution::solve(vector<vector<int> > &A) {
    vector<vector<int> > m=A;
    
    int r=A.size();
    int c=A[0].size();
    
    for(int i=r-2;i>=0;i--)
    {
        
        for(int j=0;j<=i;j++)
        {
            m[i][j]+=max(m[i+1][j],m[i+1][j+1]);
        }
    }
    
    return m[0][0];
}"
Cousins in Binary Tree,https://www.interviewbit.com/problems/cousins-in-binary-tree/,Amazon,Tree Data Structure,medium,"Problem Description

Given a Binary Tree A consisting of N nodes.

You need to find all the cousins of node B.

NOTE:

Siblings should not be considered as cousins.
Try to do it in single traversal.
You can assume that Node B is there in the tree A.
Order doesn't matter in the output.


Problem Constraints
 1 <= N <= 105 

 1 <= B <= N



Input Format
First Argument represents the root of binary tree A.

Second Argument is an integer B denoting the node number.



Output Format
Return an integer array denoting the cousins of node B.

NOTE: Order doesn't matter.



Example Input
Input 1:

 A =

           1
         /   \
        2     3
       / \   / \
      4   5 6   7 


B = 5

Input 2:

 A = 
            1
          /   \
         2     3
        / \ .   \
       4   5 .   6


B = 1




Example Output
Output 1:

 [6, 7]
Output 2:

 []


Example Explanation
Explanation 1:

 Cousins of Node 5 are Node 6 and 7 so we will return [6, 7]
 Remember Node 4 is sibling of Node 5 and do not need to return this.
Explanation 2:

 Since Node 1 is the root so it doesn't have any cousin so we will return an empty array.
","void printCousins(TreeNode* root,int node_to_find,vector<int>& ans)
{
    // if the given node is the root itself,
    // then no nodes would be printed
    if (root->val == node_to_find) {
        return;
    }
    queue<TreeNode*> q;
    bool found = false;
    int size_;
    TreeNode* p;
    q.push(root);
    // the following loop runs until found is
    // not true, or q is not empty.
    // if found has become true => we have found
    // the level in which the node is present
    // and the present queue will contain all the
    // cousins of that node
    while (!q.empty() && !found) {

        size_ = q.size();
        while (size_) {
            p = q.front();
            q.pop();

            // if current node's left or right child
            // is the same as the node to find,
            // then make found = true, and don't push
            // any of them into the queue, as
            // we don't have to print the siblings
            if ((p->left && p->left->val == node_to_find) ||
                (p->right && p->right->val == node_to_find)) {
                found = true;
            }
            else {
                if (p->left)
                    q.push(p->left);
                if (p->right)
                    q.push(p->right);
            }

            size_--;
        }
    }

    // if found == true then the queue will contain the
    // cousins of the given node
    if (found) {
        size_ = q.size();

        // size_ will be 0 when the node was at the
        // level just below the root node.
        for (int i = 0; i < size_; i++) {
            p = q.front();
            q.pop();
            ans.push_back(p->val);
        }
    }
    return;
}
vector<int> Solution::solve(TreeNode* A, int B) {
    vector<int>ans;
    printCousins(A,B,ans);
    return ans;
}"
Reverse Alternate K Nodes,https://www.interviewbit.com/problems/reverse-alternate-k-nodes/,Amazon,Linked Lists,medium,"Problem Description

Given a linked list A of length N and an integer B.

You need to reverse every alternate B nodes in the linked list A.



Problem Constraints
1 <= N <= 105
1<= Value in Each Link List Node <= 103
1 <= B <= N
N is divisible by B


Input Format
First argument is the head pointer of the linkedlist A.

Second argument is an integer B.



Output Format
Return the head pointer of the final linkedlist as described.



Example Input
Input 1:

 A = 3 -> 4 -> 7 -> 5 -> 6 -> 6 -> 15 -> 61 -> 16
 B = 3
 Input 2:

 A = 1 -> 4 -> 6 -> 6 -> 4 -> 10
 B = 2


Example Output
Output 1:

 7 -> 4 -> 3 -> 5 -> 6 -> 6 -> 16 -> 61 -> 15
Output 2:

 4 -> 1 -> 6 -> 6 -> 10 -> 4


Example Explanation
Explanation 1:

 The linked list contains 9 nodes and we need to reverse alternate 3 nodes.
 First sublist of length 3  is 3 -> 4 -> 7 so on reversing it we get 7 -> 4 -> 3.
 Second sublist of length 3 is 5 -> 6 -> 6 we don't need to reverse it.
 Third sublist of length 3 is 15 -> 61 -> 16 so on reversing it we get 16 -> 61 -> 15.
Explanation 2:

 The linked list contains 6 nodes and we need to reverse alternate 2 nodes.
 First sublist of length 2 is 1 -> 4 so on reversing it we get 4 -> 1.
 Second sublist of length 2 is 6 -> 6 we don't need to reverse it.
 Third sublist of length 2 is 4 -> 10 so on reversing it we get 10 -> 4.
","/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
ListNode* rev(ListNode* A,int B,int pos){
    if(A==NULL){
        return A;
    }
    if(pos==0){
        ListNode* cur=A;
        ListNode* prev=NULL;
        ListNode* lat=A;
        int cnt=0;
        while(cnt<B){
            prev=cur;
            cur=cur->next;
            cnt++;
        }
        prev->next=rev(cur,B,1);
        return A;
    }
    else{
        ListNode* cur=A;
        ListNode* prev=NULL;
        ListNode* lat=A;
        int cnt=0;
        while(cnt<B){
            lat=cur->next;
            cur->next=prev;
            prev=cur;
            cur=lat;
            cnt++;
        }
        A->next=rev(cur,B,0);
        return prev;
    }
} 
 
ListNode* Solution::solve(ListNode* A, int B) {
    if(B<=1){
        return A;
    }
    return rev(A,B,1);
}"
Kth Node From Middle,https://www.interviewbit.com/problems/kth-node-from-middle/,Amazon,Linked Lists,easy,"Problem Description

Given a linked list A of length N and an integer B.

You need to find the value of the Bth node from the middle towards the beginning of the Linked List A.

If no such element exists, then return -1.

NOTE:

Position of middle node is: (N/2)+1, where N is the total number of nodes in the list.


Problem Constraints
1 <= N <= 105
1<= Value in Each Link List Node <= 103
1 <= B <= 105


Input Format
First argument is the head pointer of the linkedlist A.

Second argument is an integer B.



Output Format
Return an integer denoting the value of the Bth from the middle towards the head of the linked list A. If no such element exists, then return -1.



Example Input
Input 1:

 A = 3 -> 4 -> 7 -> 5 -> 6 -> 1 6 -> 15 -> 61 -> 16
 B = 3
 Input 2:

 A = 1 -> 14 -> 6 -> 16 -> 4 -> 10
 B = 2
 Input 3:

 A = 1 -> 14 -> 6 -> 16 -> 4 -> 10
 B = 10


Example Output
Output 1:

 4
 Output 2:

 14
 Output 3:

 -1


Example Explanation
Explanation 1:

 The Middle of the linked list is the node with value 6.
 The 1st node from the middle of the linked list is the node with value 5.
 The 2nd node from the middle of the linked list is the node with value 7.
 The 3rd node from the middle of the linked list is the node with value 4.
 So we will output 4.
Explanation 2:

 The Middle of the linked list is the node with value 16.
 The 1st node from the middle of the linked list is the node with value 6.
 The 2nd node from the middle of the linked list is the node with value 14.
 So we will output 14.
Explanation 3:

 The Middle of the linked list is the node with value 16.
 There are only 3 nodes to the left of the middle node and we need to find the 10th node which doesn't exist so we will return -1.","/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
int Solution::solve(ListNode* A, int B) {

    ListNode*p=A;
    int s=0;
    while(p)
    {
        s++;p=p->next;
    }

    B=B+((s+1)/2);

    B=s-B;

    if(B<0) return -1;

    p=A;

    while(B--)
    {
        p=p->next;
    }

    return p->val;
}"
Pair With Given Difference,https://www.interviewbit.com/problems/pair-with-given-difference/,"Amazon, Facebook",Two Pointers,easy,"Problem Description

Given an one-dimensional unsorted array A containing N integers.

You are also given an integer B, find if there exists a pair of elements in the array whose difference is B.

Return 1 if any such pair exists else return 0.



Problem Constraints
1 <= N <= 105
-103 <= A[i] <= 103
-105 <= B <= 105


Input Format
First argument is an integer array A of size N.

Second argument is an integer B.



Output Format
Return 1 if any such pair exists else return 0.



Example Input
Input 1:

 A = [5, 10, 3, 2, 50, 80]
 B = 78
Input 2:

 A = [-10, 20]
 B = 30


Example Output
Output 1:

 1
Output 2:

 1


Example Explanation
Explanation 1:

 Pair (80, 2) gives a difference of 78.
Explanation 2:

 Pair (20, -10) gives a difference of 30 i.e 20 - (-10) => 20 + 10 => 30","bool findPair(vector<int>&arr, int size, int n)  
{  
    // Initialize positions of two elements  
    int i = 0;  
    int j = 1;  
   sort(arr.begin(),arr.end());
    // Search for a pair  
    while (i < size && j < size)  
    {  
        if (i != j && arr[j] - arr[i] == n)  
        {
            return true;  
        }  
        else if (arr[j]-arr[i] < n)  
            j++;  
        else
            i++;  
    }  
    return false;  
}  
int Solution::solve(vector<int> &A, int B) {
    return findPair(A,A.size(),B);
}"
Path to Given Node,https://www.interviewbit.com/problems/path-to-given-node/,Amazon,Tree Data Structure,easy,"Problem Description

Given a Binary Tree A containing N nodes.

You need to find the path from Root to a given node B.

NOTE:

No two nodes in the tree have same data values.
You can assume that B is present in the tree A and a path always exists.


Problem Constraints
 1 <= N <= 105 

 1 <= Data Values of Each Node <= N

 1 <= B <= N



Input Format
First Argument represents pointer to the root of binary tree A.

Second Argument is an integer B denoting the node number.



Output Format
Return an one-dimensional array denoting the path from Root to the node B in order.



Example Input
Input 1:

 A =

           1
         /   \
        2     3
       / \   / \
      4   5 6   7 


B = 5

Input 2:

 A = 
            1
          /   \
         2     3
        / \ .   \
       4   5 .   6


B = 1




Example Output
Output 1:

 [1, 2, 5]
Output 2:

 [1]


Example Explanation
Explanation 1:

 We need to find the path from root node to node with data value 5.
 So the path is 1 -> 2 -> 5 so we will return [1, 2, 5]
Explanation 2:

 We need to find the path from root node to node with data value 1.
 As node with data value 1 is the root so there is only one node in the path.
 So we will return [1]
","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeTreeNode *left;
 *     TreeTreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

// Returns true if there is a path from root
// to the given node. It also populates
// 'arr' with the given path
bool hasPath(TreeNode *root, vector<int>& arr, int x)
{
    // if root is NULL
    // there is no path
    if (!root)
        return false;

    // push the node's value in 'arr'
    arr.push_back(root->val);

    // if it is the required node
    // return true
    if (root->val == x)
        return true;

    // else check whether the required node lies
    // in the left subtree or right subtree of
    // the current node
    if (hasPath(root->left, arr, x) ||
        hasPath(root->right, arr, x))
        return true;

    // required node does not lie either in the
    // left or right subtree of the current node
    // Thus, remove current node's value from
    // 'arr'and then return false
    arr.pop_back();
    return false;
}
vector<int> Solution::solve(TreeNode* A, int B) {
    vector<int>ans;
    hasPath(A,ans,B);
    return ans;
}"
Count Total Set Bits,https://www.interviewbit.com/problems/count-total-set-bits/,Amazon,Bit Manipulation,hard,"Problem Description

Given a positive integer A, the task is to count the total number of set bits in the binary representation of all the numbers from 1 to A.

Return the count modulo 109 + 7.



Problem Constraints
1 <= A <= 109



Input Format
First and only argument is an integer A.



Output Format
Return an integer denoting the ( Total number of set bits in the binary representation of all the numbers from 1 to A )modulo 109 + 7.



Example Input
Input 1:

 A = 3
Input 2:

 A = 1


Example Output
Output 1:

 4
Output 2:

 1


Example Explanation
Explanation 1:

 DECIMAL    BINARY  SET BIT COUNT
    1          01        1
    2          10        1
    3          11        2
 1 + 1 + 2 = 4 
 Answer = 4 % 1000000007 = 4
Explanation 2:

 A = 1
  DECIMAL    BINARY  SET BIT COUNT
    1          01        1
 Answer = 1 % 1000000007 = 1","int powerOfTwo(int n){
  int i=0;
  while((1<<i) <= n)
    i++;
  
  return i-1;
}

int Solution::solve(int num) {
  if(num==0)
    return 0;
    
  long long x = powerOfTwo(num);
  long long bits = x * (1<<(x-1));
  long long msb = num - (1<<x) + 1;
  long long rest = num-(1<<x);
  long ans = (bits%1000000007 + msb%1000000007 + solve(rest%1000000007))%1000000007;
  
  return ans;
}"
Sort Binary Linked List,https://www.interviewbit.com/problems/sort-binary-linked-list/,Amazon,Linked Lists,easy,"Problem Description

Given a Linked List A consisting of N nodes.

The Linked List is binary i.e data values in the linked list nodes consist of only 0's and 1's.

You need to sort the linked list and return the new linked list.

NOTE:

Try to do it in constant space.


Problem Constraints
 1 <= N <= 105

 A.val = 0 or A.val = 1



Input Format
First and only argument is the head pointer of the linkedlist A.



Output Format
Return the head pointer of the new sorted linked list.



Example Input
Input 1:

 1 -> 0 -> 0 -> 1
Input 2:

 0 -> 0 -> 1 -> 1 -> 0


Example Output
Output 1:

 0 -> 0 -> 1 -> 1
Output 2:

 0 -> 0 -> 0 -> 1 -> 1


Example Explanation
Explanation 1:

 The sorted linked list looks like:
  0 -> 0 -> 1 -> 1
Explanation 2:

 The sorted linked list looks like:
  0 -> 0 -> 0 -> 1 -> 1","/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
ListNode* Solution::solve(ListNode* l) {
    int zeros = 0;
   
    for(ListNode* p = l; p != NULL; p = p->next) zeros += 1 - p->val;
    for(ListNode* p = l; p != NULL; p = p->next) p->val = zeros-- > 0 ? 0 : 1;
    
    return l;
}"
Cycle in Directed Graph,https://www.interviewbit.com/problems/cycle-in-directed-graph/,Amazon,Graph Data Structure & Algorithms,easy,"Problem Description

Given an directed graph having A nodes. A matrix B of size M x 2 is given which represents the M edges such that there is a edge directed from node B[i][0] to node B[i][1].

Find whether the graph contains a cycle or not, return 1 if cycle is present else return 0.

NOTE:

The cycle must contain atleast two nodes.
There are no self-loops in the graph.
There are no multiple edges between two nodes.
The graph may or may not be connected.
Nodes are numbered from 1 to A.
Your solution will run on multiple test cases. If you are using global variables make sure to clear them.


Problem Constraints
2 <= A <= 105

1 <= M <= min(200000,A(A-1))

1 <= B[i][0], B[i][1] <= A



Input Format
The first argument given is an integer A representing the number of nodes in the graph.

The second argument given a matrix B of size M x 2 which represents the M edges such that there is a edge directed from node B[i][0] to node B[i][1].



Output Format
Return 1 if cycle is present else return 0.



Example Input
Input 1:

 A = 5
 B = [  [1, 2] 
        [4, 1] 
        [2, 4] 
        [3, 4] 
        [5, 2] 
        [1, 3] ]
Input 2:

 A = 5
 B = [  [1, 2]
        [2, 3] 
        [3, 4] 
        [4, 5] ]


Example Output
Output 1:

 1
Output 2:

 0


Example Explanation*
Explanation 1:

 The given graph contain cycle 1 -> 3 -> 4 -> 1 or the cycle 1 -> 2 -> 4 -> 1
Explanation 2:

 The given graph doesn't contain any cycle.","const int maxn=100009;
int visited[maxn];
int recStack[maxn];
vector<int>adj[maxn];
bool isCyclicUtil(int v)
{  
        // Mark the current node as visited and part of recursion stack 
        visited[v] = 1; 
        recStack[v] = 1; 
  
        // Recur for all the vertices adjacent to this vertex 
        for(int u:adj[v])
        {
            if ( !visited[u] && isCyclicUtil(u) ) 
                return true; 
            else if (recStack[u]) 
                return true; 
        } 
    
    recStack[v] = 0;  // remove the vertex from recursion stack 
    return false; 
} 
int Solution::solve(int A, vector<vector<int> > &B) {
    memset(visited,0,sizeof(visited));
    memset(recStack,0,sizeof(recStack));
    for(int i=0;i<maxn;i++)adj[i].clear();
    for(auto& it:B)adj[it[0]].push_back(it[1]);
    int flag=0;
    for(int i=1;i<=A;i++)
    {
        if(visited[i]==0 && isCyclicUtil(i))
            return 1;
    }
    return 0;
}"
K Largest Elements,https://www.interviewbit.com/problems/k-largest-elements/,"Amazon, Flipkart",Heaps And Maps,easy,"Problem Description

Given an 1D integer array A of size N you have to find and return the B largest elements of the array A.

NOTE:

Return the largest B elements in any order you like.


Problem Constraints
1 <= N <= 105

1 <= B <= N

1 <= A[i] <= 103



Input Format
First argument is an 1D integer array A

Second argument is an integer B.



Output Format
Return a 1D array of size B denoting the B largest elements.



Example Input
Input 1:

 A = [11, 3, 4]
 B = 2
Input 2:

 A = [11, 3, 4, 6]
 B = 3


Example Output
Output 1:

 [11, 4]
Output 2:

 [4, 6, 11]


Example Explanation
Explanation 1:

 The two largest elements of A are 11 and 4
Explanation 2:

 The three largest elements of A are 11, 4 and 6","vector<int> Solution::solve(vector<int> &A, int B) {
    if(B==A.size())return A;
    priority_queue<int,vector<int>,greater<int> >pq;
    for(int i=0;i<B;i++)
        pq.push(A[i]);
    for(int i=B;i<A.size();i++)
    {
        if(pq.top()<A[i])
        {
            pq.pop();
            pq.push(A[i]);
        }
    }
    vector<int>ans;
    while(pq.empty()==false)
    {
        ans.push_back(pq.top());
        pq.pop();
    }
    return ans;
}"
Palindromic Binary Representation,https://www.interviewbit.com/problems/palindromic-binary-representation/,Amazon,Bit Manipulation,hard,"Problem Description

Given an integer A find the Ath number whose binary representation is a palindrome.

NOTE:

Consider the 1st number whose binary representation is palindrome as 1, instead of 0
Do not consider the leading zeros, while considering the binary representation.


Problem Constraints
 1 <= A <= 2104



Input Format
First and only argument is an integer A.



Output Format
Return an integer denoting the Ath number whose binary representation is a palindrome.



Example Input
Input 1:

 A = 1
Input 1:

 A = 9


Example Output
Output 1:

 1
Output 2:

 27


Example Explanation*
Explanation 1:

 1st Number whose binary representation is palindrome is 1
Explanation 2

 9th Number whose binary representation is palindrome is 27 (11011)","int Solution::solve(int a) {
    // 1 3 5 7 9 15 17 21 31
    int sum = 1;
long long p = 1;
int l = 0;
while(1)
{
    l++;
    if(sum + p > a) break;
    sum += p;
    
    l++;
    if(sum + p > a) break;
    sum += p;
    
    p <<= 1;
}

int diff = a - sum; 
int bits[l]{};
bits[0] = bits[l - 1] = 1;

int mid = l >> 1;
for(int i = 0; diff && i < mid; i++)
{
    // !(l & 1) is for making two mid bit for even length Verify :)
    bits[mid - i - !(l & 1)] = bits[mid + i] = diff & 1;
    diff >>= 1;
}

long long ans = 0;
p = 1;
for(int i = 0; i < l; i++) 
{
    ans += bits[i] * p;
    p <<= 1;
}

return ans;
}"
Remove Half Nodes,https://www.interviewbit.com/problems/remove-half-nodes/,Amazon,Tree Data Structure,easy,"Problem Description

Given a binary tree A with N nodes.

You have to remove all the half nodes and return the final binary tree.

NOTE:

Half nodes are nodes which have only one child.
Leaves should not be touched as they have both children as NULL.


Problem Constraints
 1 <= N <= 105



Input Format
First and only argument is an pointer to the root of binary tree A.



Output Format
Return a pointer to the root of the new binary tree.



Example Input
Input 1:

           1
         /   \
        2     3
       / 
      4

Input 2:

            1
          /   \
         2     3
        / \     \
       4   5     6


Example Output
Output 1:

           1
         /   \
        4     3
Output 2:

            1
          /   \
         2     6
        / \

       4   5



Example Explanation
Explanation 1:

 The only half node present in the tree is 2 so we will remove this node.
Explanation 2:

 The only half node present in the tree is 3 so we will remove this node.","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
TreeNode* Solution::solve(TreeNode* A) {
    if(A->left == NULL && A->right == NULL)return A;
    if(A->left == NULL)
        return solve(A->right);
    if(A->right == NULL)
        return solve(A->left);
    A->left = solve(A->left);
    A->right = solve(A->right);
    return A;
    
}"
Cycle in Undirected Graph,https://www.interviewbit.com/problems/cycle-in-undirected-graph/,Amazon,Graph Data Structure & Algorithms,easy,"Problem Description

Given an undirected graph having A nodes labelled from 1 to A with M edges given in a form of matrix B of size M x 2 where (B[i][0], B[i][1]) represents two nodes B[i][0] and B[i][1] connected by an edge.

Find whether the graph contains a cycle or not, return 1 if cycle is present else return 0.

NOTE:

The cycle must contain atleast three nodes.
There are no self-loops in the graph.
There are no multiple edges between two nodes.
The graph may or may not be connected.
Nodes are numbered from 1 to A.
Your solution will run on multiple test cases. If you are using global variables make sure to clear them.


Problem Constraints
1 <= A, M <= 3105

1 <= B[i][0], B[i][1] <= A



Input Format
The first argument given is an integer A representing the number of nodes in the graph.

The second argument given is an matrix B of size M x 2 which represents the M edges such that there is a edge between node B[i][0] and node B[i][1].



Output Format
Return 1 if cycle is present else return 0.



Example Input
Input 1:

 A = 5
 B = [  [1. 2]
        [1, 3]
        [2, 3]
        [1, 4]
        [4, 5]
     ]
Input 2:

 A = 3
 B = [  [1. 2]
        [1, 3]
     ]


Example Output
Output 1:

 1
Output 2:

 0


Example Explanation*
Explanation 1:

 There is a cycle in the graph i.e 1 -> 2 -> 3 -> 1 so we will return 1
Explanation 2:

 No cycle present in the graph so we will return 0.","const int maxn=300009;
int arr[maxn];
int sz[maxn];
void ini()
{
  for(int i=0;i<maxn;i++)
  {
    arr[i]=i;
    sz[i]=1;
  }
}
int root(int a)
{
  while(a!=arr[a])
  {
    arr[a]=arr[arr[a]];
    a=arr[a];
  }
  return a;
}
void un(int a,int b)
{
  a=root(a);
  b=root(b);
  if(sz[a]>=sz[b])
  {
    arr[b]=a;
    sz[a]+=sz[b];
  }
  else
  {
    arr[a]=b;
    sz[b]+=sz[a];
  }
}

int Solution::solve(int A, vector<vector<int> > &B) {
    ini();
    for(auto& it:B)
    {
        if(root(it[0])==root(it[1])) //cycle detection
            return 1;
        else un(it[0],it[1]); //union
    }
    return 0;
    
}"
Next Similar Number,https://www.interviewbit.com/problems/next-similar-number/,Amazon,Math,medium,"Problem Description

Given a number A in a form of string.

You have to find the smallest number that has same set of digits as A and is greater than A.

If A is the greatest possible number with its set of digits, then return -1.



Problem Constraints
 1 <= A <= 10100000

 A doesn't contain leading zeroes.



Input Format
First and only argument is an numeric string denoting the number A.



Output Format
Return a string denoting the smallest number greater than A with same set of digits , if A is the largest possible then return -1.



Example Input
Input 1:

 A = ""218765""
Input 2:

 A = ""4321""


Example Output
Output 1:

 ""251678""
Output 2:

 ""-1""


Example Explanation
Explanation 1:

 The smallest number greater then 218765 with same set of digits is 251678.
Explanation 2:

 The given number is the largest possible number with given set of digits so we will return -1.","string findNext(string number, int n)
{
   int i, j;

   // I) Start from the right most digit and find the first digit that is
   // smaller than the digit next to it.
   for (i = n-1; i > 0; i--)
       if (number[i] > number[i-1])
          break;

   // If no such digit is found, then all digits are in descending order
   // means there cannot be a greater number with same set of digits
   if (i==0)
   {
     return ""-1"";
   }

   // II) Find the smallest digit on right side of (i-1)'th digit that is
   // greater than number[i-1]
   char x = number[i-1];
   int smallest = i;
   for (j = i+1; j < n; j++)
       if (number[j] > x && number[j] < number[smallest])
           smallest = j;

   // III) Swap the above found smallest digit with number[i-1]
   swap(number[smallest], number[i-1]);
   string a=number.substr(i);
   string b=number.substr(0,i);
    // IV) Sort the digits after (i-1) in ascending order 
   sort(a.begin(),a.end());
   string ans=b+a;
   return ans;
}

string Solution::solve(string A) {
    return findNext(A,A.size());
}"
Convert to Palindrome,https://www.interviewbit.com/problems/convert-to-palindrome/,Amazon,Strings,easy,"Problem Description

Given a string A consisting only of lowercase characters, we need to check whether it is possible to make this string a palindrome after removing exactly one character from this.

If it is possible then return 1 else return 0.



Problem Constraints
3 <= |A| <= 105

 A[i] is always a lowercase character.



Input Format
First and only argument is an string A.



Output Format
Return 1 if it is possible to convert A to palindrome by removing exactly one character else return 0.



Example Input
Input 1:

 A = ""abcba""
Input 2:

 A = ""abecbea""


Example Output
Output 1:

 1
Output 2:

 0


Example Explanation
Explanation 1:

 We can remove character ‘c’ to make string palindrome
Explanation 2:

 It is not possible to make this string palindrome just by removing one character 
","int Solution::solve(string A) 
{
    int i{},j=A.size()-1,x=-1,y=-1;
    
    while(i<j)
    {
        if(A[i]==A[j])
        {
            i++;
            j--;
        }
        else
        {
            x=i;
            y=j;
            break;
        }
    }
    
    if(x==-1)
    {
        return 1;
    }
    
    i=x+1;
    j=y;
    bool b=false;
    
    while(i<j)
    {
        if(A[i]==A[j])
        {
            i++;
            j--;
        }
        else
        {
            b=true;
            break;
        }
    }
    
    if(!b)
    {
        return 1;
    }
    
    i=x;
    j=y-1;
    
    while(i<j)
    {
        if(A[i]==A[j])
        {
            i++;
            j--;
        }
        else
        {
            return 0;
        }
    }
    
    return 1;
}"
0-1 Knapsack,https://www.interviewbit.com/problems/0-1-knapsack/,Amazon,Dynamic Programming,medium,"Problem Description

Given two integer arrays A and B of size N each which represent values and weights associated with N items respectively.

Also given an integer C which represents knapsack capacity.

Find out the maximum value subset of A such that sum of the weights of this subset is smaller than or equal to C.

NOTE:

You cannot break an item, either pick the complete item, or don’t pick it (0-1 property).


Problem Constraints
1 <= N <= 103

1 <= C <= 103

1 <= A[i], B[i] <= 103



Input Format
First argument is an integer array A of size N denoting the values on N items.

Second argument is an integer array B of size N denoting the weights on N items.

Third argument is an integer C denoting the knapsack capacity.



Output Format
Return a single integer denoting the maximum value subset of A such that sum of the weights of this subset is smaller than or equal to C.



Example Input
Input 1:

 A = [60, 100, 120]
 B = [10, 20, 30]
 C = 50
Input 2:

 A = [10, 20, 30, 40]
 B = [12, 13, 15, 19]
 C = 10


Example Output
Output 1:

 220
Output 2:

 0


Example Explanation
Explanation 1:

 Taking items with weight 20 and 30 will give us the maximum value i.e 100 + 120 = 220
Explanation 2:

 Knapsack capacity is 10 but each item has weight greater than 10 so no items can be considered in the knapsack therefore answer is 0.","int knapsack(vector<int> &A, vector<int> &B, int n, int c, vector<vector<int>> &dp){
    if(n==0 || c==0){
        return 0;
    }
    if(dp[n][c]!=-1)
        return dp[n][c];
    if(B[n-1]<=c){
        return dp[n][c]=max(A[n-1]+knapsack(A,B,n-1,c-B[n-1],dp),knapsack(A,B,n-1,c,dp));
    }
    else 
        return dp[n][c]=knapsack(A,B,n-1,c,dp);
}
int Solution::solve(vector<int> &A, vector<int> &B, int C) {
    int n=B.size();
    vector<vector<int>> dp(n+1,vector<int>(C+1,-1));
    return knapsack(A,B,n,C,dp);
}"
Chain of Pairs,https://www.interviewbit.com/problems/chain-of-pairs/,"Amazon, Directi",Dynamic Programming,medium,"Problem Description
 
 

Given a N * 2 array A where (A[i][0], A[i][1]) represents the ith pair.

In every pair, the first number is always smaller than the second number.

A pair (c, d) can follow another pair (a, b) if b < c , similarly in this way a chain of pairs can be formed.

Find the length of the longest chain subsequence which can be formed from a given set of pairs.


Note: A subsequence of a given sequence is a sequence that can be derived from the given sequence by deleting some or no elements without changing the order of the remaining elements.



Problem Constraints
1 <= N <= 103

1 <= A[i][0] < A[i][1] <= 104



Input Format
First and only argument is an 2D integer array A of size N * 2 representing the N pairs.



Output Format
Return a single integer denoting the length of longest chain subsequence of pairs possible under given constraint.



Example Input
Input 1:

 A = [  [5, 24]
        [39, 60]
        [15, 28]
        [27, 40]
        [50, 90]
     ]
Input 2:

 
A = [   [10, 20]
        [1, 2]
     ]


Example Output
Output 1:

 3
Output 2:

 1


Example Explanation
Explanation 1:

 Longest chain that can be formed is of length 3, and the chain is [ [5, 24], [27, 40], [50, 90] ]
Explanation 2:

 Longest chain that can be formed is of length 1, and the chain is [ [1, 2] ] or [ [10, 20] ]","int solveQ(vector < vector < int > > & arr) {
  int n = arr.size();
  int dp[n];
  for (int i = 0; i < n; i++)
    dp[i] = 1;

  for (int i = 1; i < n; i++) {
    for (int j = 0; j < i; j++) {
      if (arr[i][0] > arr[j][1] && dp[i] < dp[j] + 1) {
        dp[i] = dp[j] + 1;
      }
    }
  }

  int maxe = 0;
  for (int i = 0; i < n; i++)
    maxe = max(maxe, dp[i]);
  return maxe;
}
int Solution::solve(vector < vector < int > > & A) {
  return solveQ(A);
}"
Merge two Binary Tree,https://www.interviewbit.com/problems/merge-two-binary-tree/,Amazon,Tree Data Structure,easy,"Problem Description

Given two Binary Trees A and B, you need to merge them in a single binary tree.

The merge rule is that if two nodes overlap, then sum of node values is the new value of the merged node.

Otherwise, the non-null node will be used as the node of new tree.



Problem Constraints
1 <= Number of Nodes in A , B <= 105



Input Format
First argument is an pointer to the root of binary tree A.

Second argument is an pointer to the root of binary tree B.



Output Format
Return a pointer to the root of new binary tree.



Example Input
Input 1:

 A =   2

      / \

     1   4

    /

   5


B =   3
      / \
      6  1
      \   \
       2   7

Input 2:

 A =   12

      / \

     11  14            


B =   3
      / \
      6  1



Example Output
Output 1:

     5
    / \
   7   5
  / \   \ 
 5   2   7
Output 2:

   15
  / \
 17  15


Example Explanation
Explanation 1:

 After merging both the trees you get:
     5
    / \
   7   5
  / \   \ 
 5   2   7
Explanation 2:

 After merging both the trees we get:
   15
  / \
 17  15","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
/* Function to merge given two binary trees*/
TreeNode *MergeTrees(TreeNode * t1, TreeNode * t2) 
{ 
    if (!t1) 
        return t2; 
    if (!t2) 
        return t1; 
    t1->val += t2->val; 
    t1->left = MergeTrees(t1->left, t2->left); 
    t1->right = MergeTrees(t1->right, t2->right); 
    return t1; 
} 
TreeNode* Solution::solve(TreeNode* A, TreeNode* B) {
    assert( A && B);
    return MergeTrees(A,B);
}"
Maximum Ones After Modification,https://www.interviewbit.com/problems/maximum-ones-after-modification/,Amazon,Two Pointers,medium,"Problem Description

Given a binary array A and a number B, we need to find length of the longest subsegment of ‘1’s possible by changing at most B ‘0’s.



Problem Constraints
 1 <= N, B <= 105

 A[i]=0 or A[i]=1



Input Format
First argument is an binary array A.

Second argument is an integer B.



Output Format
Return a single integer denoting the length of the longest subsegment of ‘1’s possible by changing at most B ‘0’s.



Example Input
Input 1:

 A = [1, 0, 0, 1, 1, 0, 1]
 B = 1
Input 2:

 A = [1, 0, 0, 1, 0, 1, 0, 1, 0, 1]
 B = 2


Example Output
Output 1:

 4
Output 2:

 5


Example Explanation
Explanation 1:

 Here, we should only change 1 zero(0). Maximum possible length we can get is by changing the 3rd zero in the array,
 we get a[] = {1, 0, 0, 1, 1, 1, 1}
Explanation 2:

 Here, we can change only 2 zeros. Maximum possible length we can get is by changing the 3rd and 4th (or) 4th and 5th zeros.","int longestSubSeg(vector<int>& a, int n, int k) 
{ 
    int cnt0 = 0; 
    int l = 0; 
    int max_len = 0; 
  
    // i decides current ending point 
    for (int i = 0; i < n; i++) { 
        if (a[i] == 0) 
            cnt0++; 
  
        // If there are more 0's move 
        // left point for current ending 
        // point. 
        while (cnt0 > k) { 
            if (a[l] == 0) 
                cnt0--; 
            l++; 
        } 
  
        max_len = max(max_len, i - l + 1); 
    } 
  
    return max_len; 
} 
  
int Solution::solve(vector<int> &A, int B) {
    return longestSubSeg(A,A.size(),B);
}"
Is Rectangle?,https://www.interviewbit.com/problems/is-rectangle/,N/A,Math,easy,"Problem Description

Given four positive integers A, B, C, D, determine if there’s a rectangle such that the lengths of its sides are A, B, C and D (in any order).

If any such rectangle exist return 1 else return 0.



Problem Constraints
1 <= A, B, C, D <= 100



Input Format
First argument is an interger A.

Second argument is an interger B.

Third argument is an interger C.

Fourth argument is an interger D.



Output Format
If any such rectangle exist whose sides are A, B, C, D in any orde then return 1 else return 0.



Example Input
Input 1:

 A = 1
 B = 1
 C = 2
 D = 2
Input 2:

 A = 1
 B = 2
 C = 3
 D = 4


Example Output
Output 1:

 1
Output 2:

 0


Example Explanation
Explanation 1:

 
 The rectangle drawn above is one of the rectangles that can be formed by side length of 1, 1, 2, 2 so we will return 1.
Explanation 2:

 No such rectangle exist whose sides are 1, 2, 3, 4. So, we will return 0.
","bool isRectangle(int a, int b, int c, int d)
{
    // Square is also a rectangle
    if (a == b && b == c && c == d)
        return true;

    else if (a == b && c == d)
        return true;
    else if (a == d && c == b)
        return true;
    else if (a == c && d == b)
        return true;
    else
        return false;
}

int Solution::solve(int A, int B, int C, int D) {
    if(isRectangle(A,B,C,D))return 1;
    return 0;
}"
Snake Ladder Problem!,https://www.interviewbit.com/problems/snake-ladder-problem/,Amazon,Graph Data Structure & Algorithms,medium,"Problem Description

Rishabh takes out his Snakes and Ladders Game, stares the board and wonders: ""If I can always roll the die to whatever number I want, what would be the least number of rolls to reach the destination?""

 

 

RULES:

The game is played with cubic dice of 6 faces numbered from 1 to 6.
Starting from 1 , land on square 100 with the exact roll of the die. If moving the number rolled would place the player beyond square 100, no move is made.
If a player lands at the base of a ladder, the player must climb the ladder. Ladders go up only.
If a player lands at the mouth of a snake, the player must go down the snake and come out through the tail. Snakes go down only.
BOARD DESCRIPTION:

The board is always 10 x 10 with squares numbered from 1 to 100.
The board contains N ladders given in a form of 2D matrix A of size N * 2 where (A[i][0], A[i][1]) denotes a ladder that has its base on square A[i][0] and end at square A[i][1].
The board contains M snakes given in a form of 2D matrix B of size M * 2 where (B[i][0], B[i][1]) denotes a snake that has its mouth on square B[i][0] and tail at square B[i][1].
 

 

 



Problem Constraints

1 <= N, M <= 15

 

 

 

1 <= A[i][0], A[i][1], B[i][0], B[i][1] <= 100

A[i][0] < A[i][1] and B[i][0] > B[i][1]

Neither square 1 nor square 100 will be the starting point of a ladder or snake.

A square will have at most one endpoint from either a snake or a ladder.

 

 

 



Input Format

First argument is a 2D matrix A of size N * 2 where (A[i][0], A[i][1]) denotes a ladder that has its base on square A[i][0] and end at square A[i][1].

 

 

 

Second argument is a 2D matrix B of size M * 2 where (B[i][0], B[i][1]) denotes a snake that has its mouth on square B[i][0] and tail at square B[i][1].

 

 

 



Output Format

Return the least number of rolls to move from start to finish on a separate line. If there is no solution, return -1.



Example Input

Input 1:

 

 

 

 A = [  [32, 62]
        [42, 68]
        [12, 98]
     ]
 B = [  [95, 13]
        [97, 25]
        [93, 37]
        [79, 27]
        [75, 19]
        [49, 47]
        [67, 17]
Input 2:

 A = [  [8, 52]
        [6, 80]
        [26, 42]
        [2, 72]
     ]
 B = [  [51, 19]
        [39, 11]
        [37, 29]
        [81, 3]
        [59, 5]
        [79, 23]
        [53, 7]
        [43, 33]
        [77, 21] 
 

 

 



Example Output

Output 1:

 

 

 

 3
Output 2:

 5
 

 

 



Example Explanation

Explanation 1:

 

 

 

 The player can roll a 5 and a 6 to land at square 12. There is a ladder to square 98. A roll of 2 ends the traverse in 3 rolls.
Explanation 2:

 The player first rolls 5 and climbs the ladder to square 80. Three rolls of 6 get to square 98.
 A final roll of 2 lands on the target square in 5 total rolls.
 

 

 

","int Solution::snakeLadder(vector<vector<int> > &A, vector<vector<int> > &B) {
    int n = A.size(), m = B.size();
    vector<vector<int>> g(101);
    for(int i = 1; i <= 99; i++){
        for(int j = 1; j <= 6; j++){
            if(i + j <= 100){
                bool f = 0;
                for(auto x : A){
                    if(x[0] == i + j){
                        g[i].push_back(x[1]);
                        f = 1;
                        break;
                    }
                }
                for(auto x : B){
                    if(x[0] == i + j){
                        g[i].push_back(x[1]);
                        f = 1;
                        break;
                    }
                }
                if(!f){
                    g[i].push_back(i + j);
                }
            }
        }
    }
    vector<bool> vis(101, 0);
    vector<int> dist(101);
    queue<int> q;
    q.push(1);
    vis[1] = 1;
    dist[1] = 0;
    while(!q.empty()){
        int u = q.front();
        q.pop();
        for(int v : g[u]){
            if(!vis[v]){
                q.push(v);
                vis[v] = 1;
                dist[v] = dist[u] + 1;
            }
        }
    }
    if(vis[100]){
        return dist[100];
    }
    return -1;
}"
Region in BinaryMatrix,https://www.interviewbit.com/problems/region-in-binarymatrix/,Amazon,Graph Data Structure & Algorithms,easy,"Problem Description

Given a binary matrix A of size N x M.

 Cells which contain 1 are called filled cell and cell that contain 0 are called empty cell.

Two cells are said to be connected if they are adjacent to each other horizontally, vertically, or diagonally.

If one or more filled cells are also connected, they form a region. Find the length of the largest region.



Problem Constraints
 1 <= N, M <= 102

 A[i][j]=0 or A[i][j]=1



Input Format
First argument is a 2D binary matrix Aof size  N x M.



Output Format
Return a single interger denoting the length of largest region.



Example Input
Input 1:

 A = [  [0, 0, 1, 1, 0]
        [1, 0, 1, 1, 0]
        [0, 1, 0, 0, 0]
        [0, 0, 0, 0, 1]
    ]
Input 2:

 A = [  [1, 1, 1]
        [0, 0, 1]
    ]


Example Output
Output 1:

 6
Output 2:

 4


Example Explanation
Explanation 1:

 The largest region is denoted by red color in the matrix:
    00110
    10110
    01000
    00001
Explanation 2:

 The largest region is:
    111
    001
","int dfs(int row, int col, vector<vector<bool>> &vis, int maxRow, int maxCol, vector<vector<int>> &A){
    vis[row][col] = 1;
    int regionSize = 1;
    for(int r = -1;r<=1;r++){
        for(int c=-1;c<=1;c++){
            int newRow = row + r;
            int newCol = col + c;
            if(newRow<maxRow && newRow>=0 && newCol<maxCol && newCol>=0 && A[newRow][newCol] == 1 && !vis[newRow][newCol]){
                regionSize += dfs(newRow, newCol, vis, maxRow, maxCol, A);
            }
        }
    }
    return regionSize;
}

int Solution::solve(vector<vector<int> > &A) {
    int rows = A.size();
    int cols = A[0].size();
    vector<vector<bool>> vis (A.size(), vector<bool>(A[0].size()));
    int maxSize = 0;
    for(int i=0;i<rows;i++){
        for(int j=0;j<cols;j++){
            if(A[i][j] == 1 && !vis[i][j]){
                maxSize = max(maxSize, dfs(i, j, vis, rows, cols, A));
            }
        }
    }
    return maxSize;
}"
Balanced Parantheses!,https://www.interviewbit.com/problems/balanced-parantheses/,"Amazon, Google",Stacks And Queues,easy,"Problem Description

Given a string A consisting only of '(' and ')'.

You need to find whether parantheses in A is balanced or not ,if it is balanced then return 1 else return 0.



Problem Constraints
1 <= |A| <= 105



Input Format
First argument is an string A.



Output Format
Return 1 if parantheses in string are balanced else return 0.



Example Input
Input 1:

 A = ""(()())""
Input 2:

 A = ""(()""


Example Output
Output 1:

 1
Output 2:

 0


Example Explanation
Explanation 1:

 Given string is balanced so we return 1
Explanation 2:

 Given string is not balanced so we return 0","int Solution::solve(string A) 
{
    stack<int> s;
    for(int i=0;i<A.size();i++)
    {
        if(A[i]=='(')
        {
            s.push(i);
        }
        else
        {
            if(s.empty())
            {
                return 0;
            }
            s.pop();
        }
    }
    return s.empty();
    
}"
Pairs With Given Xor,https://www.interviewbit.com/problems/pairs-with-given-xor/,Flipkart,Hashing,medium,"Problem Description

Given an 1D integer array A containing N distinct integers.

Find the number of unique pairs of integers in the array whose XOR is equal to B.

NOTE:

Pair (a, b) and (b, a) is considered to be same and should be counted once.


Problem Constraints
1 <= N <= 105

1 <= A[i], B <= 107



Input Format
First argument is an 1D integer array A.

Second argument is an integer B.



Output Format
Return a single integer denoting the number of unique pairs of integers in the array A whose XOR is equal to B.



Example Input
Input 1:

 A = [5, 4, 10, 15, 7, 6]
 B = 5
Input 2:

 A = [3, 6, 8, 10, 15, 50]
 B = 5


Example Output
Output 1:

 1
Output 2:

 2


Example Explanation
Explanation 1:

 (10 ^ 15) = 5
Explanation 2:

 (3 ^ 6) = 5 and (10 ^ 15) = 5 
","// Returns count of pairs in arr[0..n-1] with XOR 
// value equals to x. 
int xorPairCount(vector<int>&arr,int x) 
{ 
    int n=arr.size();
    int result = 0; // Initialize result 
  
    // create empty set that stores the visiting  
    // element of array.  
    // Refer below post for details of unordered_set 
    // https://www.geeksforgeeks.org/unorderd_set-stl-uses/ 
    unordered_set<int> s; 
  
    for (int i=0; i<n ; i++) 
    { 
        // If there exist an element in set s 
        // with XOR equals to x^arr[i], that means 
        // there exist an element such that the 
        // XOR of element with arr[i] is equal to 
        // x, then increment count. 
        if (s.find(x^arr[i]) != s.end()) 
            result++; 
  
        // Make element visited 
        s.insert(arr[i]); 
    } 
  
    // return total count of pairs with XOR equal to x 
    return result; 
} 
int Solution::solve(vector<int> &A, int B) {
    return xorPairCount(A,B);
}"
Maximum Size Square Sub-matrix,https://www.interviewbit.com/problems/maximum-size-square-sub-matrix/,Flipkart,Dynamic Programming,medium,"Problem Description
 
 

Given a 2D binary matrix A of size  N x M  find the area of maximum size square sub-matrix with all 1's.



Problem Constraints
1 <= N, M <= 103

 A[i][j] = 1 or A[i][j] = 0



Input Format
First argument is an 2D matrix A of size N x M.



Output Format
Output the area of maximum size square sub-matrix in A with all 1's.



Example Input
Input 1:

 A = [

        [0, 1, 1, 0, 1],

        [1, 1, 0, 1, 0],

        [0, 1, 1, 1, 0],

        [1, 1, 1, 1, 0],

        [1, 1, 1, 1, 1],

        [0, 0, 0, 0, 0]
     ]
Input 2:

 A = [

       [1, 1],
       [1, 1]
     ]


Example Output
Output 1:

 9
Output 2:

 4


Example Explanation
Explanation 1:

  Consider the below binary matrix.
 
 The area of the square is 3 * 3 = 9
Explanation 2:

 The given matrix is the largest size square possible so area will be 2 * 2 = 4
","int Solution::solve(vector<vector<int> > &A) {
    int m=A.size();if(m==0)return 0;
    int n=A[0].size(),ans=0;
    vector< vector<int> >dp(m+1,vector<int>(n+1,0));
       for(int i = 0; i < m; i++)  
        {dp[i][0] = A[i][0]; ans=max(ans,dp[i][0]);}  
    for(int j = 0; j < n; j++)  
        {dp[0][j] = A[0][j];  ans=max(ans,dp[0][j]);}
     for(int i= 1; i < m; i++)  
    {  
        for(int j = 1; j < n; j++)  
        {  
            if(A[i][j] == 1)  
                dp[i][j] = min(dp[i][j-1],min( dp[i-1][j],  
                                dp[i-1][j-1])) + 1;  
            else
                dp[i][j] = 0;
                ans=max(ans,dp[i][j]);
        }  
    }  
    return ans*ans;
}"
Min Cost Path,https://www.interviewbit.com/problems/min-cost-path/,Directi,Graph Data Structure & Algorithms,hard,"Problem Description

You are given a AB character matrix named C. Every cell in C has a character U,R,L or D indicating up,right,left and down.

Your target is to go from top left corner to the bottom right corner of the matrix.

But there are some restrictions while moving along the matrix:

If you follow what is written in the cell then you can move freely.
But if you don't follow what is written in the cell then you have to pay 1 unit of cost.
Like: If a cell contains character U and you go right instead of Up you have to pay 1 unit of cost.

So your task is to find the minimum cost to go from top-left corner to the bottom-right corner.



Problem Constraints
1 <= A,B <= 103
C[i][j] can be either U,R,L or D.


Input Format
First Argument represents a integer A (number of rows).
Second Argument represents a integer B (number of columns).
Third Argument represents a string array C which contains A strings each of length B.


Output Format
 Return an integer denoting the minimum cost to travel from top-left corner to bottom-right corner.



Example Input
Input:1

 A = 3
 B = 3
 C = [""RRR"",""DDD"",""UUU""]
Input:2

 A = 1
 B = 4
 C = [""LLLL""]


Example Output
Output-1 :

 1
Output-2 :

 3


Example Explanation*
Explanation for Input-1:

 Matrix looks like: RRR
                    DDD
                    UUU
 We go right two times and down two times.
 So from top-right cell we are going down though right is given so this incurs a cost of 1.
Explanation for Input-2:

 Matrix looks like: LLLL
 We go right three times.","int Solution::solve(int n, int m, vector<string> &C) {
    const int inf=1e9;
    vector<vector<int>>dis;
    dis.assign(n,vector<int>(m,inf));
    dis[0][0]=0;
    deque<pair<int,int>>q;
    q.push_front({0,0});
    while(!q.empty()){
        auto f=q.front();
        q.pop_front();
        int i=f.first,j=f.second;
        int a=i,b=j;
        if(C[i][j]=='U')
            a--;
        if(C[i][j]=='D')
            a++;
        if(C[i][j]=='L')
            b--;
        if(C[i][j]=='R')
            b++;
        if(a>=0&&a<n&&b>=0&&b<m){
            if(dis[a][b]>dis[i][j]){
                dis[a][b]=dis[i][j];
                q.push_front({a,b});
            }
        }
        if(i+1<n&&dis[i+1][j]>dis[i][j]+1){
            dis[i+1][j]=dis[i][j]+1;
            q.push_back({i+1,j});
        }
        if(i>0&&dis[i-1][j]>dis[i][j]+1){
            dis[i-1][j]=dis[i][j]+1;
            q.push_back({i-1,j});
        }
        if(j+1<m&&dis[i][j+1]>dis[i][j]+1){
            dis[i][j+1]=dis[i][j]+1;
            q.push_back({i,j+1});
        }
        if(j>0&&dis[i][j-1]>dis[i][j]+1){
            dis[i][j-1]=dis[i][j]+1;
            q.push_back({i,j-1});
        }
    }
    return dis[n-1][m-1];
}"
Minimum Lights to Activate,https://www.interviewbit.com/problems/minimum-lights-to-activate/,Directi,Arrays,easy,"Problem Description
 
 

There is a corridor in a Jail which is N units long. Given an array A of size N. The ith index of this array is 0 if the light at ith position is faulty otherwise it is 1.

All the lights are of specific power B which if is placed at position X, it can light the corridor from [ X-B+1, X+B-1].

Initially all lights are off.

Return the minimum number of lights to be turned ON to light the whole corridor or -1 if the whole corridor cannot be lighted.



Problem Constraints
1 <= N <= 100000

1 <= B <= 10000



Input Format
First argument is an integer array A where A[i] is either 0 or 1.

Second argument is an integer B.



Output Format
Return the minimum number of lights to be turned ON to light the whole corridor or -1 if the whole corridor cannot be lighted.


Example Input
Input 1:

A = [ 0, 0, 1, 1, 1, 0, 0, 1].
B = 3
Input 2:

A = [ 0, 0, 0, 1, 0].
B = 3


Example Output
Output 1:

2
Output 2:

-1


Example Explanation
Explanation 1:

In the first configuration, Turn on the lights at 2nd and 7th index. 
Light at 2nd index covers from [ 1, 5] and light at 7th index covers [6, 8].
Explanation 2:

In the second configuration, there is no light which can light the first corridor.
","int Solution::solve(vector<int> &A, int B) {
    int n = (int)A.size(), i = 0, ans = 0;
    if(B == 0)
        return -1;
    //Start from 0th index
    while(i<n)
    {
        int idx = -1;
        //check range [X-B+1, X+B-1] and find rightmost bulb
        for(int j=max(0, i-B+1);j<min(n,i+B);j++)
        {
            if(A[j] == 1)
                idx = j;
        }
        if(idx == -1)
            return -1;
        ans++;
        //Start now from index which is outside the current selected bulb
        i = idx+B;
    }
    return ans;
}"
Two teams?,https://www.interviewbit.com/problems/two-teams/,Directi,Graph Data Structure & Algorithms,medium,"Problem Description

There are A people numbered 1 to A in a football academy.

The coach of the academy wants to make two teams (not necessary of equal size) but unfortunately, not all people get along, and several refuse to be put on the same team as that of their enemies.

Given a 2-D array B of size M x 2 denoting the enemies i.e B[i][0] and B[i][1] both are enemies of each other.

Return 1 if it possible to make exactly two teams else return 0.



Problem Constraints
2 <= A <= 105

1 <= M <= 105

1 <= B[i][0], B[i][1] <= A

B[i][0] != B[i][1]



Input Format
First argument is an integer A denoting number of peoples.

Second argument is a 2-D array B of size M x 2 denoting enemies.



Output Format
Return 1 if it possible to make exactly two teams else return 0.



Example Input
Input 1:

 A = 5
 B = [ [1, 2],
       [2, 3],
       [1, 5],
       [2, 4] ] 
Input 2:

 A = 4
 B = [ [1, 4],
       [3, 1],
       [4, 3],
       [2, 1] ]


Example Output
Output 1:

 1 
Output 2:

 0 


Example Explanation
Explanation 1:

 We can make two teams [1, 3, 4] and [2, 5].
Explanation 2:

 No possible way to create two teams. So, we need to return 0.
","vector<int> g[100005];
int ans,vis[100005];
void dfs(int i)
{
    for(auto j:g[i])
    {
        if(!vis[j])
        {
            vis[j]=3-vis[i];
            dfs(j);
        }
        else if(vis[i]==vis[j])
            ans=0;
    }
}
int Solution::solve(int A, vector<vector<int> > &B) {
    for(auto i:B)
    {
        g[i[0]].push_back(i[1]);
        g[i[1]].push_back(i[0]);
    }
    int ret=1;
    for(int i=1;i<=A;i++)
    {
        if(vis[i])
            continue;
        vis[i]=1;
        ans=1;
        dfs(i);
        ret&=ans;
    }
    for(int i=1;i<=A;i++)
    {
        g[i].clear();
        vis[i]=0;
    }
    return ret;
}"
Even Reverse,https://www.interviewbit.com/problems/even-reverse/,Amazon,Linked Lists,medium,"Problem Description

Given a linked list A , reverse the order of all nodes at even positions.



Problem Constraints
1 <= Size of linked list <= 100000



Input Format
First and only argument is the head of the Linked-List A.



Output Format
Return the head of the new linked list.



Example Input
Input 1:

A = 1 -> 2 -> 3 -> 4
Input 2:

A = 1 -> 2 -> 3


Example Output
Output 1:

 1 -> 4 -> 3 -> 2
Output 2:

 1 -> 2 -> 3


Example Explanation
Explanation 1:

Nodes are positions 2 and 4 have been swapped.
Explanation 2:

No swapping neccassary here.","/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
 
 func reverseLinkedList(_ head: ListNode?) -> ListNode? {
    if (head!.next == nil){ return head}
    
    var cur: ListNode? = head
    var nextNode: ListNode? = head!.next
    while (nextNode != nil) {
        var tmp: ListNode? = nextNode!.next
        nextNode!.next = cur
        cur = nextNode
        nextNode = tmp
    }

    head!.next = nextNode
    return cur
}
ListNode* Solution::solve(ListNode* A) {
    var count: Int = 1

    vector<int> even;
    vector<int> odd;
    ListNode * ans=A;
    while(A !=NULL)
    {
        if(count%2)
            odd.push_back(A ->val);
        else
            even.push_back(A -> val);
        count++;
        A=A->next;
    }
    int fincount=count-1;
    reverse(even.begin(),even.end());
    count=1;
    A=ans;
    while(A!=NULL)
    {
        if(count%2 == 0)
            A->val=even[count/2-1];
        count++;
        A=A->next;
        
    }
    return ans;
    
}"
Check Palindrome!,https://www.interviewbit.com/problems/check-palindrome/,N/A,Hashing,easy,"Problem Description
 
 

Given a string A consisting of lowercase characters.

Check if characters of the given string can be rearranged to form a palindrome.

Return 1 if it is possible to rearrange the characters of the string A such that it becomes a palindrome else return 0.



Problem Constraints
1 <= |A| <= 105

A consists only of lower-case characters.



Input Format
First argument is an string A.



Output Format
Return 1 if it is possible to rearrange the characters of the string A such that it becomes a palindrome else return 0.



Example Input
Input 1:

 A = ""abcde""
Input 2:

 A = ""abbaee""


Example Output
Output 1:

 0
Output 2:

 1


Example Explanation
Explanation 1:

 No possible rearrangement to make the string palindrome.
Explanation 2:

 Given string ""abbaee"" can be rearranged to ""aebbea"" to form a palindrome.","int Solution::solve(string A) {
  int hashMap[26] = {0};
  for (char a: A)
    hashMap[a - 'a']++;
  int odd = 0;
  for (int a: hashMap)
    if (a % 2)
      odd++;
  if (odd > 1)
    return 0;
  return 1;
}"
Vowel and Consonant Substrings!,https://www.interviewbit.com/problems/vowel-and-consonant-substrings/,N/A,Strings,easy,"Problem Description
 
 

Given a string A consisting of lowercase characters.

You have to find the number of substrings in A which starts with vowel and end with consonants or vice-versa.

Return the count of substring modulo 109 + 7.



Problem Constraints
1 <= |A| <= 105

A consists only of lower-case characters.



Input Format
First argument is an string A.



Output Format
Return a integer denoting the the number of substrings in A which starts with vowel and end with consonants or vice-versa with modulo 109 + 7.



Example Input
Input 1:

 A = ""aba""
Input 2:

 A = ""a""


Example Output
Output 1:

 2
Output 2:

 0


Example Explanation
Explanation 1:

 Substrings of S are : [a, ab, aba, b, ba, a]Out of these only 'ab' and 'ba' satisfy the condition for special Substring. So the answer is 2.
Explanation 2:

 No possible substring that start with vowel and end with consonant or vice-versa.
","int Solution::solve(string A) {
    long int  l = A.length();
    long int mod = 1000000007;

    int vowel =0, cons =0;
    long int sum=0;

    for(int i=0;i<l;i++){
        A[i] = tolower(A[i]);
            if(A[i]=='a' || A[i]=='e' || A[i]=='i'|| A[i]=='o'|| A[i]=='u'){
                sum = ((sum+ cons%mod)%mod);
                vowel++;
            }
            else{
                sum = ((sum+ vowel%mod)%mod);
                cons++;
            }
    }

    return sum;
}"
Minimum Appends for Palindrome!,https://www.interviewbit.com/problems/minimum-appends-for-palindrome/,Facebook,Strings,medium,"Problem Description

Given a string A consisting of lowercase characters.

We need to tell minimum characters to be appended (insertion at end) to make the string A a palindrome.



Problem Constraints
1 <= |A| <= 105

A consists only of lower-case characters.



Input Format
First argument is an string A.



Output Format
Return a integer denoting the minimum characters to be appended (insertion at end) to make the string A a palindrome.



Example Input
Input 1:

 A = ""abede""
Input 2:

 A = ""aabb""


Example Output
Output 1:

 2
Output 2:

 2


Example Explanation
Explanation 1:

 We can make string palindrome as ""abedeba"" by adding ba at the end of the string.
Explanation 2:

 We can make string palindrome as ""aabbaa"" by adding aa at the end of the string.
","int lps[2000009];
void prelps(string A)
{
    memset(lps,0,sizeof(lps));
    int n=A.size();
    int j=0;
    int i=1;
    while(i<n)
    {
        if(A[i]==A[j])
        {
            lps[i]=j+1;
            i++;
            j++;
        }
        else
        {
            if(j!=0)
                j=lps[j-1];
            else
            {
                lps[i]=0;
                i++;
            }
        }
    }
}
int Solution::solve(string A) {
    assert(A.size()<=1000000);
    string b=A;
    reverse(A.begin(),A.end());
    string C=A+""$""+b;
    prelps(C);
    int len=C.size();
    return A.size()-lps[len-1];
}"
Maximal String,https://www.interviewbit.com/problems/maximal-string/,Apple,Backtracking,medium,"Problem Description
 
 

Given a string A and integer B, what is maximal lexicographical string that can be made from A if you do atmost B swaps.



Problem Constraints
1 <= |A| <= 9

A contains only digits from 0 to 9.

1 <= B <= 5



Input Format
First argument is string A.

Second argument is integer B.



Output Format
Return a string, the naswer to the problem.



Example Input
Input 1:

A = ""254""
B = 1
Input 2:

A = ""254""
B = 2


Example Output
Output 1:

 524
Output 2:

 542


Example Explanation
Explanation 1:

 Swap 2 and 5.
Explanation 2:

Swap 2 and 5 then swap 4 and 2.
","void swap(char &a,char &b)
{
    char c=a; a=b; b=c;
}

string ans;
int n;

void check(int i,string &str,int k)
{
    if(ans<str)
    ans=str;
    
    if(!k || i==n)
    return;
    
    check(i+1,str,k);

    for(int j=i+1;j<n;j++)
    {
        if(str[j]>str[i])
        {
            swap(str[j],str[i]); 
            check(i+1,str,k-1);
            swap(str[j],str[i]); 
        }
    }
}
string Solution::solve(string str, int k) 
{
     ans=str;
    n=str.length();
    
     check(0,str,k);
     return ans;
}"
An Increment Problem,https://www.interviewbit.com/problems/an-increment-problem/,Google,Hashing,medium,"Problem Description
 
 

Given a stream of numbers A. On arrival of each number, you need to increase its first occurrence by 1 and include this in the stream.

Return the final stream of numbers.

Note: You will traverse the stream from left to right and update the first occurrence of the number by 1, if found.



Problem Constraints
1 <= |A| <= 100000

1 <= A[i] <= 10000



Input Format
First and only argument is the array A.



Output Format
Return an array, the final stream of numbers.



Example Input
Input 1: 

A = [1, 1]
 

Input 2:

A = [1, 2]
 

Input 3:

A = [1, 1, 2, 2]


Example Output
Output 1:

[2, 1]
 

Output 2:

[1, 2]
 

Output 3:

[3, 1, 3, 2]


Example Explanation
Explanation 1:

On arrival of the second element, the other element is increased by 1.
 

Explanation 2:

No increases are to be done.
 

Explanation 3:

Stream after arrival of numbers (1-based indexing):
  First number  (1): [1]          , Simply push 1 to the stream
  Second number (1): [2, 1]       , Increment first occurence of 1, present at 1st Index and push 1 to the stream
  Third number  (2): [3, 1, 2]    , Increment first occurence of 2, present at 1st Index and push 2 to the stream
  Fourth number (2): [3, 1, 3, 2] , Increment first occurence of 2, present at 3rd Index and push 2 to the stream
","vector<int> Solution::solve(vector<int> &A) {
    vector<int> res;
    for(int i=0;i<A.size();i++) {
        auto it=find(res.begin(),res.end(),A[i]);
        if(it!=res.end()) {
            (*it)++;
            res.push_back(A[i]);
        }
        else {
            res.push_back(A[i]);
        }
    }
    return res;
}"
Large Factorial,https://www.interviewbit.com/problems/large-factorial/,N/A,Arrays,medium,"Problem Description

Given a number A. Find the fatorial of the number.



Problem Constraints
1 <= A <= 100



Input Format
First and only argument is the integer A.



Output Format
Return a string, the factorial of A.



Example Input
Input 1:

A = 2
Input 2:

A = 3


Example Output
Output 1:

 2
Output 2:

 6


Example Explanation
Explanation 1:

2! = 2 .
Explanation 2:

3! = 6 .","int multiply(int x, int res[], int res_size); 
#define MAX 500
// This function finds factorial of large numbers 
// and prints them 
string factorial(int n) 
{ 
    int res[MAX]; 
  
    // Initialize result 
    res[0] = 1; 
    int res_size = 1; 
  
    // Apply simple factorial formula n! = 1 * 2 * 3 * 4...*n 
    for (int x=2; x<=n; x++) 
        res_size = multiply(x, res, res_size); 
    string s="""";
    for(int i=res_size-1;i>=0;i--)
        s+=res[i]+'0';
    return s;
} 
  
int multiply(int x, int res[], int res_size) 
{ 
    int carry = 0;  // Initialize carry 
  
    // One by one multiply n with individual digits of res[] 
    for (int i=0; i<res_size; i++) 
    { 
        int prod = res[i] * x + carry; 
  
        // Store last digit of 'prod' in res[]   
        res[i] = prod % 10;   
  
        // Put rest in carry 
        carry  = prod/10;     
    } 
  
    // Put carry in res and increase result size 
    while (carry) 
    { 
        res[res_size] = carry%10; 
        carry = carry/10; 
        res_size++; 
    } 
    return res_size; 
}
string Solution::solve(int A) {
    return factorial(A);
}"
Remove Consecutive Characters,https://www.interviewbit.com/problems/remove-consecutive-characters/,N/A,Strings,easy,"Problem Description
 
 

Given a string A and integer B, remove all consecutive same characters that have length exactly B.


NOTE : All the consecutive same characters that have length exactly B will be removed simultaneously.



Problem Constraints
1 <= |A| <= 100000

1 <= B <= |A|



Input Format
First Argument is string A.

Second argument is integer B.



Output Format
Return a string after doing the removals.



Example Input
Input 1:

A = ""aabcd""
B = 2
Input 2:

A = ""aabbccd""
B = 2


Example Output
Output 1:

 ""bcd""
Output 2:

 ""d""


Example Explanation
Explanation 1:

 ""aa"" had length 2.
Explanation 2:

 ""aa"", ""bb"" and ""cc"" had length of 2.","string Solution::solve(string A, int B) {
    string ans = """";
    for( int i = 0; i < A.size(); i++ ) {
        int j = i;
        string temp = """";
        while(j < A.size() && A[i] == A[j] ) {
            temp += A[i]; 
            j++;
        } 
        if( j - i != B ) ans += temp; 
        i = j - 1;
    }
    return ans;
}
"
Permutation Swaps!,https://www.interviewbit.com/problems/permutation-swaps/,Directi,Graph Data Structure & Algorithms,medium,"Problem Description

Rishabh has a permutation A of N integers 1, 2, ... N but he doesn't like it. Rishabh wants to get a permutation B.

Also, Rishabh has some M good pairs given in a form of 2D matrix C of size M x 2  where (C[i][0], C[i][1]) denotes that two indexes of the permutation A.

In one operation he can swap Ax and Ay only if (x, y) is a good pair.

You have to tell whether Rishabh can obtain permutation B by performing the above operation any number of times on permutation A.

If the permutation B can be obtained return 1 else return 0.



Problem Constraints
2 <= N <= 105
1 <= M <= 105
1 <= A[i], B[i] <= N
A[i] and B[i] are all distinct.
1 <= C[i][0] < C[i][1] <= N


Input Format
First arguement is an integer array A of size N denoting the permutation A.

Second arguement is an integer array B of size N denoting the permutation B.

Third argument is an 2D integer array C of size M x 2 denoting the M good pairs.



Output Format
If the permutation B can be obtained return 1 else return 0.



Example Input
Input 1:

 A = [1, 3, 2, 4]
 B = [1, 4, 2, 3]
 C = [ 
        [3, 4]
     ]
Input 2:

 A = [1, 3, 2, 4]
 B = [1, 4, 2, 3]
 C = [
        [2, 4]
     ] 


Example Output
Output 1:

 0
Output 2:

 1


Example Explanation
Explanation 1:

 As A != B you have to perform operations on A but there is only good pair available i,e (3, 4) so if you swap
 A3 with A4 you get A = [1, 3, 4, 2] which is not equal to B so we will return 0.
Explanation 2:

 As A != B you have to perform operations on A but there is only good pair available i,e (2, 4) so if you swap
 A2 with A4 you get A = [1, 4, 2, 3] which is equal to B so we will return 1.
","int Solution::solve(vector<int> &A, vector<int> &B, vector<vector<int> > &C) {
    
}"
Delete Edge!,https://www.interviewbit.com/problems/delete-edge/,Flipkart,Graph Data Structure & Algorithms,medium,"Problem Description
 
 

Given an undirected tree with N nodes labeled from 1 to N.

Each node has a certain weight assigned to it given by an integer array A of size N.

You need to delete an edge in such a way that the Product between the sum of weights of nodes in one subtree with the sum of weights of nodes in other subtree is maximized.

Return this maximum possible product modulo 109 + 7.

NOTE:

The tree is rooted at a node labeled with 1.
You need to return the maximum possible product, then take its mod.


Problem Constraints
2 <= N <= 105

1 <= A[i] <= 103



Input Format
First argument is an integer array A of size N denoting the weight of each node.

Second argument is a 2-D array B of size (N-1) x 2 denoting the edge of the tree.



Output Format
Return a single integer denoting the maximum product prossible of sum of weights of nodes in the two subtrees formed by deleting an edge with modulo 109 + 7.



Example Input
Input 1:

 A = [10, 5, 12, 6]
 B = [

        [1, 2]
        [1, 4]
        [4, 3]
     ]
Input 2:

 A = [11, 12]
 B = [

        [1, 2]
     ]


Example Output
Output 1:

 270
Output 2:

 132


Example Explanation
Explanation 1:

 Removing edge (1, 4) created two subtrees.
 Subtree-1 contains nodes (1, 2) and Subtree-2 contains nodes (3, 4)
 So product will be = (A[1] + A[2]) * (A[3] + A[4]) = 15 * 18 = 270
Explanation 2:

 Removing edge (1, 2) created two subtrees.
 Subtree-1 contains node (1) and Subtree-2 contains node (3)
 So product will be = (A[1]) * (A[2]) = 11 * 12 = 132
","const int maxn = 100009;
vector < int > adj[maxn];
long long s;
long long maxe;
const int mod = 1e9 + 7;

int dfs(int u, int p, vector < int > & A) {
  long long sum = A[u - 1];
  for (int v: adj[u]) {
    if (v == p) continue;
    sum += dfs(v, u, A);
  }
  long long res = ((sum ) * ((s - sum) ));
  maxe = max(maxe, res);
  return sum;
}

int Solution::deleteEdge(vector < int > & A, vector < vector < int > > & B) {

  s = 0; //total sum of tree
  maxe = 0; //maximum product

  //clearing the adjacency list
  for (int i = 0; i <= A.size(); i++)
    adj[i].clear();

  //Calculating sum of weights of all nodes
  for (int a: A)
    s += a;

  //Creating tree 
  for (auto & it: B) {
    adj[it[0]].push_back(it[1]);
    adj[it[1]].push_back(it[0]);
  }

  dfs(1, 0, A);

  return maxe%mod;
}"
Maximum Sum Triplet,https://www.interviewbit.com/problems/maximum-sum-triplet/,Directi,Arrays,medium,"Problem Description
 
 

Given an array A containing N integers.

You need to find the maximum sum of triplet ( Ai + Aj + Ak ) such that 0 <= i < j < k < N and Ai < Aj < Ak.

If no such triplet exist return 0.



Problem Constraints
3 <= N <= 105.

1 <= A[i] <= 108.



Input Format
First argument is an integer array A.



Output Format
Return a single integer denoting the maximum sum of triplet as described in the question.



Example Input
Input 1:

 A = [2, 5, 3, 1, 4, 9]
Input 2:

 A = [1, 2, 3]


Example Output
Output 1:

 16
Output 2:

 6


Example Explanation
Explanation 1:

 All possible triplets are:-
    2 3 4 => sum = 9
    2 5 9 => sum = 16
    2 3 9 => sum = 14
    3 4 9 => sum = 16
    1 4 9 => sum = 14
  Maximum sum = 16
Explanation 2:

 All possible triplets are:-
    1 2 3 => sum = 6
 Maximum sum = 6
","int Solution::solve(vector<int> &A) {
    
}"
Find Nth Fibonacci,https://www.interviewbit.com/problems/find-nth-fibonacci/,Facebook,Math,hard,"Problem Description

Given an integer A you need to find the Ath fibonacci number modulo 109 + 7.

The first fibonacci number F1 = 1

The first fibonacci number F2 = 1

The nth fibonacci number Fn = Fn-1 + Fn-2 (n > 2)



Problem Constraints
1 <= A <= 109.



Input Format
First argument is an integer A.



Output Format
Return a single integer denoting Ath fibonacci number modulo 109 + 7.



Example Input
Input 1:

 A = 4
Input 2:

 A = 3


Example Output
Output 1:

 3
Output 2:

 2


Example Explanation
Explanation 1:

 F3 = F2 + F1 = 1 + 1 = 2
 F4 = F3 + F2 = 2 + 1 = 3
Explanation 2:

 F3 = F2 + F1 = 1 + 1 = 2
","const int mod=1e9+7;
#define ll long long
void multiply(ll f[2][2],ll m[2][2])
{
    ll a=(((f[0][0]*m[0][0])%mod)+((f[0][1]*m[1][0])%mod))%mod;
    ll b=(((f[0][0]*m[0][1])%mod)+((f[0][1]*m[1][1])%mod))%mod;
    ll c=(((f[1][0]*m[0][0])%mod)+((f[1][1]*m[1][0])%mod))%mod;
    ll d=(((f[1][0]*m[0][1])%mod)+((f[1][1]*m[1][1])%mod))%mod;
    f[0][0]=a;
    f[0][1]=b;
    f[1][0]=c;
    f[1][1]=d;
}
void power(ll f[2][2],int n)
{
  if(n==0 || n==1)return;
  ll m[2][2]={{1,1},{1,0}};
  power(f,n/2);
  multiply(f,f);
  if(n%2!=0)multiply(f,m);
}
int fib(int n)
{
  if(n==1)return 1;
  ll f[2][2]={{1,1},{1,0}};
  power(f,n-1);
  return f[0][0];
}
int Solution::solve(int A) {
    return fib(A);
}"
Maximum Sum Square SubMatrix,https://www.interviewbit.com/problems/maximum-sum-square-submatrix/,N/A,Arrays,medium,"Problem Description

Given a 2D integer matrix A of size N x N find a B x B submatrix where B<= N and B>= 1, such that sum of all the elements in submatrix is maximum.



Problem Constraints
1 <= N <= 103.

1 <= B <= N 

-102 <= A[i][j] <= 102.



Input Format
First arguement is an 2D integer matrix A.

Second argument is an integer B.



Output Format
Return a single integer denoting the maximum sum of submatrix of size B x B.



Example Input
Input 1:

 A = [
        [1, 1, 1, 1, 1]
        [2, 2, 2, 2, 2]
        [3, 8, 6, 7, 3]
        [4, 4, 4, 4, 4]
        [5, 5, 5, 5, 5]
     ]
 B = 3
Input 2:

 A = [
        [2, 2]
        [2, 2]
    ]
 B = 2


Example Output
Output 1:

 48
Output 2:

 8


Example Explanation
Explanation 1:

    Maximum sum 3 x 3 matrix is
    8 6 7
    4 4 4
    5 5 5
    Sum = 48
Explanation 2:

 Maximum sum 2 x 2 matrix is
  2 2
  2 2
  Sum = 8
","const int maxn = 1009;
int stripSum[maxn][maxn];
int maxSumSub(int k, vector < vector < int > > & mat) {
  int N = mat.size();
  // k must be smaller than or equal to n
  if (k > N) return 0;

  // 1: PREPROCESSING
  // To store sums of all strips of size k x 1
  memset(stripSum, 0, sizeof(stripSum));;

  // Go column by column
  for (int j = 0; j < N; j++) {
    // Calculate sum of first k x 1 rectangle
    // in this column
    int sum = 0;
    for (int i = 0; i < k; i++)
      sum += mat[i][j];
    stripSum[0][j] = sum;

    // Calculate sum of remaining rectangles
    for (int i = 1; i < N - k + 1; i++) {
      sum += (mat[i + k - 1][j] - mat[i - 1][j]);
      stripSum[i][j] = sum;
    }
  }

  // max_sum stores maximum sum and its
  // position in matrix
  int max_sum = INT_MIN;

  // 2: CALCULATE SUM of Sub-Squares using stripSum[][]
  for (int i = 0; i < N - k + 1; i++) {
    // Calculate and print sum of first subsquare
    // in this row
    int sum = 0;
    for (int j = 0; j < k; j++)
      sum += stripSum[i][j];

    // Update max_sum and position of result
    if (sum > max_sum) {
      max_sum = sum;
    }

    // Calculate sum of remaining squares in
    // current row by removing the leftmost
    // strip of previous sub-square and adding
    // a new strip
    for (int j = 1; j < N - k + 1; j++) {
      sum += (stripSum[i][j + k - 1] - stripSum[i][j - 1]);

      // Update max_sum and position of result
      if (sum > max_sum) {
        max_sum = sum;
      }
    }
  }
  return max_sum;
}
int Solution::solve(vector < vector < int > > & A, int B) {
    assert(A.size()==A[0].size() && B>=1 && B<=A.size());
    for(vector<int>a:A)
        for(int b:a)
            assert(b>=-100 && b<=100);
  return maxSumSub(B, A);
}"
Maximum Area of Triangle!,https://www.interviewbit.com/problems/maximum-area-of-triangle/,Directi,Arrays,medium,"Problem Description

Given a character matrix of size N x M in the form of a string array A of size N where A[i] denotes ith row.

Each character in the matrix consists any one of the following three characters {'r', 'g', 'b'} where 'r' denotes red color similarly 'g' denotes green color and 'b' denotes blue color.

You have to find the area of the largest triangle that has one side parallel to y-axis i.e vertical and the color of all three vertices are different.

NOTE:

If the area comes out to be a real number than return the ceil of that number.


Problem Constraints
2 <= N, M <= 103

A[i][j] = 'r' or A[i][j] = 'g' or A[i][j] = 'b'



Input Format
First and only argument is an string array A of size N denoting the 2D character matrix.



Output Format
Return a single integer denoting the area of the largest triangle that has one side parallel to y-axis i.e vertical and the color of all three vertices are different.

If the area comes out to be a real number than return the ceil of that number.



Example Input
Input 1:

 A = [""rrrrr"", ""rrrrg"", ""rrrrr"", ""bbbbb""]
Input 2:

 A = [""rrr"", ""rrr"", ""rrr"", ""rrr""]


Example Output
Output 1:

 10
Output 2:

 0


Example Explanation
Explanation 1:

 The maximum area of triangle is 10.
 Triangle coordinates are (0,0) containing r, (1,4) containing g, (3,0) containing b.
 
Explanation 2:

 All cells have same color so no triangle possible so we will return 0
","int Solution::solve(vector<string> &A) {
    int n = A.size(), m = A[0].size();
    map<char, int> mxr[m], mnr[m], mxc, mnc;
    for(int i = 0; i < n; i++){
        for(int j = 0; j < m; j++){
            mxr[j][A[i][j]] = max(mxr[j][A[i][j]], i);
            if(mnr[j].count(A[i][j]))
                mnr[j][A[i][j]] = min(mnr[j][A[i][j]], i);
            else
                mnr[j][A[i][j]] = i;
            mxc[A[i][j]] = max(mxc[A[i][j]], j);
            if(mnc.count(A[i][j]))
                mnc[A[i][j]] = min(mnc[A[i][j]], j);
            else
                mnc[A[i][j]] = j;
        }
    }
    int ans = 0;
    for(int i = 0; i < m; i++){
        if(mxr[i].count('r') and mxr[i].count('g') and mxc.count('b'))
            ans = max(ans, max(abs(mxr[i]['r'] - mnr[i]['g']) + 1, abs(mxr[i]['g'] - mnr[i]['r']) + 1) * max(abs(mxc['b'] - i) + 1, abs(i - mnc['b']) + 1));
        if(mxr[i].count('g') and mxr[i].count('b') and mxc.count('r'))
            ans = max(ans, max(abs(mxr[i]['g'] - mnr[i]['b']) + 1, abs(mxr[i]['b'] - mnr[i]['g']) + 1) * max(abs(mxc['r'] - i) + 1, abs(i - mnc['r']) + 1));
        if(mxr[i].count('r') and mxr[i].count('b') and mxc.count('g'))
            ans = max(ans, max(abs(mxr[i]['r'] - mnr[i]['b']) + 1, abs(mxr[i]['b'] - mnr[i]['r']) + 1) * max(abs(mxc['g'] - i) + 1, abs(i - mnc['g']) + 1));
    }
    return (ans + 1)/2;
}"
Profit Maximisation,https://www.interviewbit.com/problems/profit-maximisation/,N/A,Heaps And Maps,easy,"Problem Description
 
 

 Given an array A , representing seats in each row of a stadium. You need to sell tickets to B people.

Each seat costs equal to the number of vacant seats in the row it belongs to. The task is to maximize the profit by selling the tickets to B people.



Problem Constraints
1 <= |A| <= 100000

1 <= B <= 1000000



Input Format
First argument is the array A.

Second argument is integer B.



Output Format
Return one integer, the answer to the problem.



Example Input
Input 1:

A = [2, 3]
B = 3
Input 2:

A = [1, 4]
B = 2


Example Output
Output 1:

7
Output 2:

7


Example Explanation
Explanation 1:

 First you serve the seat with number = 3. Then with 2 and then with 2. hence answer = 3 + 2 + 2 = 7.
Explanation 2:

 You give both tickets from the row with 4 seats. 4 + 3 = 7.","int maxProfit(vector<int> seats, int n)
{

    // Push all the vacant seats
    // in a priority queue
    int k=seats.size();
    priority_queue<int> pq;
    for (int i = 0; i < k; i++)
        pq.push(seats[i]);

    // To store the maximized profit
    int profit = 0;

    // To count the people that
    // have been sold a ticket
    int c = 0;
    while (c < n) {

        // Get the maximimum number of
        // vacant seats for any row
        int top = pq.top();

        // Remove it from the queue
        pq.pop();

        // If there are no vacant seats
        if (top == 0)
            break;

        // Update the profit
        profit = profit + top;

        // Push the updated status of the
        // vacant seats in the current row
        pq.push(top - 1);

        // Update the count of persons
        c++;
    }
    return profit;
}
int Solution::solve(vector<int> &A, int B) {
    return maxProfit(A,B);
}"
Perfect Peak of Array,https://www.interviewbit.com/problems/perfect-peak-of-array/,Flipkart,Arrays,easy,"Problem Description
 
 

Given an integer array A of size N.

You need to check that whether there exist a element which is strictly greater than all the elements on left of it and strictly smaller than all the elements on right of it.

If it exists return 1 else return 0.

NOTE:

Do not consider the corner elements i.e A[0] and A[N-1] as the answer.


Problem Constraints
3 <= N <= 105

1 <= A[i] <= 109



Input Format
First and only argument is an integer array A containing N integers.



Output Format
Return 1 if there exist a element that is strictly greater than all the elements on left of it and strictly  smaller than all the elements on right of it else return 0.



Example Input
Input 1:

 A = [5, 1, 4, 3, 6, 8, 10, 7, 9]
Input 2:

 A = [5, 1, 4, 4]


Example Output
Output 1:

 1
Output 2:

 0


Example Explanation
Explanation 1:

 A[4] = 6 is the element we are looking for.
 All elements on left of A[4] are smaller than it and all elements on right are greater.
Explanation 2:

 No such element exits.
","int findElement(vector<int>& arr) 
{ 
    int n=arr.size();
    // leftMax[i] stores maximum of arr[0..i-1] 
    int leftMax[n]; 
    leftMax[0] = INT_MIN; 
  
    // Fill leftMax[]1..n-1] 
    for (int i = 1; i < n; i++) 
        leftMax[i] = max(leftMax[i-1], arr[i-1]); 
  
    // Initialize minimum from right 
    int rightMin = arr[n-1]; 
  
    // Traverse array from right 
    for (int i=n-2; i>=1; i--) 
    { 
        // Check if we found a required element 
        if (leftMax[i] < arr[i] && rightMin > arr[i]) 
        {
             return 1; 
        }
        // Update right minimum 
        rightMin = min(rightMin, arr[i]); 
    } 
  
    // If there was no element matching criteria 
    return 0; 
} 
int Solution::perfectPeak(vector<int> &A) {
    return findElement(A);
}"
Subarray with given XOR,https://www.interviewbit.com/problems/subarray-with-given-xor/,N/A,Hashing,medium,"Problem Description
 
 

Given an array of integers A and an integer B.

Find the total number of subarrays having bitwise XOR of all elements equals to B.



Problem Constraints
1 <= length of the array <= 105

1 <= A[i], B <= 109



Input Format
The first argument given is the integer array A.

The second argument given is integer B.



Output Format
Return the total number of subarrays having bitwise XOR equals to B.



Example Input
Input 1:

 A = [4, 2, 2, 6, 4]
 B = 6
Input 2:

 A = [5, 6, 7, 8, 9]
 B = 5


Example Output
Output 1:

 4
Output 2:

 2


Example Explanation
Explanation 1:

 The subarrays having XOR of their elements as 6 are:
 [4, 2], [4, 2, 2, 6, 4], [2, 2, 6], [6]
Explanation 2:

 The subarrays having XOR of their elements as 5 are [5] and [5, 6, 7, 8, 9]
","int Solution::solve(vector<int> &A, int B) {
    int n = A.size();
    int ans = 0; // Initialize answer to be returned

    // Create a prefix xor-sum array such that xorArr[i] has value equal to XOR of all elements in A[0 ..... i]
    int xorArr[n];

    // Create map that stores number of prefix array elements corresponding to a XOR value
    unordered_map<int, int> mp;

    // Initialize first element of prefix array
    xorArr[0] = A[0];

    // Computing the prefix array.
    for (int i = 1; i < n; i++)
        xorArr[i] = xorArr[i - 1] ^ A[i];

    // Calculate the answer
    for (int i = 0; i < n; i++) {
      // Find XOR of current prefix with m.
        int tmp = B ^ xorArr[i];

        // If above XOR exists in map, then there is another previous prefix with same XOR, i.e., there is a subarray ending at i with XOR equal to B.
        ans = ans + mp[tmp];

        // If this subarray has XOR equal to m itself.
        if (xorArr[i] == B)
            ans++;

        // Add the XOR of this subarray to the map
        mp[xorArr[i]]++;
    }

    // Return total count of subarrays having XOR of elements as given value m
    return ans;
}"
Two out of Three,https://www.interviewbit.com/problems/two-out-of-three/,N/A,Hashing,medium,"Problem Description

Given are Three arrays A, B and C.

Return the sorted list of numbers that are present in atleast 2 out of the 3 arrays.



Problem Constraints
1 <= |A|, |B|, |C| <= 100000

1 <= A[i], B[i], C[i] <= 100000

A, B, C may or may not have pairwise distinct elements.



Input Format
First argument is the array A.

First argument is the array B.

First argument is the array C.



Output Format
Return a sorted array of numbers.



Example Input
Input 1:

A = [1, 1, 2]
B = [2, 3]
C = [3]
Input 2:

A = [1, 2]
B = [1, 3]
C = [2, 3]


Example Output
Output 1:

[2, 3]
Output 2:

[1, 2, 3]


Example Explanation
Explanation 1:

1 is only present in A. 2 is present in A and B. 3 is present in B and C.
Explanation 2:

All numbers are present in atleast 2 out of 3 lists.","vector<int> Solution::solve(vector<int> &A, vector<int> &B, vector<int> &C) {
    map<int,int> m,ma,mb,mc;
    for(auto i:A){
        ma[i]++;
        m[i]++;
    }
    for(auto i:B){
        mb[i]++;
        m[i]++;
    }
    for(auto i:C){
        mc[i]++;
        m[i]++;
    }
    vector<int> temp;
    for(auto i:m){
        if(i.second>=2){
            temp.push_back(i.first);
        }
    }
    vector<int> ans;
    for(int i=0;i<temp.size();i++){
        auto a=ma.find(temp[i]),b=mb.find(temp[i]),c=mc.find(temp[i]);
        if((a!=ma.end() && b!=mb.end()) || (b!=mb.end() && c!=mc.end()) || (a!=ma.end() && c!=mc.end())){
            ans.push_back(temp[i]);
        }
    }
    return ans;
}"
Subarray with B odd numbers,https://www.interviewbit.com/problems/subarray-with-b-odd-numbers/,N/A,Hashing,medium,"Problem Description

Given an array of integers A and an integer B.

Find the total number of subarrays having exactly B odd numbers.



Problem Constraints
1 <= length of the array <= 105

1 <= A[i] <= 109

0 <= B <= A



Input Format
The first argument given is the integer array A.

The second argument given is integer B.



Output Format
Return the total number of subarrays having exactly B odd numbers.



Example Input
Input 1:

 A = [4, 3, 2, 3, 4]
 B = 2
Input 2:

 A = [5, 6, 7, 8, 9]
 B = 3


Example Output
Output 1:

 4
Output 2:

 1


Example Explanation
Explanation 1:

 The subarrays having exactly B odd numbers are:
 [4, 3, 2, 3], [4, 3, 2, 3, 4], [3, 2, 3], [3, 2, 3, 4]
Explanation 2:

 The subarrays having exactly B odd numbers is [5, 6, 7, 8, 9]
","int Solution::solve(vector<int> &A, int B) {
    int n = A.size();
    int count = 0;
    int prefix[n+1];
    memset(prefix, 0, sizeof(prefix));
    int odd = 0;
    // traverse in the array
    for (int i = 0; i < n; i++)
    {

      prefix[odd]++;
      // if array element is odd
      if (A[i] & 1)
          odd++;

      // when number of odd elements>=M
      if (odd >= B)
          count += prefix[odd - B];
    }
    return count;
    
}"
Tiling With Dominoes,https://www.interviewbit.com/problems/tiling-with-dominoes/,"Directi, Uber",Dynamic Programming,medium,"Problem Description
 
 

Given an integer A you have to find the number of ways to fill a 3 x A board with 2 x 1 dominoes.

Return the answer modulo 109 + 7 .

NOTE:

See the sample explanation for better understanding.


Problem Constraints
1 <= A <= 105



Input Format
First and only argument is an integer A.



Output Format
Return an integer denoting the number of ways to fill a 3 x A board with 2 x 1 dominoes with modulo 109 + 7.



Example Input
Input 1:

 2
Input 2:

 1


Example Output
Output 1:

 3
Output 2:

 0


Example Explanation
Explanation 1:

 Following are all the 3 possible ways to fill up a 3 x 2 board.
 
Explanation 2:

 Not a even a single way exists to completely fill the grid of size 3 x 1.
","#define ll long long
const int mod=1e9+7;
int countWays(int n) 
{ 
	ll A[n + 1], B[n + 1]; 
	A[0] = 1, A[1] = 0, B[0] = 0, B[1] = 1; 
	for (int i = 2; i <= n; i++) { 
	    A[i] = ((A[i - 2]%mod) + ((2 * B[i - 1])%mod))%mod;
		B[i] = ((A[i - 1]%mod) + (B[i - 2]%mod))%mod;
	} 
	return A[n]; 
} 
int Solution::solve(int A) {
    return countWays(A);
}"
Reverse Level Order,https://www.interviewbit.com/problems/reverse-level-order/,N/A,Tree Data Structure,medium,"Problem Description

Given a binary tree, return the reverse level order traversal of its nodes values. (i.e, from left to right and from last level to starting level).



Problem Constraints
1 <= number of nodes <= 5 * 105

1 <= node value <= 105



Input Format
First and only argument is a pointer to the root node of the Binary Tree, A.



Output Format
Return an integer array denoting the reverse level order traversal from left to right.



Example Input
Input 1:

    3
   / \
  9  20
    /  \
   15   7
Input 2:

   1
  / \
 6   2
    /
   3


Example Output
Output 1:

 [15, 7, 9, 20, 3] 
Output 2:

 [3, 6, 2, 1]


Example Explanation
Explanation 1:

 Nodes as level 3 : [15, 7]
 Nodes at level 2: [9, 20]
 Nodes at level 1: [3]
 Reverse level order traversal will be: [15, 7, 9, 20, 3]
Explanation 2:

 Nodes as level 3 : [3]
 Nodes at level 2: [6, 2]
 Nodes at level 1: [1]
 Reverse level order traversal will be: [3, 6, 2, 1]
","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
vector<int> Solution::solve(TreeNode* A) {
    stack <TreeNode *> S;
    vector <TreeNode *> Q;
    Q.push_back(A);
    // Do something like normal level order traversal order. Following are the
    // differences with normal level order traversal
    // 1) Instead of printing a node, we push the node to stack
    // 2) Right subtree is visited before left subtree
    while (Q.size() != 0)
    {
        /* Dequeue node and make it root */
        TreeNode *temp = Q[0];
        //Q.pop();
        Q.erase(Q.begin());
        S.push(temp);

        /* Enqueue right child */
        if (temp->right)
            Q.push_back(temp->right); // NOTE: RIGHT CHILD IS ENQUEUED BEFORE LEFT

        /* Enqueue left child */
        if (temp->left)
            Q.push_back(temp->left);
    }

    // Now pop all items from stack one by one and print them
    vector<int> ans;
    while (S.empty() == false)
    {
        TreeNode *temp = S.top();
        ans.push_back(temp->val);
        S.pop();
    }
    return ans;
}"
Smaller or equal elements,https://www.interviewbit.com/problems/smaller-or-equal-elements/,N/A,Binary Search,easy,"Problem Description

Given an sorted array A of size N. Find number of elements which are less than or equal to B.

NOTE: Expected Time Complexity O(log N)



Problem Constraints
1 <= N <= 106

1 <= A[i], B <= 109



Input Format
First agument is an integer array A of size N.

Second argument is an integer B.



Output Format
Return an integer denoting the number of elements which are less than or equal to B.



Example Input
Input 1:

 A = [1, 3, 4, 4, 6]
 B = 4
Input 2:

 A = [1, 2, 5, 5]
 B = 3


Example Output
Output 1:

 4
Output 2:

 2


Example Explanation
Explanation 1:

 Elements (1, 3, 4, 4) are less than or equal to 4.
Explanation 2:

 Elements (1, 2) are less than or equal to 3.
","int Solution::solve(vector<int> &A, int B) {
    int n = A.size();
    int left = 0;
    int right = n - 1;
    int count = 0;

    while (left <= right) {
        int mid = (right + left) / 2;

        // Check if middle element is less than or equal to B
        if (A[mid] <= B) {

            // At least (mid + 1) elements are there whose values are less than or equal to B
            count = mid + 1;
            left = mid + 1;
        }

        // If B is smaller, ignore right half
        else
            right = mid - 1;
    }
    return count;
    
}"
WoodCutting Made Easy!,https://www.interviewbit.com/problems/woodcutting-made-easy/,Flipkart,Binary Search,medium,"Problem Description

There is given an integer array A of size N denoting the heights of N trees.

Lumberjack Ojas needs to chop down B metres of wood. It is an easy job for him since he has a nifty new woodcutting machine that can take down forests like wildfire. However, Ojas is only allowed to cut a single row of trees.

Ojas's machine works as follows: Ojas sets a height parameter H (in metres), and the machine raises a giant sawblade to that height and cuts off all tree parts higher than H (of course, trees not higher than H meters remain intact). Ojas then takes the parts that were cut off. For example, if the tree row contains trees with heights of 20, 15, 10, and 17 metres, and Ojas raises his sawblade to 15 metres, the remaining tree heights after cutting will be 15, 15, 10, and 15 metres, respectively, while Ojas will take 5 metres off the first tree and 2 metres off the fourth tree (7 metres of wood in total).

Ojas is ecologically minded, so he doesn't want to cut off more wood than necessary. That's why he wants to set his sawblade as high as possible. Help Ojas find the maximum integer height of the sawblade that still allows him to cut off at least B metres of wood.

NOTE:

The sum of all heights will exceed B, thus Ojas will always be able to obtain the required amount of wood.


Problem Constraints
1 <= N <= 106

1 <= A[i] <= 106

1 <= B <= 2106



Input Format
First argument is an integer array A of size N denoting the heights of each tree(in metres).

Second argument is an integer B.



Output Format
Return a single integer denoting maximum integer height of the sawblade that still allows him to cut off at least B metres of wood.



Example Input
Input 1:

 A = [20, 15, 10, 17]
 B = 7
Input 2:

 A = [4, 42, 40, 26, 46]
 B = 20


Example Output
Output 1:

 15
Output 2:

 36


Example Explanation*
Explanation 1:

 If you the height parameter to 15 then you can chop:
  5 metres from first tree
  0 metres from second tree
  0 metres from third tree
  2 metres from fourth tree
  So in total you chopped 7 metres of wood.
Explanation 2:

 If you the height parameter to 36 then you can chop:
  0 metres from first tree
  6 metres from second tree
  4 metres from third tree
  0 metres from fourth tree
  10 metres from fifth tree
  So in total you chopped 20 metres of wood.","bool check(vector < int > & A, int val, int B) {
  int rem = 0;
  int n = A.size();
  for (int i = 0; i < n; i++) {
    if (A[i] > val) rem += A[i] - val;
  }
  if (rem >= B) return true;
  return false;
}
int Solution::solve(vector < int > & A, int B) {
  int low = 0;
  int high = 1000000;
  int ans = 0;
  while (low <= high) {
    int mid = (low + high) / 2;
    if (check(A, mid, B)) {
      ans = mid;
      low = mid + 1;
    } else high = mid - 1;
  }
  return ans;
}"
Useful Extra Edges,https://www.interviewbit.com/problems/useful-extra-edges/,Directi,Graph Data Structure & Algorithms,hard,"Problem Description
 
 

Given a graph of A nodes. Also given the weighted edges in the form of array B.

You are also given starting point C and destination point D.

Also given are some extra edges in the form of vector E.

You need to find the length of the shortest path from C to D if you can use maximum one road from the given roads in E.

All roads are bidirectional.



Problem Constraints
1 <= A <= 100000

1 <= |B| <= 100000

1 <= C, D <= A

1 <= |E| <= 300

All lengths of the roads lie between 1 and 1000.



Input Format
First argument is the integer A.

Second argument is the vector of vectors B.

Third argument is the integer C.

Fourth argument is the integer D.

Fifth argument is the vector of vectors E.



Output Format
Return -1 if C is not reachable from D. Else return the shortest distance between them.



Example Input
Input 1:

 A = 3
B = [   [1, 2, 1]
        [2, 3, 2]
    ]
C = 1
D = 3
E = [   [1, 3, 2]
    ]
Input 2:

 A = 4
B = [   [1, 2, 1]
        [2, 3, 2]
        [3, 1, 4]
    ]
C = 1
D = 4
E = [   [1, 3, 2]
    ]


Example Output
Output 1:

 2
Output 2:

 -1


Example Explanation
Explanation 1:

 Use the direct edge from 1 to 3. It has shortest path from 1 to 3.
Explanation 2:

 4 cannot be reached from 1.","typedef pair<int,int> ii;
typedef vector<ii> vii;
typedef vector<int> vi;
#define se second
#define fi first
#define pb push_back
int n,m,kk,s,t,pp;

vector<vii> dist;
vector<vii> rdist;

const int INF = 1e9;

vi dists(100002,INF); //distance from source s to node
vi distt(100002,INF); //distance from node to target

void dijkstras(int source, vector<vii> &v,vector<int> &distance){
	priority_queue<ii,vii,greater<ii> > pq;
	pq.push(ii(0,source));
	distance[source]=0;
	while(!pq.empty()){
		ii top = pq.top();
		pq.pop();
		int node = top.se;
		int d = top.fi;
		for(int i=0;i<v[node].size();++i){
			ii neighbor = v[node][i];
			if(distance[neighbor.fi]>d+neighbor.se){
				distance[neighbor.fi]=d+neighbor.se;
				pq.push(ii(distance[neighbor.fi],neighbor.fi));
			}
		}
	}
}
int Solution::solve(int A, vector<vector<int> > &B, int C, int D, vector<vector<int> > &E) {
    dists = vi(100002,INF);
	distt = vi(100002, INF);
	n=A;
	dist = vector<vii> (n+1,vector<ii>());
	rdist = vector<vii> (n+1,vector<ii>());
	for(int i=0;i<B.size();i++)
	{
	    dist[B[i][0]].push_back(ii(B[i][1],B[i][2]));
	    rdist[B[i][1]].push_back(ii(B[i][0],B[i][2]));
	}
	dijkstras(C,dist,dists);
	dijkstras(D,rdist,distt);
	int ans = dists[D];
	for(int i=0;i<E.size();i++)
	{   int u=E[i][0];
	    int v=E[i][1];
	    int d=E[i][2];
	    ans=min(ans,min(dists[u]+d+distt[v],dists[v]+d+distt[u]));
	}
	if(ans==INF)
		ans=-1;
	return ans;
}"
Largest Permutation,https://www.interviewbit.com/problems/largest-permutation/,N/A,Greedy Algorithm,easy,"Problem Description

Given an integer array A of size N consisting of unique integers from 1 to N. You can swap any two integers atmost B times.

Return the largest lexicographical value array that can be created by executing atmost B swaps.



Problem Constraints
1 <= N <= 106

1 <= B <= 109



Input Format
First argument is an integer array A of size N.

Second argument is an integer B.



Output Format
Return an integer array denoting the largest lexicographical value array that can be created by executing atmost B swaps.



Example Input
Input 1:

 A = [1, 2, 3, 4]
 B = 1
Input 2:

 A = [3, 2, 1]
 B = 2


Example Output
Output 1:

 [4, 2, 3, 1]
Output 2:

 [3, 2, 1]


Example Explanation
Explanation 1:

 In one swap we can swap (1, 4) so that the array becomes : [4, 2, 3, 1].
Explanation 2:

 Array is already the largest lexicographical value array.
","vector<int> Solution::solve(vector<int> &A, int B) {
    
    int n = A.size();
    
    // Store the initial index of element
    int idx[n+1];
    for(int i = 0; i < n; i ++){
        idx[ A[i] ] = i;
    }
    
    int i = 0;
    // Loop till we have left with swaps or traverse whole array
    while(i < n && B){
        if(A[i] == n-i){
            i ++;
            continue;
        }

        int tmp = idx[n-i];
        idx[ A[i] ] = idx[ n-i ];
        idx[ n-i ] = i;
        swap( A[ tmp ], A[i] );
        B --;
        i ++;
    }
    return A;
}"
Increasing Path in Matrix,https://www.interviewbit.com/problems/increasing-path-in-matrix/,Google,Dynamic Programming,medium,"Problem Description
 
 

Given a 2D integer matrix A of size N x M.

From A[i][j] you can move to A[i+1][j], if A[i+1][j] > A[i][j], or can move to A[i][j+1] if A[i][j+1] > A[i][j].

The task is to find and output the longest path length possible if we start from the cell (0, 0) and want to reach cell (N - 1, M - 1).

NOTE:

If there doesn't exist a path return -1.


Problem Constraints
1 <= N, M <= 103

1 <= A[i][j] <= 108



Input Format
First and only argument is an 2D integer matrix A of size N x M.



Output Format
Return a single integer denoting the length of longest path in the matrix if no such path exists return -1.



Example Input
Input 1:

 A = [  [1, 2]
        [3, 4]
     ]
Input 2:

 A = [  [1, 2, 3, 4]
        [2, 2, 3, 4]
        [3, 2, 3, 4]
        [4, 5, 6, 7]
     ]


Example Output
Output 1:

 3
Output 2:

 7


Example Explanation
Explanation 1:

 Longest path is either 1 2 4 or 1 3 4.
Explanation 2:

 Longest path is 1 2 3 4 5 6 7.
","int dp[1009][1009];
int Solution::solve(vector < vector < int > > & A) {
  int n = A.size();
  int m = A[0].size();
  assert(n>=1 && n<=1000 && m>=1 && m<=1000);
  for(auto a:A) 
    for(auto b:a)
        assert(b>=1 && b<=100000000);
  memset(dp, 0, sizeof(dp));
  dp[0][0] = 1;
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
      if (i == 0 && j == 0)
        continue;
      int top = ((i == 0) || (A[i - 1][j] >= A[i][j]) || dp[i-1][j]==0) ? 0 : dp[i - 1][j] + 1;
      int left = ((j == 0) || (A[i][j - 1] >= A[i][j]) || dp[i][j-1]==0) ? 0 : dp[i][j - 1] + 1;
      dp[i][j] = max(top, left);
    }
  }
  if (dp[n - 1][m - 1] == 0) return -1;
  return dp[n - 1][m - 1];
}"
Minimum Parantheses!,https://www.interviewbit.com/problems/minimum-parantheses/,Google,Strings,easy,"Problem Description

Given a string A of parantheses  ‘(‘ or ‘)’.

The task is to find minimum number of parentheses ‘(‘ or ‘)’ (at any positions) we must add to make the resulting parentheses string valid.

An string is valid if:

Open brackets must be closed by the corresponding closing bracket.
Open brackets must be closed in the correct order.


Problem Constraints
1 <= |A| <= 105

A[i] = '(' or A[i] = ')'



Input Format
First and only argument is an string A.



Output Format
Return a single integer denoting the minimumnumber of parentheses ‘(‘ or ‘)’ (at any positions) we must add in A to make the resulting parentheses string valid.



Example Input
Input 1:

 A = ""())""
Input 2:

 A = ""(((""


Example Output
Output 1:

 1
Output 2:

 3


Example Explanation
Explanation 1:

 One '(' is required at beginning.
Explanation 2:

 Three ')' is required at end.
","int Solution::solve(string a) {
    int openBrackets = 0, req=0;
    for(int i=0;i<a.length();i++) {
        if(a[i]=='(') {
            openBrackets++;
        } else {
            if(openBrackets>0) openBrackets--;
            else {
                req++;
            }
        }
    }
    req+=openBrackets;
    return req;
}"
Leaders in an array,https://www.interviewbit.com/problems/leaders-in-an-array/,N/A,Arrays,easy,"Problem Description

Given an integer array A containing N distinct integers, you have to find all the leaders in the array A.

 An element is leader if it is strictly greater than all the elements to its right side.

NOTE:The rightmost element is always a leader.



Problem Constraints
1 <= N <= 105

1 <= A[i] <= 108



Input Format
First and only argument is an integer array A.



Output Format
Return an integer array denoting all the leader elements of the array.

NOTE: Ordering in the output doesn't matter.



Example Input
Input 1:

 A = [16, 17, 4, 3, 5, 2]
Input 2:

 A = [1, 2]


Example Output
Output 1:

 [17, 2, 5]
Output 2:

 [2]


Example Explanation
Explanation 1:

 Element 17 is strictly greater than all the elements on the right side to it.
 Element 2 is strictly greater than all the elements on the right side to it.
 Element 5 is strictly greater than all the elements on the right side to it.
 So we will return this three elements i.e [17, 2, 5], we can also return [2, 5, 17] or [5, 2, 17] or any other ordering.
Explanation 2:

 Only 2 the rightmost element is the leader in the array.
","/* C++ Function to print leaders in an array */
vector<int> printLeaders(vector<int>& arr) 
{ 
    int size = arr.size();
    int max_from_right =  arr[size-1]; 
  
    vector<int>ans;
    /* Rightmost element is always leader */
    ans.push_back(arr[size-1]);
    
    for (int i = size-2; i >= 0; i--) 
    { 
        if (max_from_right < arr[i]) 
        {            
            max_from_right = arr[i];
            ans.push_back(max_from_right);
        } 
    }
    return ans;
} 
  
vector<int> Solution::solve(vector<int> &A) {
    assert(A.size()>=1 && A.size()<=100000);
    for(int a:A)assert(a>=1 && a<=100000000);
    set<int>s;
    for(int a:A)
        s.insert(a);
    assert(s.size()==A.size());
    return printLeaders(A);
}"
Trailing Zeroes,https://www.interviewbit.com/problems/trailing-zeroes/,N/A,Bit Manipulation,easy,"Problem Description

Given an integer A, count and return the number of trailing zeroes.



Problem Constraints
1 <= A <= 109



Input Format
First and only argument is an integer A.



Output Format
Return an integer denoting the count of trailing zeroes.



Example Input
Input 1:

 A = 18
Input 2:

 A = 8


Example Output
Output 1:

 1
Output 2:

 3


Example Explanation
Explanation 1:

 18 in binary is represented as: 10010, there is 1 trailing zero.
Explanation 2:

 8 in binary is represented as: 1000, there are 3 trailing zeroes.
","int Solution::solve(int x) {
      int count = 0; 
  while ((x & 1) == 0) 
  { 
      x = x >> 1; 
      count++; 
  } 
  return count; 
    
}"
Maximum Edge Removal,http://interviewbit.com/problems/maximum-edge-removal/,Amazon,Tree Data Structure,medium,"Problem Description

Given an undirected tree with an even number of nodes. Consider each connection between a parent and child node to be an edge.

You need to remove maximum number of these edges, such that the disconnected subtrees that remain each have an even number of nodes.

Return the maximum number of edges you can remove.



Problem Constraints
2 <= A <= 105

1 <= B[i][0], B[i][1] <= A

Integer A will be even.



Input Format
First argument is an integer A denoting the number of nodes in the tree.

Second argument is a 2D array B of size (A-1) * 2, denoting the edge between nodes B[i][0] and B[i][1].



Output Format
Return an integer, denoting the maximum number of edges you can remove.



Example Input
Input 1:

 A = 6
 B = [
       [1, 2]
       [1, 3]
       [1, 4]
       [3, 5]
       [4, 6]
     ]
Input 2:

 A = 2
 B = [
       [1, 2]
     ]


Example Output
Output 1:

 2
Output 2:

 0


Example Explanation
Explanation 1:

      1
    / | \
   2  3  4
      |   \
      5    6
 Maximum number of edges we can remove is 2, i.e (1, 3) and (1, 4)
Explanation 2:

 We can't remove any edges.","const int maxN = 1e5 + 5;
vector<int> g[maxN];
int res = 0;

// Utility method to do DFS of the graph and count edge removal
int dfs(int u, int par) {
    int currComponentNode = 0;

    //  iterate over all neighbor of node u
    for (auto v: g[u]) {
        if(v == par){
            continue;
        }
        // Count the number of nodes in a subtree
        int subtreeNodeCount = dfs(v, u);

        // if returned node count is even, disconnect the subtree and increase result by one.
        if (subtreeNodeCount % 2 == 0)
            res++;

        //  else add subtree nodes in current component
        else
            currComponentNode += subtreeNodeCount;
    }

    // number of nodes in current component and one for current node
    return (currComponentNode + 1);
}

int Solution::solve(int A, vector<vector<int> > &B) {
    assert(A%2 == 0 && A <= 1e5);
    for(int i = 1; i <= A; i++){
        g[i].clear();
    }
    for(int i = 0; i < B.size(); i++){
        g[B[i][0]].push_back(B[i][1]);
        g[B[i][1]].push_back(B[i][0]);
    }
    res = 0;
    // calling the dfs from node-1 and making its parent as -1
    dfs(1, 0);
    return res;
}"
Search in Bitonic Array!,https://www.interviewbit.com/problems/search-in-bitonic-array/,N/A,Binary Search,easy,"Problem Description
 
 

Given a bitonic sequence A of N distinct elements, write a program to find a given element B in the bitonic sequence in O(logN) time.

NOTE:

A Bitonic Sequence is a sequence of numbers which is first strictly increasing then after a point strictly decreasing.


Problem Constraints
3 <= N <= 105

1 <= A[i], B <= 108

Given array always contain a bitonic point.

Array A always contain distinct elements.



Input Format
First argument is an integer array A denoting the bitonic sequence.

Second argument is an integer B.



Output Format
Return a single integer denoting the position (0 index based) of the element B in the array A if B doesn't exist in A return -1.



Example Input
Input 1:

 A = [3, 9, 10, 20, 17, 5, 1]
 B = 20
Input 2:

 A = [5, 6, 7, 8, 9, 10, 3, 2, 1]
 B = 30


Example Output
Output 1:

 3
Output 2:

 -1


Example Explanation
Explanation 1:

 B = 20 present in A at index 3
Explanation 2:

 B = 30 is not present in A
","// Function for binary search in ascending part
int ascendingBinarySearch(vector < int > & arr, int low,
  int high, int key) {
  while (low <= high) {
    int mid = low + (high - low) / 2;
    if (arr[mid] == key)
      return mid;
    if (arr[mid] > key)
      high = mid - 1;
    else
      low = mid + 1;
  }
  return -1;
}

// Function for binary search in descending part of array
int descendingBinarySearch(vector < int > & arr, int low,
  int high, int key) {
  while (low <= high) {
    int mid = low + (high - low) / 2;
    if (arr[mid] == key)
      return mid;
    if (arr[mid] < key)
      high = mid - 1;
    else
      low = mid + 1;
  }
  return -1;
}

// finding bitonic point
int findBitonicPoint(vector < int > & arr, int n, int l, int r) {
  int mid;
  mid = (r + l) / 2;
  if (arr[mid] > arr[mid - 1] && arr[mid] > arr[mid + 1]) {
    return mid;
  } else if (arr[mid] > arr[mid - 1] && arr[mid] < arr[mid + 1]) {
    return findBitonicPoint(arr, n, mid, r);
  } else if (arr[mid] < arr[mid - 1] && arr[mid] > arr[mid + 1]) {
    return findBitonicPoint(arr, n, l, mid);
  }
}

// Function to search key in bitonic array
int searchBitonic(vector < int > & arr, int n, int key, int index) {
  if (key > arr[index])
    return -1;

  else if (key == arr[index])
    return index;

  else {
    int temp = ascendingBinarySearch(arr, 0, index - 1, key);
    if (temp != -1) {
      return temp;
    }

    // Search in right of k
    return descendingBinarySearch(arr, index + 1, n - 1, key);
  }
}
int solveQ(vector < int > & arr, int b) {
  int index = findBitonicPoint(arr, arr.size(), 0, arr.size() - 1);
  int x = searchBitonic(arr, arr.size(), b, index);
  return x;
}
int Solution::solve(vector < int > & A, int B) {
  return solveQ(A, B);
}"
Egg Drop Problem!,https://www.interviewbit.com/problems/egg-drop-problem/,N/A,Dynamic Programming,hard,"Problem Description

You are given A eggs, and you have access to a building with B floors from 1 to B.

Each egg is identical in function, and if an egg breaks, you cannot drop it again.

You know that there exists a floor C with 0 <= C <= B  such that any egg dropped at a floor higher than C will break, and any egg dropped at or below floor C will not break.

Each move, you may take an egg (if you have an unbroken one) and drop it from any floor X (with 1 <= X <= B). 

Your goal is to know with certainty what the value of C is.

What is the minimum number of moves that you need to know with certainty what C is, regardless of the initial value of C



Problem Constraints
1 <= A <= 100
1 <= B <= 104


Input Format
First Argument is an integer A denoting number of eggs.

Second Argument is an integer B denoting number of floors.



Output Format
Return an integer denoting the Minimum number of moves.



Example Input
Input 1:

 A = 1
 B = 2
Input 2:

 A = 2
 B = 10


Example Output
Output 1:

 2
Output 2:

 4 


Example Explanation
Explanation 1:

 Drop the egg from floor 1.  If it breaks, we know with certainty that F = 0.
 Otherwise, drop the egg from floor 2.  If it breaks, we know with certainty that F = 1.
 If it didn't break, then we know with certainty F = 2.
 Hence, we needed 2 moves in the worst case to know what F is with certainty.","int f(int floors, int eggs,vector <vector <int>> &dp){
    if(eggs == 1) return floors; //if we have only one egg left, we will start from bottom most floor.
    if(floors == 0) return 0; //if we have no floors, we dont require any step.
    
    if(dp[floors][eggs] != -1) return dp[floors][eggs]; // if we have already explored the floors with these many 
                                                        //remaining eggs, we can reuse it to save time.
    
    int low = 1, high = floors; 
    int mini = INT_MAX; // to store minimum no of steps.
    
    while(low <= high){
        int mid = low + (high-low)/2;
        
        int notBreak = f(floors-mid, eggs, dp); //if egg doesn't break, try from above floors.
        int breaks = f(mid-1, eggs-1, dp); //if egg breaks, we will try from below floors.
        
        if(breaks > notBreak){
            mini = min(mini, breaks + 1);
            high = mid - 1;
        } else{
            mini = min(mini, notBreak + 1);
            low = mid + 1;
        }
    }
    
    return dp[floors][eggs] = mini; // while returning the answer, store the ans so that we can use it again.
}

int Solution::solve(int eggs, int floors) {
    vector <vector <int>> dp(floors+1, vector <int> (eggs+1, -1));
    
    return f(floors, eggs, dp);
}"
Step by Step,https://www.interviewbit.com/problems/step-by-step/,N/A,Math,easy,"Problem Description

Given a target A on an infinite number line, i.e. -infinity to +infinity.

You are currently at position 0 and you need to reach the target by moving according to the below rule:

In ith move you can take i steps forward or backward.
Find the minimum number of moves required to reach the target.



Problem Constraints
-109 <= A <= 109



Input Format
First and only argument is an integer A.



Output Format
Return an integer denoting the minimum moves to reach target.



Example Input
Input 1:

 3
Input 2:

 2


Example Output
Output 1:

 2
Output 2:

 3


Example Explanation
Explanation 1:

 On the first move we step from 0 to 1.
 On the second step we step from 1 to 3.
Explanation 2:

 On the first move we step from 0 to 1.
 On the second move we step  from 1 to -1.
 On the third move we step from -1 to 2.
","int Solution::solve(int B) {
    long long A = abs(B);

    // N that satifyes 1 + 2 + 3... + N = (1 + N)*N/2 >= B;
    long long N = ceil((-1 + sqrt(1 + 8*A))/2);
    long long sum = N*(N + 1)/2;
    
   // If sum has the same parity we are done
    if ((sum - A)%2 == 0)
        return N;

   // If the parity is different check if adding N + 1 will change it
   // If not, sum both N + 1 and N + 2 to 'fix' the parity
    if (N%2 == 1) return N + 2;
    else return N + 1;
}"
Next Smallest Palindrome!,https://www.interviewbit.com/problems/next-smallest-palindrome/,"Google, Grofers",Math,hard,"Problem Description

Given a numeric string A representing a large number you need to find the next smallest palindrome greater than this number.



Problem Constraints
1 <= |A| <= 100

A doesn't start with zeroes and always contain digits from 0-9.



Input Format
First and only argument is an string A.



Output Format
Return a numeric string denoting the next smallest palindrome greater than A.



Example Input
Input 1:

 A = ""23545""
Input 2:

 A = ""999""


Example Output
Output 1:

 ""23632""
Output 2:

 ""1001""","string Solution::solve(string A) {
    int size = A.size();
    int mid = (size+1)/2;

    bool incr = true;
    // check if we need to add 1 to first half of the number
    // before making it into a palindrome.
    for(int i = mid; i < size; i++) {
        if(A[size-1-i] == A[i]) continue;
        if(A[size-1-i] < A[i]) incr = true;
        if(A[size-1-i] > A[i]) incr = false;
        break;
    }

    A = A.substr(0,mid);

    //add 1 to the first half of the number.
    if(incr) {
        int carry = 1;

        for(int i = mid-1; i >= 0 && carry == 1; i--)
            A[i] = ( A[i] == '9' ? '0' : A[i] + carry--);

        if(carry) //every digit must have been '9'
            return '1' + string(size-1,'0') + '1';
    }

    //append the first half reversed to make the palindrome.
    for(int i = size-A.size()-1; i >= 0; i--)
        A.push_back(A[i]);

    return A;
}"
Distribute in Circle!,https://www.interviewbit.com/problems/distribute-in-circle/,N/A,Math,easy,"Problem Description

A items are to be delivered in a circle of size B.

Find the position where the Ath item will be delivered if we start from a given position C.

NOTE: Items are distributed at adjacent positions starting from C.



Problem Constraints
1 <= A, B, C <= 108



Input Format
First argument is an integer A.

Second argument is an integer B.

Third argument is an integer C.



Output Format
Return an integer denoting the position where the Ath item will be delivered if we start from a given position C.



Example Input
Input 1:

 A = 2
 B = 5
 C = 1
Input 2:

 A = 8
 B = 5
 C = 2


Example Output
Output 1:

 2
Output 2:

 4


Example Explanation
Explanation 1:

 The first item will be given to 1st position. Second (or last) item will be delivered to 2nd position
Explanation 2:

 The last item will be delivered to 4th position

","// n ==> Size of circle
// m ==> Number of items
// k ==> Initial position
int lastPosition(int n, int m, int k)
{
    // n - k + 1 is number of positions
    // before we reach beginning of circle
    // If m is less than this value, then
    // we can simply return (m-1)th position
    if (m <= n - k + 1)
        return m + k - 1;

    // Let us compute remaining items before
    // we reach beginning.
    m = m - (n - k + 1);

    // We compute m % n to skip all complete
    // rounds. If we reach end, we return n
    // else we return m % n
    return (m % n == 0) ? n : (m % n);
}
int Solution::solve(int A, int B, int C) {
    return lastPosition(B,A,C);
}"
Total Moves For Bishop!,https://www.interviewbit.com/problems/total-moves-for-bishop/,N/A,Math,easy,"Problem Description

Given the position of a Bishop (A, B) on an 8 * 8 chessboard.

Your task is to count the total number of squares that can be visited by the Bishop in one move.

The position of the Bishop is denoted using row and column number of the chessboard.



Problem Constraints
1 <= A, B <= 8



Input Format
First argument is an integer A denoting the row number of the bishop.

Second argument is an integer B denoting the column number of the bishop.



Output Format
Return an integer denoting the total number of squares that can be visited by the Bishop in one move.



Example Input
Input 1:

 A = 4
 B = 4


Example Output
Output 1:

 13","int Solution::solve(int A, int B) {

    
    return min(B-1,A-1) + min(8-B,A-1) + min(8-B,8-A) + min(B-1,8-A);
    
    
}"
Subarray with equal occurences!,https://www.interviewbit.com/problems/subarray-with-equal-occurences/,N/A,Hashing,medium,"Problem Description

Given an integer array A and two integers B and C.

You need to find the number of subarrays in which the number of occurrences of B is equal to number of occurrences of C.

NOTE: Don't count empty subarrays.



Problem Constraints
1 <= |A| <= 104

1 <= A[i], B, C <= 108

 B != C



Input Format
First argument is an integer array A.

Second argument is an integer B.

Third argument is an integer C.



Output Format
Return an integer denoting the number of subarrays in which the number of occurrences of B is equal to number of occurrences of C.



Example Input
Input 1:

 A = [1, 2, 1]
 B = 1
 C = 2
Input 2:

 A = {1, 2, 1}
 B = 4
 C = 6


Example Output
Output 1:

 2
Output 2:

 6


Example Explanation
Explanation 1:

 The possible sub-arrays have same equal number of occurrences of B and C are:
    1) {1, 2}, B and C have same occurrence(1).
    2) {2, 1}, B and C have same occurrence(1).
Explanation 2:

 The possible sub-arrays have same equal number of occurrences of B and C are:
    1) {1}, B and C have same occurrence(0).
    2) {2}, B and C have same occurrence(0).
    3) {1}, B and C have same occurrence(0).
    4) {1, 2}, B and C have same occurrence(0).
    5) {2, 1}, B and C have same occurrence(0).
    6) {1, 2, 1}, B and C have same occurrence(0).","int solveQ(vector<int>&arr,int x,int y)
{
    int n=arr.size();
    int countX[n], countY[n];

    map<int, int> m; // To store counts of same diffs

    if(arr[0]==x)
        countX[0]=1;
    else if(arr[0]==y)
        countY[0]=1;
    else
    {
        countX[0]=0;
        countY[0]=0;
    }
    // Count occurrences of x and y
    for (int i = 1; i < n; i++) {
         // Increment count of current
         if(arr[i]==x)
            countX[i]=1;
         else if(arr[i]==y)
            countY[i]=1;
         countX[i]+=countX[i-1];
         countY[i]+=countY[i-1];
         m[countX[i] - countY[i]]++;
    }

    // Traverse map and commute result.
    int result = m[0];
    for (auto it = m.begin(); it != m.end(); it++)
        result = result + ((it->second) * ((it->second) - 1)) / 2;

    return (result);
}

int Solution::solve(vector<int> &A, int B, int C) {
    return solveQ(A,B,C);
}"
Paint House!,https://www.interviewbit.com/problems/paint-house/,Linkedin,Dynamic Programming,medium,"Problem Description

There are a row of N houses, each house can be painted with one of the three colors: red, blue or green.

The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.

The cost of painting each house with a certain color is represented by a N x 3 cost matrix A.

For example, A[0][0] is the cost of painting house 0 with color red; A[1][2] is the cost of painting house 1 with color green, and so on.

Find the minimum total cost to paint all houses.



Problem Constraints
1 <= N <= 105

1 <= A[i][j] <= 103



Input Format
First and only argument is an 2D integer matrix A of size N x 3 denoting the cost to paint the houses.



Output Format
Return an integer denoting the minimum total cost to paint all houses.



Example Input
Input 1:

 A = [  [1, 2, 3]
        [10, 11, 12]
     ]


Example Output
Output 1:

 12


Example Explanation
Explanation 1:

 Paint house 1 with red and house 2 with green i.e A[0][0] + A[1][1] = 1 + 11 = 12
","int Solution::solve(vector<vector<int> > &A) {
    int n=A.size();
    int dp[n][3];
    dp[0][0] = A[0][0], dp[0][1] = A[0][1], dp[0][2] = A[0][2];
    for (int i = 1; i < A.size(); ++i) {
        dp[i][0] = A[i][0] + min(dp[i-1][1], dp[i-1][2]);
        dp[i][1] = A[i][1] + min(dp[i-1][0], dp[i-1][2]);
        dp[i][2] = A[i][2] + min(dp[i-1][0], dp[i-1][1]);
    }
    return min(dp[n-1][0],min(dp[n-1][1],dp[n-1][2]));
}"
Maximum level sum,https://www.interviewbit.com/problems/maximum-level-sum/,N/A,Tree Data Structure,easy,"Problem Description

Given a Binary Tree denoted by root node A having integer value on nodes. You need to find maximum sum level in it.



Problem Constraints
1 <= number of nodes <= 105

1 <= value on nodes <= 105



Input Format
First and only argument is a root node of Binary Tree A.



Output Format
Return an integer denoting the maximum sum level in the tree.



Example Input
Input 1:

 Tree:      4
          /   \
         2     5
        / \   / \
       1  3  2   6
Input 2:

 Tree:      1
          /   \
         2     3
       /  \     \
      4    5     8
                / \
               6   7  


Example Output
Output 1:

 12
Output 2:

 17


Example Explanation
Explanation 1:

 Sum of all nodes of 0'th level is 4 
 Sum of all nodes of 1'th level is 7
 Sum of all nodes of 2'th level is 12
 Hence maximum sum is 12
Explanation 2:

 Sum of all nodes of 0'th level is 1
 Sum of all nodes of 1'th level is 5
 Sum of all nodes of 2'th level is 17
 Sum of all nodes of 3'th level is 13
 Hence maximum sum is 17","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
int Solution::solve(TreeNode* root){
    // Base case
    if (root == NULL)
        return 0;

    // Initialize result
    int result = root->val;

    // Do Level order traversal keeping track of number of nodes at every level.
    queue<TreeNode*> q;
    q.push(root);
    while (!q.empty())
    {
        // Get the size of queue when the level order traversal for one level finishes
        int count = q.size() ;
        // Iterate for all the nodes in the queue currently
        int sum = 0;
        while (count--)
        {
            // Dequeue an node from queue
            TreeNode *temp = q.front();
            q.pop();

            // Add this node's value to current sum.
            sum = sum + temp->val;

            // Enqueue left and right children of
            // dequeued node
            if (temp->left != NULL)
                q.push(temp->left);
            if (temp->right != NULL)
                q.push(temp->right);
        }
        // Update the maximum node count value
        result = max(sum, result);
    }
    return result;
}"
Pick from both sides!,https://www.interviewbit.com/problems/pick-from-both-sides/,N/A,Arrays,easy,"Problem Description
 
 

Given an integer array A of size N.

You have to pick exactly B elements from either left or right end of the array A to get the maximum sum.

Find and return this maximum possible sum.

NOTE: Suppose B = 4 and array A contains 10 elements then

You can pick the first four elements or can pick the last four elements or can pick 1 from the front and 3 from the back etc. you need to return the maximum possible sum of elements you can pick.


Problem Constraints
1 <= N <= 105

1 <= B <= N

-103 <= A[i] <= 103



Input Format
First argument is an integer array A.

Second argument is an integer B.



Output Format
Return an integer denoting the maximum possible sum of elements you picked.



Example Input
Input 1:

 A = [5, -2, 3 , 1, 2]
 B = 3
Input 2:

 A = [1, 2]
 B = 1


Example Output
Output 1:

 8
Output 2:

 2


Example Explanation
Explanation 1:

 Pick element 5 from front and element (1, 2) from back so we get 5 + 1 + 2 = 8
Explanation 2:

 Pick element 2 from end as this is the maximum we can get","int fun(vector < int > & A, int B) {
  int n = A.size();
  int suff[n + 1];
  suff[n] = 0;
  suff[n - 1] = A[n - 1];
  for (int i = n - 2; i >= 0; i--)
    suff[i] = A[i] + suff[i + 1];
  int prefSum = 0;
  int ans = suff[n - B];
  for (int i = 0; i < B; i++) {
    prefSum = prefSum + A[i];
    int suffSum = suff[n - B + (i + 1)];
    ans = max(ans, prefSum + suffSum);
  }
  return ans;
}
int Solution::solve(vector < int > & A, int B) {
  return fun(A, B);
}"
Merge K sorted arrays!,https://www.interviewbit.com/problems/merge-k-sorted-arrays/,N/A,Heaps And Maps,medium,"Problem Description

You are given K sorted integer arrays in a form of 2D integer matrix A of size K X N.

You need to merge them into a single array and return it.



Problem Constraints
1 <= K, N <= 103

0 <= A[i][j] <= 108

A[i][j] <= A[i][j+1]



Input Format
First and only argument is an 2D integer matrix A.



Output Format
Return a integer array denoting the merged array you get after merging all the arrays in A.



Example Input
Input 1:

 A = [  [1, 2, 3]
        [2, 4, 6]
        [0, 9, 10]
     ]


Example Output
Output 1:

 [0, 1, 2, 2, 3, 4, 6, 9, 10]


Example Explanation
Explanation 1:

 You need to merge [1, 2, 3] , [2, 4, 6] and [0, 9, 10]  into a single array
 so the merged array will look like [0, 1, 2, 2, 3, 4, 6, 9, 10]
","typedef pair<int,pair<int,int>> ppi;

vector<int> Solution::solve(vector<vector<int> > &A) {
    priority_queue<ppi, vector<ppi>, greater<ppi>> q;
    vector<int> res;

    for(int i=0;i<A.size();i++) q.push({A[i][0],{i,0}});

    pair<int,int> pr;

    while(!q.empty())
    {
        res.push_back(q.top().first);
        pr = q.top().second;
        q.pop();

        if(pr.second+1 < A[pr.first].size()) q.push({A[pr.first][pr.second+1],{pr.first,pr.second+1}});
    }
    return res;
}"
Minimum Difference Subsets!,https://www.interviewbit.com/problems/minimum-difference-subsets/,Uber,Dynamic Programming,medium,"Problem Description

Given an integer array A containing N integers.

You need to divide the array A into two subsets S1 and S2 such that the absolute difference between their sums is minimum.

Find and return this minimum possible absolute difference.

NOTE:

Subsets can contain elements from A in any order (not necessary to be contiguous).
Each element of A should belong to any one subset S1 or S2, not both.
It may be possible that one subset remains empty.


Problem Constraints
1 <= N <= 100

1 <= A[i] <= 100



Input Format
First and only argument is an integer array A.



Output Format
Return an integer denoting the minimum possible difference among the sums of two subsets.



Example Input
Input 1:

 A = [1, 6, 11, 5]


Example Output
Output 1:

 1


Example Explanation
Explanation 1:

 Subset1 = {1, 5, 6}, sum of Subset1 = 12
 Subset2 = {11}, sum of Subset2 = 11
","int Solution::solve(vector<int> &A) {
    int n = A.size();
    int totalsum = 0;
    for(int i=0;i<n;i++)
    totalsum += A[i];
    
     int dp[n+1][totalsum];
     
     for(int i=0;i<totalsum+1;i++)
     dp[0][i] = 0;
     
     for(int i=0;i<n+1;i++)
     dp[i][0] = 1;
     
     for(int i=1;i<n+1;i++)
     for(int j=0;j<totalsum+1;j++)
     {
         if(A[i-1]<=j)
         dp[i][j] = dp[i-1][j-A[i-1]] | dp[i-1][j];
         else
         dp[i][j] = dp[i-1][j];
     }
     
     for(int i=totalsum/2;i>=0;i--)
     {
         if(dp[n][i] == 1){
         return abs(totalsum - i*2);
        //  break;
         }
     }
    //  return ans;
}
"
Sort array with squares!,https://www.interviewbit.com/problems/sort-array-with-squares/,N/A,Arrays,easy,"Problem Description

Given a sorted array A containing N integers both positive and negative.

You need to create another array containing the squares of all the elements in A and return it in non-decreasing order.

Try to this in O(N) time.


Problem Constraints
1 <= N <= 105.

-103 <= A[i] <= 103



Input Format
First and only argument is an integer array A.



Output Format
Return a integer array as described in the problem above.



Example Input
Input 1:

 A = [-6, -3, -1, 2, 4, 5]
Input 2:

 A = [-5, -4, -2, 0, 1]


Example Output
Output 1:

 [1, 4, 9, 16, 25, 36]
Output 2:

 [0, 1, 4, 16, 25]","// function to sort array after doing squares of elements
vector < int > sortSquares(vector < int > & arr) {
  // first dived array into part negative and positive
  vector<int> t;
  
  for(int i = 0; i < arr.size(); i++){
      t.push_back(arr[i]);
  }
  sort(t.begin(), t.end());
  
  int n = arr.size();
  for(int i = 0; i < n; i++){
      assert(arr[i] == t[i]);
  }
  int K = 0;

  for (K = 0; K < n; K++)
    if (arr[K] >= 0)
      break;

  // Now do the same process that we learn
  // in merge sort to merge to two sorted array
  // here both two half are sorted and we traverse
  // first half in reverse meaner because
  // first half contain negative element
  int i = K - 1; // Initial index of first half
  int j = K; // Initial index of second half
  int ind = 0; // Initial index of temp array

  // store sorted array
  vector < int > temp(n);
  while (i >= 0 && j < n) {
    if ((arr[i] * arr[i]) < (arr[j] * arr[j])) {
      temp[ind] = arr[i] * arr[i];
      i--;
    } else {
      temp[ind] = arr[j] * arr[j];
      j++;
    }
    ind++;
  }

  /* Copy the remaining elements of first half */
  while (i >= 0) {
    temp[ind] = arr[i] * arr[i];
    i--;
    ind++;
  }

  /* Copy the remaining elements of second half */
  while (j < n) {
    temp[ind] = arr[j] * arr[j];
    j++;
    ind++;
  }
  return temp;
}

vector < int > Solution::solve(vector < int > & A) {
  return sortSquares(A);
}"
Counting Subarrays!,https://www.interviewbit.com/problems/counting-subarrays/,Uber,Two Pointers,medium,"Problem Description

Given an array A of N non-negative numbers and you are also given non-negative number B.

You need to find the number of subarrays in A having sum less than B. We may assume that there is no overflow.



Problem Constraints
1 <= N <= 104

1 <= A[i] <= 100

1 <= B <= 108



Input Format
First argument is an integer array A.

Second argument is an integer B.



Output Format
Return an integer denoting the number of subarrays in A having sum less than B.



Example Input
Input 1:

 A = [2, 5, 6]
 B = 10
Input 2:

 A = [1, 11, 2, 3, 15]
 B = 10


Example Output
Output 1:

 4
Output 2:

 4


Example Explanation
Explanation 1:

 The subarrays with sum less than B are {2}, {5}, {6} and {2, 5},
Explanation 2:

 The subarrays with sum less than B are {1}, {2}, {3} and {2, 3}
","int Solution::solve(vector<int> &A, int B) {
    int n=A.size(),count=0,sum=0,j=0;

    for(int i=0;i<n;i++)
    {
        sum+=A[i];
        while(sum>=B)
        {
            sum-=A[j];
            j++;
        }
        count+=i-j+1;
    }
    return count;
}"
Subset Sum Problem!,https://www.interviewbit.com/problems/subset-sum-problem/,Zenefits,Dynamic Programming,medium,"Problem Description

Given an integer array A  of size N.

You are also given an integer B, you need to find whether their exist a subset in A whose sum equal B.

If there exist a subset then return 1 else return 0.



Problem Constraints
1 <= N <= 100

1 <= A[i] <= 100

1 <= B <= 105



Input Format
First argument is an integer array A.

Second argument is an integer B.



Output Format
Return 1 if there exist a subset with sum B else return 0.



Example Input
Input 1:

 A = [3, 34, 4, 12, 5, 2]
 B = 9
Input 2:

 A = [3, 34, 4, 12, 5, 2]
 B = 30


Example Output
Output 1:

 1
Output 2:

 0


Example Explanation
Explanation 1:

 There is a subset (4, 5) with sum 9.
Explanation 2:

 There is no subset that add up to 30.
","int Solution::solve(vector<int> &A, int B) {
        int n = A.size(); 
        
    vector<int> dp(B+1, 0); 
    
    dp[0] = 1; 

    for(int i=0; i<n; i++){
        int e = A[i]; 
        for(int j=B; j>=e; j--){
            if(dp[j-e]==1){
                dp[j]=1;
            }
            if(dp[B]) return 1;
        }
    }
    
    return dp[B]==1;
}"
XOR-ing the Subarrays!,https://www.interviewbit.com/problems/xor-ing-the-subarrays/,Zenefits,Bit Manipulation,medium,"Problem Description

Given an integer array A of size N.

You need to find the value obtained by XOR-ing the contiguous subarrays, followed by XOR-ing the values thus obtained. Determine and return this value.

For example, if A = [3, 4, 5] :

Subarray    Operation   Result
3       None            3
4       None            4
5       None            5
3,4   3 XOR 4         7
4,5   4 XOR 5         1
3,4,5    3 XOR 4 XOR 5   2

Now we take the resultant values and XOR them together:

3 ? 4 ? 5 ? 7 ? 1? 2 = 6 we will return 6.



Problem Constraints
1 <= N <= 105

1 <= A[i] <= 108



Input Format
First and only argument is an integer array A.



Output Format
Return a single integer denoting the value as described above.



Example Input
Input 1:

 A = [1, 2, 3]
Input 2:

 A = [4, 5, 7, 5]


Example Output
Output 1:

 2
Output 2:

 0


Example Explanation
Explanation 1:

 1 ? 2 ? 3 ?  (1 ? 2 ) ? (2 ? 3) ? (1 ? 2 ? 3) = 2
Explanation 2:

 4 ? 5 ? 7 ? 5 ? (4 ? 5) ? (5 ? 7) ? (7 ? 5) ? (4 ? 5 ? 7) ? (5 ? 7 ? 5) ? (4 ? 5 ? 7 ? 5) = 0
","int Solution::solve(vector<int> &A) {
    int res = 0 , n = A.size() ;
    for (int i = 0 ; i < n ; i++)
    {
        int val = (i+1)*(n-i);
        if (val % 2 == 1)
        {
           res  = res ^ A[i] ;   
        }
    }
    return res;
}"
Longest Subarray Length,https://www.interviewbit.com/problems/longest-subarray-length/,N/A,Hashing,medium,"Problem Description
 
 

Given an integer array A of size N containing 0's and 1's only.

 

 

 

 

You need to find the length of the longest subarray having count of 1’s one more than count of 0’s.

 

 

Note: In the subarray count of 1's should be one more than the count of 0's.

 



Problem Constraints
1 <= N <= 105



Input Format
First and only argument is an integer array A of size N.



Output Format
Return an integer denoting the longest length of the subarray.



Example Input
Input 1:

 A = [0, 1, 1, 0, 0, 1]
Input 2:

 A = [1, 0, 0, 1, 0]


Example Output
Output 1:

 5
Output 2:

 1


Example Explanation
Explanation 1:

 Subarray of length 5, index 1 to 5 i.e 1, 1, 0, 0, 1. Count of 1 = 3, Count of 0 = 2.
Explanation 2:

 Subarray of length 1 will be only subarray that follow the above condition.
","int Solution::solve(vector<int> &nums) {
    int prefixSum = 0;
    unordered_map<int,int>mp;
    mp[0] = -1;
    int res = 0;
    
    for(int i=0; i<nums.size(); ++i){
        prefixSum += (nums[i]==0) ? -1 : 1;
        
        if(mp.count(prefixSum-1))
            res = max(res,i-mp[prefixSum-1]);
            
        if(!mp.count(prefixSum))
            mp[prefixSum] = i;
    }
    
    return res;
    
}"
First Repeating element,https://www.interviewbit.com/problems/first-repeating-element/,N/A,Hashing,easy,"Problem Description

Given an integer array A of size N, find the first repeating element in it.

We need to find the element that occurs more than once and whose index of first occurrence is smallest.

If there is no repeating element, return -1.



Problem Constraints
1 <= N <= 105

1 <= A[i] <= 109



Input Format
First and only argument is an integer array A of size N.



Output Format
Return an integer denoting the first repeating element.



Example Input
Input 1:

 A = [10, 5, 3, 4, 3, 5, 6]
Input 2:

 A = [6, 10, 5, 4, 9, 120]


Example Output
Output 1:

 5
Output 2:

 -1


Example Explanation
Explanation 1:

 5 is the first element that repeats
Explanation 2:

 There is no repeating element, output -1
","int Solution::solve(vector<int> &A) {
    int n = A.size();
    // Initialize index of first repeating element
    int mini = -1;

    // Creates an empty hashset named ump
    unordered_map<int,int> ump;

    // Traverse the input array from right to left
    for (int i = n - 1; i >= 0; i--)
    {
        // If element is already in hash set, update min
        if (ump.find(A[i]) != ump.end())
            mini = i;
        else   // Else add element to hash set
            ump[A[i]] = 1;
    }
    if(mini == -1){
        return mini;
    }
    return A[mini];
}"
Merge elements,https://www.interviewbit.com/problems/merge-elements/,N/A,Dynamic Programming,hard,"Problem Description

Given an integer array A of size N. You have to merge all the elements of the array into one with the minimum possible cost.

The rule for merging is as follows:

Choose any two adjacent elements of the array with values say X and Y and merge them into a single element with value (X + Y) paying a total cost of (X + Y).
Return the minimum possible cost of merging all elements.



Problem Constraints
1 <= N <= 200

1 <= A[i] <= 103



Input Format
First and only argument is an integer array A of size N.



Output Format
Return an integer denoting the minimum cost of merging all elements.



Example Input
Input 1:

 A = [1, 3, 7]
Input 2:

 A = [1, 2, 3, 4]


Example Output
Output 1:

 15
Output 2:

 19


Example Explanation
Explanation 1:

 All possible ways of merging:
 a) {1, 3, 7} (cost = 0) -> {4, 7} (cost = 4) -> {11} (cost = 4+11 = 15)
 b) {1, 3, 7} (cost = 0) -> {1, 10} (cost = 10) -> {11} (cost = 10+11 = 21)
 Thus, ans = 15","int n;
int a[205];
int pre[205];
int dp[205][205];

int rec(int i,int j){
    if(i<0 || j<0 || i>=n || j>=n || i>j){
        return 0;
    }
    if(i==j){
        return 0;
    }
    if(dp[i][j]!=-1){
        return dp[i][j];
    }
    int ans=100000000;
    for(int k=i+1;k<=j;k++){
        ans=min(ans,rec(i,k-1)+pre[j]-pre[i]+a[i]+rec(k,j));
    }
    dp[i][j]=ans;
    return dp[i][j];
}

int Solution::solve(vector<int> &A) {
    n=A.size();
    for(int i=0;i<n;i++){
        a[i]=A[i];
        if(i==0){
            pre[i]=a[i];
        }
        else{
            pre[i]=pre[i-1]+a[i];
        }
        for(int j=0;j<n;j++){
            dp[i][j]=-1;
        }
    }
    return rec(0,n-1);
}"
Balance Array,https://www.interviewbit.com/problems/balance-array/,N/A,Arrays,easy,"Problem Description

Given an integer array A of size N. You need to count the number of special elements in the given array.

A element is special if removal of that element make the array balanced.

Array will be balanced if sum of even index element equal to sum of odd index element.



Problem Constraints
1 <= N <= 105

1 <= A[i] <= 109



Input Format
First and only argument is an integer array A of size N.



Output Format
Return an integer denoting the count of special elements.



Example Input
Input 1:

 A = [2, 1, 6, 4]
Input 2:

 A = [5, 5, 2, 5, 8]


Example Output
Output 1:

 1
Output 2:

 2


Example Explanation
Explanation 1:

 After deleting 1 from array : {2,6,4}
    (2+4) = (6)
 Hence 1 is the only special element, so count is 1
Explanation 2:

 If we delete A[0] or A[1] , array will be balanced
    (5+5) = (2+8)
 So A[0] and A[1] are special elements, so count is 2.
","int Solution::solve(vector<int> &A) {
    int n = A.size();
    int odd = 0, even = 0;
    int leftOdd[n], rightOdd[n];
    int leftEven[n], rightEven[n];
    for(int i = 0;i < n; i++){
        leftOdd[i] = odd;
        leftEven[i] = even;
        if(i%2 == 0)
            even += A[i];
        else
            odd += A[i];
    }
    odd = 0;
    even = 0;
    for(int i = n-1; i >= 0; i--){
        rightOdd[i] = odd;
        rightEven[i] = even;
        if(i%2 == 0)
            even += A[i];
        else
            odd += A[i];
    }
    int ans = 0;
    for(int i = 0; i < n; i++){
        if(leftOdd[i] + rightEven[i] == leftEven[i] + rightOdd[i]){
            ans++;
        }
    }
    return ans;
}"
Max Min,https://www.interviewbit.com/problems/max-min-05542f2f-69aa-4253-9cc7-84eb7bf739c4/,Google,Arrays,easy,"Problem Description

Given an array A of size N. You need to find the sum of Maximum and Minimum element in the given array.

NOTE: You should make minimum number of comparisons.



Problem Constraints
1 <= N <= 105

-109 <= A[i] <= 109



Input Format
First and only argument is an integer array A of size N.



Output Format
Return an integer denoting the sum Maximum and Minimum element in the given array.



Example Input
Input 1:

 A = [-2, 1, -4, 5, 3]
Input 2:

 A = [1, 3, 4, 1]


Example Output
Output 1:

 1
Output 2:

 5


Example Explanation
Explanation 1:

 Maximum Element is 5 and Minimum element is -4. (5 + (-4)) = 1. 
Explanation 2:

 Maximum Element is 4 and Minimum element is 1. (4 + 1) = 5.","//Using the approach of divide and conquer.
pair<int,int> findMinMax(vector<int> &A, int start, int end){
    if(start == end)
        return make_pair(A[start], A[start]);

    int mid = (end-start)/2 + start;
    //Find Min and Max pair for left sub-array
    pair<int,int> mm1 = findMinMax(A,start,mid);
    //Find Min and Max pair for right sub-array
    pair<int,int> mm2 = findMinMax(A,mid+1,end);

    //Compare the value to get the max and min for the entire array.
    int minNum = mm1.first < mm2.first ? mm1.first : mm2.first;
    int maxNum = mm1.second > mm2.second ? mm1.second : mm2.second;

    //Return max and min values as a pair.
    return make_pair(minNum,maxNum);
}

int Solution::solve(vector<int> &A) {
    pair<int,int> minMax = findMinMax(A,0,A.size()-1);
    return minMax.first + minMax.second;
}"
Subarrays with distinct integers!,https://www.interviewbit.com/problems/subarrays-with-distinct-integers/,Uber,Two Pointers,medium,"Problem Description

Given an array A of positive integers,call a (contiguous,not necessarily distinct) subarray of A good if the number of different integers in that subarray is exactly B.

(For example: [1, 2, 3, 1, 2] has 3 different integers 1, 2 and 3)

Return the number of good subarrays of A.



Problem Constraints
1 <= |A| <= 40000

1 <= A[i] <= |A|

1 <= B <= |A|



Input Format
The first argument given is the integer array A.

The second argument given is an integer B.



Output Format
Return an integer denoting the number of good subarrays of A.



Example Input
Input 1:

 A = [1, 2, 1, 2, 3]
 B = 2
Input 2:

 A = [1, 2, 1, 3, 4]
 B = 3


Example Output
Output 1:

 7
Output 2:

 3


Example Explanation
Explanation 1:

  Subarrays formed with exactly 2 different integers: [1, 2], [2, 1], [1, 2], [2, 3], [1, 2, 1], [2, 1, 2], [1, 2, 1, 2].
Explanation 2:

  Subarrays formed with exactly 3 different integers: [1, 2, 1, 3], [2, 1, 3], [1, 3, 4].","int at_most(vector<int> A,int k){
    int n = A.size(),s = 0,ans = 0,j = 0,i = 0;
    unordered_map<int,int> mp;
    while(j < n){
        mp[A[j]]++;
        while(mp.size() > k){
            mp[A[i]]--;
            if(mp[A[i]] == 0) mp.erase(A[i]);
            i++;
        }
        ans += (j-i+1);
        j++;
    }
    return ans;
}

int Solution::solve(vector<int> &A, int B) {
    return at_most(A,B)-at_most(A,B-1);
}"
Path in Directed Graph,https://www.interviewbit.com/problems/path-in-directed-graph/,Uber,Graph Data Structure & Algorithms,easy,"Problem Description

Given an directed graph having A nodes labelled from 1 to A containing M edges given by matrix B of size M x 2such that there is a edge directed from node

B[i][0] to node B[i][1].

Find whether a path exists from node 1 to node A.

Return 1 if path exists else return 0.

NOTE:

There are no self-loops in the graph.
There are no multiple edges between two nodes.
The graph may or may not be connected.
Nodes are numbered from 1 to A.
Your solution will run on multiple test cases. If you are using global variables make sure to clear them.


Problem Constraints
2 <= A <= 105

1 <= M <= min(200000,A(A-1))

1 <= B[i][0], B[i][1] <= A



Input Format
The first argument given is an integer A representing the number of nodes in the graph.

The second argument given a matrix B of size M x 2 which represents the M edges such that there is a edge directed from node B[i][0] to node B[i][1].



Output Format
Return 1 if path exists between node 1 to node A else return 0.



Example Input
Input 1:

 A = 5
 B = [  [1, 2] 
        [4, 1] 
        [2, 4] 
        [3, 4] 
        [5, 2] 
        [1, 3] ]
Input 2:

 A = 5
 B = [  [1, 2]
        [2, 3] 
        [3, 4] 
        [4, 5] ]


Example Output
Output 1:

 0
Output 2:

 1


Example Explanation*
Explanation 1:

 The given doens't contain any path from node 1 to node 5 so we will return 0.
Explanation 2:

 Path from node1 to node 5 is ( 1 -> 2 -> 3 -> 4 -> 5 ) so we will return 1.
","int Solution::solve(int A, vector<vector<int> > &B) {
    vector<vector<int>> gp(A+1);
    
    for (const auto &it : B) {
        int  x = it[0];
        int  y = it[1];
        gp[x].push_back(y);
    }
    
    queue<int> q;
    q.push(1);
    vector<int> vis(A+1,0);
    vis[1] = true;
    
    while(!q.empty()) {
        int node = q.front();
        q.pop();
     
        
        for (auto const &it : gp[node]) {
            if (vis[it])continue;
            vis[it] = true;
            q.push(it);
        }
    }
    
    return vis[A];
    
}"
Path with good nodes!,https://www.interviewbit.com/problems/path-with-good-nodes/,N/A,Graph Data Structure & Algorithms,easy,"Problem Description

Given a tree with N nodes labelled from 1 to N.

Each node is either good or bad denoted by binary array A of size N where if A[i] is 1 then ithnode is good else if A[i] is 
0 then ith node is bad.

Also the given tree is rooted at node 1 and you need to tell the number of root to leaf paths in the tree that contain not more than C good nodes.

NOTE:

Each edge in the tree is bi-directional.


Problem Constraints
2 <= N <= 105

A[i] = 0 or A[i] = 1

0 <= C <= N



Input Format
First argument is an binary integer array A of size N.

Second argument is a 2-D array B of size (N-1) x 2 denoting the edge of the tree.

Third argument is an integer C.



Output Format
Return an integer denoting the number of root to leaf paths in the tree that contain not more than C good nodes.



Example Input
Input 1:

 A = [0, 1, 0, 1, 1, 1]
 B = [  [1, 2]
        [1, 5]
        [1, 6]
        [2, 3]
        [2, 4]
     ]
 C = 1


Example Output
Output 1:

 3


Example Explanation
Explanation 1:

 Path (1 - 2 - 3) and (1 - 5) and (1 - 6) are the paths which contain atmost C nodes.","void dfs(vector<int> &A, vector<bool> &visited, int C,int u,vector<vector<int> > &adj, int &count,int good)
{
  //general Node
    if(good+A[u-1]>C)
    return ;
    
    //leaf Node
    if(adj[u].size()==1 && !visited[u] && C>=good+A[u-1])
    {count++;return;}
    
      //else go forward
    visited[u]=true;
    
    for(int i=0;i<adj[u].size();i++)
    {
        if(!visited[adj[u][i]])
        {
          dfs(A,visited,C,adj[u][i],adj,count,good+A[u-1]);  
            
        }
        
    }
    
 return ;   
}






int Solution::solve(vector<int> &A, vector<vector<int> > &B, int C) {
    int count = 0;
    vector<bool> visited(A.size()+1,false);
    vector<vector<int> > adj(A.size()+1);
    for(int i=0;i<B.size();i++)
    {
        adj[B[i][0]].push_back(B[i][1]);
        adj[B[i][1]].push_back(B[i][0]);
    }
    
  dfs(A,visited,C,1,adj,count,0);
  return count;
}"
Xor Between Two Arrays!,https://www.interviewbit.com/problems/xor-between-two-arrays/,N/A,Tree Data Structure,easy,"Problem Description

Given two integer array A and B, you have to pick one element from each array such that their xor is maximum.

Return this maximum xor value.



Problem Constraints
1 <= |A|, |B| <= 105

1 <= A[i], B[i] <= 109



Input Format
First argument is an integer array A.

Second argument is an integer array B.



Output Format
Return an integer denoting the maximum xor value as described in the question.



Example Input
Input 1:

 A = [1, 2, 3]
 B = [4, 1, 2]


Example Output
Output 1:

 7


Example Explanation
Explanation 1:

 Pick A[2] and B[0] because their xor value is maximum. 3 ^ 4 = 7
","class TrieNode
{
    TrieNode* links[2];
    public:
    TrieNode()
    {
        for(int i=0; i<2; i++) links[i] = NULL;
    }

    TrieNode* get(int bit)
    {
        return links[bit];
    }

    void put(int bit)
    {
        links[bit] = new TrieNode();
    }

    bool containsKey(int bit)
    {
        return links[bit] != NULL;
    }
};

class Trie
{
    TrieNode* root;
    public:
    Trie()
    {
        root = new TrieNode();
    }

    void insertNum(int num)
    {
        TrieNode* curr = root;
        for(int i=31; i>=0; i--)
        {
            int bit = (num>>i) & 1;
            if(!curr->containsKey(bit))
            {
                curr->put(bit);
            }
            curr = curr->get(bit);
        }
    }

    int getMaxXor(int num) // get the maximum xor possible with any number present in trie 
    {
        int mx = 0;
        TrieNode* curr = root;
        for(int i=31; i>=0; i--)
        {
            // find ith bit of x
            int bit = (num>>i) & 1;
            // check if trie contains opposite of this bit
            if(curr->containsKey(1-bit)) // if yes, update maximum XOR by setting ith bit to 1
            {
                mx = mx | (1<<i);
                // move to that node
                curr = curr->get(1-bit);
            }
            // if not, then move to the available bit
            else curr = curr->get(bit);
        }
        return mx;
    }
};

int Solution::solve(vector<int> &arr1, vector<int> &arr2) {
    Trie trie;
    int n = arr1.size(), m = arr2.size();
    for(int i=0; i<n; i++)
        trie.insertNum(arr1[i]); // time complexity O(n*32)
    // check maximum xor for every number of arr2
    int ans = 0;
    for(int i=0; i<m; i++)
    {
        ans = max(ans, trie.getMaxXor(arr2[i])); // time complexity O(m*32)
    }
    return ans;
}"
Max edge queries!,https://www.interviewbit.com/problems/max-edge-queries/,N/A,Dynamic Programming,medium,"Problem Description

Given a tree with N nodes numbered from 1 to N.

Each edge is bi-directional and has a certain weight assigned to it.

You are given Q queries, in each query you are given two integers u and v and you are required to find the maximum weighted edge in a simple path from u to v.

You have to return the weight of the edge for each queries.



Problem Constraints
2 <= N, Q <= 105

1 <= u, v <= N  and u != v

1 <= weight of any edge <= 108



Input Format
First argument is a 2-D array A of size (N-1) x 3  where  (A[i][0], A[i][1]) denotes an edge of the tree from node A[i][0] to node A[i][1] with weight A[i][2].

Second argument is a 2-D array B of size Q x 2 denoting the queries, B[i][0] denotes u and B[i][1] denotes v.



Output Format
Return an integer array of size Q denoting the answer for each queries.



Example Input
Input 1:

 A = [  [1, 2, 11]
        [1, 3, 1]
        [2, 4, 12]
        [2, 5, 100]
     ]
 B = [  [3, 5]
        [2, 3]
     ]


Example Output
Output 1:

 [100, 11]


Example Explanation
Explanation 1:

 Query 1: u  = 3 and v = 5 so edge (2 -> 5) is the maximum weighted in the path from u to v so we will return the
 edge weight as the answer for this query.
 Query 2: u = 2 and  v= 3 so edge (2 -> 1) is the maximum weighted in the path from u to v so we will return the
 edge weight as the answer for this query.
","#define mp make_pair
#define pb push_back
vector<pair<int,int> >graph[100010];
int level[100010];
int dp[100010][18],mx[100010][18];
void dfs(int u,int h)
{
    dp[u][0] = h;
    if(h!=-1)
        level[u] = level[h]+1;
    for(int i=0;i<graph[u].size();i++)
    {
        int v = graph[u][i].first;
        if(v==h)
            continue;
        int wt = graph[u][i].second;
        dfs(v,u);
        mx[v][0] = wt;
    }
    return;
}
void precal(int n)
{
    for(int h=1;h<18;h++)
    {
        for(int i=0;i<n;i++)
        {
            if(dp[i][h-1]!=-1)
            {
                dp[i][h] = dp[dp[i][h-1]][h-1];
                mx[i][h] = max(mx[i][h-1],mx[dp[i][h-1]][h-1]);
            }
        }
    }
}
int comp(int a,int b)
{
    if(level[a]<level[b])
        swap(a,b);
    int ans=0;
    for(int i=17;i>=0;i--)
    {
        if(level[a]-(1<<i)>=level[b])
        {
            ans = max(ans,mx[a][i]);
            a = dp[a][i];
        }
    }
    if(a==b)
        return ans;
    for(int i=17;i>=0;i--)
    {
        if(dp[b][i]!=-1 && dp[b][i]!=dp[a][i])
        {
            ans = max(ans,mx[a][i]);
            ans = max(ans,mx[b][i]);
            a = dp[a][i];
            b = dp[b][i];
        }
    }
    ans = max(ans,mx[a][0]);
    ans = max(ans,mx[b][0]);
    return ans;
}
vector<int> Solution::solve(vector<vector<int> > &A, vector<vector<int> > &B) 
{
    int n = A.size()+1;
    for(int i=0;i<n;i++)
    {
        graph[i].clear();
    }
    for(int i=0;i<A.size();i++)
    {
        int u = A[i][0], v = A[i][1], w = A[i][2];
        graph[u-1].pb(mp(v-1,w));
        graph[v-1].pb(mp(u-1,w));
    }
    level[0] = 0;
    memset(dp,-1,sizeof(dp));
    dfs(0,-1);
    precal(n);
    vector<int>ans;
    for(int i=0;i<B.size();i++)
    {
        int u = B[i][0]-1;
        int v = B[i][1]-1;
        int x = comp(u,v);
        ans.pb(x);
    }
    return ans;
}"
Disjoint Intervals,https://www.interviewbit.com/problems/disjoint-intervals/,Google,Greedy Algorithm,medium,"Problem Description

Given a set of N intervals denoted by 2D array A of size N x 2, the task is to find the length of maximal set of mutually disjoint intervals.

Two intervals [x, y] & [p, q] are said to be disjoint if they do not have any point in common.

Return a integer denoting the length of maximal set of mutually disjoint intervals.



Problem Constraints
1 <= N <= 105

1 <= A[i][0] <= A[i][1] <= 109



Input Format
First and only argument is a 2D array A of size N x 2 denoting the N intervals.



Output Format
Return a integer denoting the length of maximal set of mutually disjoint intervals.



Example Input
Input 1:

 A = [
       [1, 4]
       [2, 3]
       [4, 6]
       [8, 9]
     ]
Input 2:

 A = [
       [1, 9]
       [2, 3]
       [5, 7]
     ]


Example Output
Output 1:

 3
Output 2:

 2


Example Explanation
Explanation 1:

 Intervals: [ [1, 4], [2, 3], [4, 6], [8, 9] ]
 Intervals [2, 3] and [1, 4] overlap.
 We must include [2, 3] because if [1, 4] is included thenwe cannot include [4, 6].
 We can include at max three disjoint intervals: [[2, 3], [4, 6], [8, 9]]
Explanation 2:

 Intervals: [ [1, 9], [2, 3], [5, 7] ]
 We can include at max two disjoint intervals: [[2, 3], [5, 7]]
","bool comp(vector<int> a,vector<int> b)
{
    if(a[1]<b[1])
    {
        return 1;
    }
    else if(a[1]==b[1])
    {
        return a[0]<b[0];
    }
    return 0;
}
int Solution::solve(vector<vector<int> > &A) {

    sort(A.begin(),A.end(),comp);

    int c=0,ans=0;

    for(auto x:A)
    {
        if(x[0]>c)
        {
            ans++;
            c=x[1];
        }
    }

    return ans;

}"
Water Flow,https://www.interviewbit.com/problems/water-flow/,Google,Graph Data Structure & Algorithms,medium,"Problem Description

Given an N x M matrix A of non-negative integers representing the height of each unit cell in a continent, the ""Blue lake"" touches the left and top edges of the matrix and the ""Red lake"" touches the right and bottom edges.

Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.

Find the number of cells from where water can flow to both the Blue and Red lake.



Problem Constraints
1 <= M, N <= 1000

1 <= A[i][j] <= 109



Input Format
First and only argument is a 2D matrix A.



Output Format
Return an integer denoting the number of cells from where water can flow to both the Blue and Red lake.



Example Input
Input 1:

 A = [
       [1, 2, 2, 3, 5]
       [3, 2, 3, 4, 4]
       [2, 4, 5, 3, 1]
       [6, 7, 1, 4, 5]
       [5, 1, 1, 2, 4]
     ]
Input 2:

 A = [
       [2, 2]
       [2, 2]
     ]


Example Output
Output 1:

 7
Output 2:

 4


Example Explanation
Explanation 1:

 Blue Lake ~   ~   ~   ~   ~ 
        ~  1   2   2   3  (5) *
        ~  3   2   3  (4) (4) *
        ~  2   4  (5)  3   1  *
        ~ (6) (7)  1   4   5  *
        ~ (5)  1   1   2   4  *
           *   *   *   *   * Red Lake
 Water can flow to both lakes from the cells denoted in parentheses.

Explanation 2:

 Water can flow from all cells.","int red[1001][1001], blue[1001][1001];

bool check(int x, int y, int n, int m){
    if(x >= 0 && x < n && y >= 0 && y < m){
        return true;
    }
    return false;
}

int Solution::solve(vector<vector<int> > &A) {
    int n = A.size(), m = A[0].size();
    int ans = 0;
    for(int i = 0; i < n; i++){
        for(int j = 0; j < m; j++){
            blue[i][j] = 0;
            red[i][j] = 0;
        }
    }
    queue<pair<int,int>> q;
    // All the co-ordinates which touches blue lake on left edge
    for(int i = 1; i < n; i++){
        q.push({i,0});
        blue[i][0] += 1;
    }
    // All the co-ordinates which touches blue lake on top edge
    for(int i = 0; i < m; i++){
        q.push({0,i});
        blue[0][i] += 1;
    }
    int dx[4] = {0, 0, 1, -1};
    int dy[4] = {1, -1, 0, 0};


    while(!q.empty()){
        pair<int,int> idx = q.front();
        q.pop();
        for(int i = 0; i < 4; i++){
            int x = idx.first + dx[i], y = idx.second + dy[i];
            if(check(x, y, n, m) && blue[x][y] == 0 && A[x][y] >= A[idx.first][idx.second]){
                  q.push({x,y});
                  blue[x][y] += 1;
            }
        }
    }
    // All the co-ordinates which touches red lake on right edge
    for(int i = 0; i < n; i++){
        q.push({i,m-1});
        red[i][m-1] += 1;
    }
    // All the co-ordinates which touches red lake on bottom edge
    for(int i = m-2; i >= 0; i--){
        q.push({n-1,i});
        red[n-1][i] += 1;
    }

    while(!q.empty()){
        pair<int,int> idx = q.front();
        if(red[idx.first][idx.second] == 1 && blue[idx.first][idx.second] == 1){
            ans += 1;
        }
        q.pop();
        for(int i = 0; i < 4; i++){
            int x = idx.first + dx[i], y = idx.second + dy[i];
            if(check(x, y, n, m) && red[x][y] == 0 && A[x][y] >= A[idx.first][idx.second]){
                  q.push({x,y});
                  red[x][y] += 1;
            }
        }
    }
    return ans;
}"
Burn a Tree,https://www.interviewbit.com/problems/burn-a-tree/,Amazon,Tree Data Structure,medium,"Problem Description

Given a binary tree denoted by root node A and a leaf node B from this tree.

 It is known that all nodes connected to a given node (left child, right child and parent) get burned in 1 second. Then all the nodes which are connected through one intermediate get burned in 2 seconds, and so on.

You need to find the minimum time required to burn the complete binary tree.



Problem Constraints
2 <= number of nodes <= 105

1 <= node value, B <= 105

node value will be distinct



Input Format
First argument is a root node of the binary tree, A.

Second argument is an integer B denoting the node value of leaf node.



Output Format
Return an integer denoting the minimum time required to burn the complete binary tree.



Example Input
Input 1:

 Tree :      1 
            / \ 
           2   3 
          /   / \
         4   5   6
 B = 4
Input 2:

 Tree :      1
            / \
           2   3
          /     \
         4       5 
 B = 5 


Example Output
Output 1:

 4
Output 2:

 4


Example Explanation
Explanation 1:

 After 1 sec: Node 4 and 2 will be burnt. 
 After 2 sec: Node 4, 2, 1 will be burnt.
 After 3 sec: Node 4, 2, 1, 3 will be burnt.
 After 4 sec: Node 4, 2, 1, 3, 5, 6(whole tree) will be burnt.
 
Explanation 2:

 After 1 sec: Node 5 and 3 will be burnt. 
 After 2 sec: Node 5, 3, 1 will be burnt.
 After 3 sec: Node 5, 3, 1, 2 will be burnt.
 After 4 sec: Node 5, 3, 1, 2, 4(whole tree) will be burnt.
 
","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
/*
    ***********ADDITIONAL INFO*************
    lDepth - maximum height of left subtree
    rDepth - maximum height of right subtree
    contains - stores true if tree rooted at current node contains the first burnt node
    time - time to reach fire from the initally burnt leaf node to this node
*/

struct Info {
    int lDepth;
    int rDepth;
    bool contains;
    int time;
    Info()
    {
        lDepth = rDepth = 0;
        contains = false;

        time = -1;
    }
};

/*
    Function to calculate time required to burn tree completely
    node - address of current node
    info - extra information about current node
    target - node that is fired
    res - stores the result
*/

void calcTime(TreeNode* node, Info& info, int target, int& res){
    // Base case: if root is null
    if (node == NULL) {
        return;
    }

    // If current node is leaf
    if (node->left == NULL && node->right == NULL) {

        // If current node is the first burnt node
        if (node->val == target) {
            info.contains = true;
            info.time = 0;
        }
        return;
    }

    // Information about left child of root
    Info leftInfo;
    calcTime(node->left, leftInfo, target, res);

    // Information about right child of root
    Info rightInfo;
    calcTime(node->right, rightInfo, target, res);

    // If left subtree contains the fired node then time required to reach fire to current node will be (1 + time required for left child)
    info.time = (node->left && leftInfo.contains) ? (leftInfo.time + 1) : -1;

    // If right subtree contains the fired node then time required to reach fire to current node will be (1 + time required for right child)
    if (info.time == -1)
        info.time = (node->right && rightInfo.contains) ? (rightInfo.time + 1) : -1;

    // Storing(true or false) if the tree rooted at current node contains the fired node
    info.contains = ((node->left && leftInfo.contains) || (node->right && rightInfo.contains));

    // Calculate the maximum depth of left subtree
    info.lDepth = !(node->left) ? 0 : (1 + max(leftInfo.lDepth, leftInfo.rDepth));

    // Calculate the maximum depth of right subtree
    info.rDepth = !(node->right) ? 0 : (1 + max(rightInfo.lDepth, rightInfo.rDepth));

    // Calculating answer
    if (info.contains) {
        // If left subtree exists and it contains the fired node
        if (node->left && leftInfo.contains) {
            // calculate result
            res = max(res, info.time + info.rDepth);
        }

        // If right subtree exists and it contains the fired node
        if (node->right && rightInfo.contains) {
            // calculate result
            res = max(res, info.time + info.lDepth);
        }
    }
}

int Solution::solve(TreeNode* A, int B) {
    int res = 0;
    Info info;
    calcTime(A, info, B, res);
    return res;
}"
Collect Resources,https://www.interviewbit.com/problems/collect-resources/,Uber,Dynamic Programming,medium,"Problem Description

There is a rectangular field with two types of resources viz, resource A and resource B. At each cell in the field, both of 
the resources can be present. There are two types of factories which can collect resource A and B. If resource A is collected 
in a factory then resource B is lost and vice versa. Now, these two factories are located perpendicular to each other i.e the 
factory collecting resource A is at the top ( north) of the rectangular field and the factory collecting resource B is to the 
left ( west) of the rectangular field. The resources have to be brought to the factory on a straight path without taking any 
turns. This implies that if there is any south-north conveyor belt in the cell, but the cell north of it contains an east-west 
conveyor belt, then all resources transported on the south-north conveyor belt will be lost.

You have to design a conveyor belt system that maximizes the total amount of minerals mined, i.e the sum of the amount of 
resource A transported to the top and the sum of the amount of resource B transported to the left. You are given a 2-D matrix 
A and B of the same size denoting the amount of resource of the corresponding type in that 
cell.

Since the answer can be large, return it modulo 109 + 7.



Problem Constraints
1 <= |A| = |B| <= 103

1 <= |A[0]| = |B[0]| <=103

0 <= A[i][j], B[i][j] <= 109



Input Format
The first line contains a matrix that specifies the availability of the resource A in each of the cells. 

The second line contains a matrix that specifies the availability of the resource B in each of the cells.



Output Format
Return a single integer which specifies the maximum amount of resources that can be processed by the factories.



Example Input

  Input 1:

   A = [
         [7, 8, 9]
         [4, 5, 6]
         [1, 2, 3]
       ]


B = [
         [1, 2, 3]
         [4, 5, 6]
         [7, 8, 9]
       ]

Input 2:

   A = [
         [1, 0, 1]
       ]


B = [
         [2, 1, 0]
       ]



Example Output

  Output 1:

  63
Output 2:

  4


Example Explanation

  Explanation 1:

  The first row can be sent to the top to collect resource A. The rest two rows will be sent to the left to collect resource B. 
Explanation 2:

  The first two columns can be sent to the left. The third column will be sent to the top.Total resource collected - 2 + 1 + 1 = 4 ","int r,c,a[1005][1005],b[1005][1005];
long long dp[1005],mx[1005];
int Solution::solve(vector<vector<int> > &A, vector<vector<int> > &B) {
    long long ans=0,s=0;
    r=A.size();
    c=A[0].size();
    for(int i=0;i<r;i++)
    {
        for(int j=0;j<c;j++)
        {
            a[i][j]=A[i][j];
            ans+=a[i][j];
        }
    }
    for(int i=0;i<r;i++)
    {
        for(int j=0;j<c;j++)
        {
            b[i][j]=B[i][j];
            b[i][j]-=a[i][j];
        }
    }
    dp[0]=0;
    mx[0]=0;
    for(int i=1;i<=c;i++)
    {
        s+=b[0][i-1];
        dp[i]=s;
        mx[i]=max(mx[i-1],dp[i]);
    }
    for(int i=1;i<r;i++)
    {
        dp[0]=mx[0];
        s=0;
        for(int j=1;j<=c;j++)
        {
            s+=b[i][j-1];
            dp[j]=s+mx[j];
        }
        for(int j=1;j<=c;j++)
            mx[j]=max(mx[j-1],dp[j]);
    }
    return (ans+mx[c])%1000000007;
}"
Queries On A Tree,https://www.interviewbit.com/problems/queries-on-a-tree/,N/A,Graph Data Structure & Algorithms,hard,"Problem Description

You are given a tree of size N.

The edges are given by the vector P of size N-1 where ith element represents an edge between i+1 and P[i]. (1-based indexing)

You need to answer Q queries on it.

In each query, you are given a set of nodes S.

You need to find the size of the minimal connected subgraph (which will also be a tree) containg all nodes in the set S.



Problem Constraints
1 ? N, Q, summation |S| ? 105
1 ? S[i] ? N


Input Format
Input consists of 2 arguments, first is the array A = P of size N-1 and second is the 2D array B of size (sum |S|) x 2 representing the queries in the same order.

Here, A and B are the names of the arguments in the function provided to you.

The queries are given in the format (qid, node) where qid is the query number and node is one of the nodes in the set S[qid].

It is guaranteed that queries are numbered consecutively starting from 1.

Refer samples for more details.



Output Format
Return a vector of integers, the answer to all the queries in increasing order of qid.



Example Input
Input 1:

 P = [1, 2, 3, 4]
 queries = [
                [1, 3],
                [1, 5]
           ]
Input 2:

 A = [1, 1, 1, 1]
 queries = [
                [1, 1],
                [1, 2],
                [1, 3],
                [2, 2],
                [2, 4],
                [3, 5]
           ]


Example Output
Output 1:

 [3]
Output 2:

 [3, 3, 1]


Example Explanation
Explanation 1:

 There is only one query.


Query 1:
 Set S = {3, 5}
 We must take subgraph formed by {3, 4, 5}. Therefore answer is 3.

Explanation 2:

 There are 3 queries.


Query 1:
 Set S = {1, 2, 3}
 If we just take these nodes, the subgraph is already connected and is minimal. Therefore answer is 3.



Query 2:
 Set S = {2, 4}
 We must take subgraph formed by {2, 1, 4}. Therefore answer is 3.



Query 3:
 Set S = {5}
 We just take node 5 here. Therefore answer is 1.

","#define ll          long long
#define pb          push_back
#define pii         pair<int,int>
#define vi          vector<int>
#define vii         vector<pii>
#define mi          map<int,int>
#define mii         map<pii,int>
#define all(a)      (a).begin(),(a).end()
#define x           first
#define y           second
#define sz(x)       (int)x.size()
#define endl        '\n'
#define hell        1000000007
#define rep(i,a,b)  for(int i=a;i<b;i++)
using namespace std;
int n,q,p[100005],h[100005],dp[20][100005],queries[100005][2],cnt,tim[100005];
vii v[100005];
vi a[100005];
void dfs(int node){
	tim[node]=++cnt;
	for(auto i:a[node]){
		dfs(i);
	}
}
int lca(int U,int V){
    if(h[U]>h[V]) swap(U,V);
    for(int i=19;i>=0;i--){
        if(h[V]-(1<<i)>=h[U]) V=dp[i][V];
    }
    if(U==V) return U;
    for(int i=19;i>=0;i--){
        if(dp[i][U]!=dp[i][V]) U=dp[i][U],V=dp[i][V];
    }
    return dp[0][U];
}
vector<int> Solution::solve(vector<int> &A, vector<vector<int> > &B) {
    n=sz(A)+1;
    rep(i,1,n+1) a[i].clear();
    cnt=0;
    p[1]=1;
    dp[0][1]=1;
    h[1]=1;
    rep(i,2,n+1){
    	p[i]=A[i-2];
    	dp[0][i]=p[i];
    	h[i]=h[p[i]]+1;
    	a[p[i]].pb(i);
    }
    rep(i,1,20){
    	rep(j,1,n+1){
    		dp[i][j]=dp[i-1][dp[i-1][j]];
    	}
    }
    dfs(1);
    q=sz(B);
    rep(i,1,q+1) v[i].clear();
    rep(i,0,q){
    	queries[i][0]=B[i][0];
    	queries[i][1]=B[i][1];
    	v[queries[i][0]].pb({tim[queries[i][1]],queries[i][1]});
    }
    q=queries[q-1][0];
    vi res;
    rep(i,1,q+1){
    	sort(all(v[i]));
    	int ans=h[v[i][0].y]-h[lca(v[i].back().y,v[i][0].y)]+1;
    	rep(j,1,sz(v[i])) ans+=h[v[i][j].y]-h[lca(v[i][j].y,v[i][j-1].y)];
        res.pb(ans);
    }
    return res;
}"
Magical Pool and Items,https://www.interviewbit.com/problems/magical-pool-and-items/,N/A,Greedy Algorithm,easy,"Problem Description

There are N items in the magical pool where ith item has A[i][0] quality and A[i][1] quantity.

Robin trying to be greedy wants to maximize the total quantity of items picked but he can only pick one item at a time with the highest quality available in the pool with corresponding quantity.

Let's say the quality of item picked is X.

The pool is magical and all items in the pool with similar quality disappears and a new item with quality = floor(X/2) and quantity = X * 2 is added.

Robin will never choose the item with quality 0.

Return the maximum quantity of items Robin can pick. Since the answer could be large, return answer % 109 + 7.



Problem Constraints
1 <= N <= 105

1 <= A[i][0], A[i][1] <= 109



Input Format
First and only argument is a 2D array A of size N x 2 denoting the quality and quantity of the items in the magical pool.



Output Format
Return an integer denoting the maximum quantity of items Robin can pick.



Example Input
Input 1:

 A = [ 
       [5, 2]
       [2, 11]
       [5, 1]
       [1, 3]
     ]
Input 2:

 A = [
       [1, 2]
       [1, 1]
       [2, 3]
     ]


Example Output
Output 1:

 17
Output 2:

 7


Example Explanation
Explanation 1:

 Pick item with quality 5 and quantity 2. All items with quality 5 disappears i.e item [5, 1] and a new item [2, 10] is added.
 Pick item [2, 11]. Item [2, 10] disappears and [1, 4] is added.
 Pick item [1, 4]. Item [1, 3] disappears and [0, 2] is added.
 Now, robin can't pick any item. Total quantity = 17.
 
Explanation 2:

 Pick item [2, 3]. Add item [1, 4].
 Pick item [1, 4]. Items [1, 2] and [1, 1] disappears and [0, 2] is added.
 Total quantity = 7.
 ","int Solution::solve(vector<vector<int> > &A) {
    const int MOD = 1e9 + 7;
    priority_queue<pair<int,long long>> pq;
    for(auto &x: A){
        pq.push({x[0], x[1]});
    }
    int ans = 0;
    while(!pq.empty()){
        auto top = pq.top();
        pq.pop();
        
        ans += top.second % MOD;
        ans %= MOD;
        while(!pq.empty() and pq.top().first == top.first)pq.pop();
        
        if(top.first/2 > 0)
        pq.push({top.first/2, top.first * 2});
    }
    return ans;
}"
Bribing was never Easy!,https://www.interviewbit.com/problems/bribing-was-never-easy/,N/A,Arrays,medium,"Problem Description

There are N students labelled from 1 to N  standing in a queue (initial state of the queue is 1, 2, 3 .... N).

Also each student has certain number of coins with themselves which they can use to bribe the students standing in front of them to exchange position.

For example: if N = 6 and student 5 bribes student 4 then the queue will look like this: 1, 2, 3, 5, 4, 6.

You are given an array A of size N which denotes the current state of the queue, you need to find the minimum number of bribes that took place to get the queue into its current state or is it impossible to reach.

NOTE:

If any student contains x coins then he/she can bribe atmost x students in front of them.
Bribing any student cost 1 coin.
In a single bribing event student standing at index i can only bribe student standing at index i - 1 and then the new index of the student who bribed will be i - 1, he can continue the same steps in the future bribing events.


Problem Constraints
1 <= N <= 105

1 <= A[i] <= N

0 <= coins with each student <= 100



Input Format
First argument is an integer array A of size N denoting the current state of queue.

Second argument is an integer array B of size N denoting the coins associated with each student.

NOTE:

Array B is given to you as 0-indexed but B[0] represents coins associates with student labelled 1 similarly for each i in [0, N-1] B[i] represents coins associated with student labelled (i + 1).


Output Format
Return the minimum number of bribes which took place to get to the current state of queue from the initial state, else if it is not possible to reach the current state then return -1.



Example Input
Input 1:

 A = [2, 1, 5, 3, 4]
 B = [2, 2, 2, 2, 2]
Input 2:

 A = [2, 5, 1, 3, 4]
 B = [1, 2, 3, 2, 1]


Example Output
Output 1:

 3
Output 2:

 -1


Example Explanation
Explanation 1:

 The initial state =>                                                 1 2 3 4 5
 After student 5 moves one position ahead by bribing student 4 =>     1 2 3 5 4
 Now student 5 moves another position ahead by bribing student 3 =>   1 2 5 3 4
 And student 2 moves one position ahead by bribing student 1 =>       2 1 5 3 4
 So the final state is 2,1,5,3,4 after three bribing operations.
Explanation 2:

 Student 5 can't bribe this many people as it contains only 1 coin.
","int Solution::solve(vector<int> &A, vector<int> &B) {
    int n=A.size();
    int a[n+1],index[n+1];
    for(int i=1;i<=n;i++){
        a[i]=A[i-1];
        index[a[i]]=i;
    }
    int ans=0;
    for(int i=n;i>=1;i--){
        if(index[i]==i) continue;
        int gap=i-index[i];
        if(gap<0 or gap>B[i-1]) return -1;
        ans+=gap;
        for(int j=index[i];j<i;j++){
            swap(a[j],a[j+1]);
            swap(index[a[j]],index[a[j+1]]);
        }
    }
    return ans;
}"
Even Product!,https://www.interviewbit.com/problems/even-product/,N/A,Arrays,easy,"Problem Description

Given an integer array A containing N integers.

You can perform a certain type of operation on this array A i.e you can select any number of elements from the array A and change it to whatever value you want.

Initially the Product of elements of the array A is ODD you need to find the total number of distinct operations (modulo 109 + 7) you can perform to make the product of array EVEN.

Two operations are said to be different if there exist atleast one element which is not selected in the other operation.



Problem Constraints
1 <= N <= 105

1 <= A[i] <= 106



Input Format
First and only argument is an integer array A.



Output Format
Return a single integer denoting the total number of distinct operations (modulo 109 + 7) you can perform to make the product of array A as EVEN.



Example Input
Input 1:

 A = [1, 3]
Input 2:

 A = [3]


Example Output
Output 1:

 3
Output 2:

 1


Example Explanation
Explanation 1:

 We can perform atmost three operations:
 Operation 1: Selecting element at index 0 and changing its value to 2 so A = [2, 3] Product = 6
 Operation 2: Selecting element at index 1 and changing its value to 10 so A = [1, 10] Product = 10
 Operation 3: Selecting element at index 0 and 1 and changing their value to 2 so A = [2, 2] Product = 4
 We can't perform any other operations on this array.
Explanation 2:

 We can perform atmost one operations:
 Operation 1: Selecting element at index 0 and changing its value to 20 so A = [20] Product = 20
","int Solution::solve(vector<int> &A) {
    int n=A.size();
    int ans=1,mod=1e9+7;
    for(int i=0;i<n;i++)
        ans=(ans*2)%mod;
    ans--;
    return ans;
}"
Predict Future!,https://www.interviewbit.com/problems/predict-future/,N/A,Math,easy,"Problem Description

Batman and Robin are on a mission. Their is a bomb which they want to diffuse but the problem is they have to solve a task first which is very difficult for them.

As you are their friend, they ask you to solve the problem for them.

You are given a pair (A, B). After each operation pair (A, B) gets changed to (B - 2A, 2B + A).

You are given the initial value of A and B you have to find and return the value of pair after Cth operation.



Problem Constraints
1 <= A, B C <= 109



Input Format
First argument is an integer A.

Second argument is an integer B.

Third argument is an integer C.



Output Format
Return an integer array containing two integers (mod 109 + 7) denoting the two values of pair after C operations.



Example Input
Input 1:

 A = 1
 B = 3
 C = 1
Input 2:

 A = 5
 B = 10
 C = 2


Example Output
Output 1:

 [1, 7]
Output 2:

 [25, 50]


Example Explanation
Explanation 1:

 Initally pair is (1, 3) after one operation => (3 - 21 , 23 + 1) => (1, 7)
Explanation 2:

 Initally pair is (5, 10) after one operation => (0, 25) and after second operation  => (25, 50)
","const int M = 1e9 + 7;
int expo(int a, int b, int mod){
    int ans = 1;
    while(b){
        if(b&1)
            ans = (ans * 1LL * a)%mod;
        a = (a * 1LL * a)%mod;
        b >>= 1;
    }
    return ans;
}
vector<int> Solution::solve(int A, int B, int C) {
    int mul = expo(5,C/2,M);
    int a = (A * 1LL * mul)%M;
    int b = (B * 1LL * mul)%M;
    vector<int>ans = {a,b};
    if(C&1){
        ans[0] = ((b - 2LL * a)%M + M)%M;
        ans[1] = (2LL * b + a)%M;
    }
    return ans;
}"
Sell items,https://www.interviewbit.com/problems/sell-items/,N/A,Math,easy,"Problem Description

A shopkeeper sells daily A units of item and his shop remains closed on weekends(Saturday and Sunday).

Find the number of weeks it will take to sell B units of item.

Assume first day to be Monday and return the ceil value of number of weeks. For eg: If it takes 9 days to sell all units then return 2 weeks.



Problem Constraints
1 <= A, B <= 109



Input Format
First argument is an integer A dentoing the daily units sold by the shopkeeper.

Second argument is an integer B denoting the total units of item.



Output Format
Return an integer denoting the required numbers of weeks.



Example Input
Input 1:

 A = 3
 B = 17
Input 2:

 A = 1
 B = 1


Example Output
Output 1:

 2
Output 2:

 1


Example Explanation
Explanation 1:

 On the first 5 days, shopkeeper can sell 15 units. On next 2 days shop remains closed(weekends). 
 On 8th day sold remaining 2 units. Number of weeks will be 2.
Explanation 2:

 On 1st day, shopkeeper can sell 1 unit. Nothing is remaining. Answer will be 1 week.
","int Solution::solve(int A, int B) {
    int days = (B+A-1)/A;
    return (days+4)/5;
}"
Make them Equal,https://www.interviewbit.com/problems/make-them-equal/,N/A,Arrays,easy,"Problem Description

You are given an array A of length N. In one operation you can select an index i ( 1 <= i <= N ) and change A[i] to floor(A[i]/2). floor(x) is the largest integer not greater than x. 

We want to make all the elements of the array equal. Calculate the minimum number of operations needed to do so.



Problem Constraints
1 <= N <= 105

1 <= A[i] <= 2 × 109



Input Format
The first and only argument contains an integer array A of length N.



Output Format
Return the minimum number of operations to make all the elements of the array equal.



Example Input

  Input 1:

  A : [ 3, 1, 1, 3 ]
Input 2:

  A : [ 2, 2, 2 ]


Example Output

  Output 1:

  2
Output 2:

  0


Example Explanation

  Explanation 1:

  We can do an operation on index 1 and 4 to change the array to [1, 1, 1, 1]
Explanation 2:

  All the elements are already same.
","int Solution::solve(vector<int> &A) {
    int n=A.size();
    map<int,int>f;
    for(auto i:A){
        int b=i;
        while(b){
            f[b]++;
            b/=2;
        }
    }
    int opt=1;
    for(auto i:f){
        if(i.second==n)
            opt=i.first;
    }
    int ans=0;
    for(auto i:A){
        int b=i;
        while(b!=opt){
            ans++;
            b/=2;
        }
    }
    return ans;
}"
Subarray Cost Sum,https://www.interviewbit.com/problems/subarray-cost-sum/,N/A,Arrays,hard,"Problem Description

Let's the sum of the array S be sum(S) and the maximum be max(S). The cost of an array S is ceil(sum(S)/2) * max(S). ceil(x) is the smallest integer not less than x.

You have an array A of length N. Find the sum of the cost of all the subarrays of this array.

Since the answer can be large, return it modulo 109 + 7.



Problem Constraints
1 <= N <= 5 x 105

1 <= A[i] <= 106



Input Format
The first and only argument contains an integer array A of length N.



Output Format
Return the sum of cost of all subarrays modulo 109 + 7.



Example Input

  Input 1:

  A : [ 1, 2 ]
Input 2:

  A : [5]


Example Output

  Output 1:

  7
Output 2:

  15


Example Explanation

  Explanation 1:

  The array has 3 subarrays-
  1. [1] - Cost = 1 * ceil(1/2) = 1
  2. [2] - Cost = 2 * ceil(2/2) = 2
  3. [1, 2] - Cost = 2 * ceil(3/2) = 4
  Sum of cost = 7
Explanation 2:

  It has only one subarray. Cost is 5 * ceil(5/2) = 15","int n,a[500005],s[3][500005],L[500005],R[500005];
const int mod = 1e9 + 7;
int f(int l,int mid,int r){
    int sum1 = ((mid - l + 1)*1ll*(s[1][r]-s[1][mid-1]+mod)%mod)%mod;
    int sum2 = ((r-mid+1)*1ll*(s[1][mid-1]-(l>=2?s[1][l-2]:0)+mod)%mod)%mod;
    int sum = (sum1 - sum2 + mod)%mod;
    int c1 = (s[2][mid-1] - (l >= 2 ? s[2][l-2]:0));
    int c2 = (s[2][r] - s[2][mid-1]);
    int odd = (c1 *1ll* (r-mid+1-c2) + c2 * 1ll * (mid-l+1-c1))%mod;
    sum=(sum+odd)%mod;
    sum=(sum*1ll*((mod+1)/2))%mod;
    return sum;
}
int Solution::solve(vector<int> &A) {
    int n=A.size();
    for(int i=1;i<=n;i++){
        a[i]=A[i-1];
        s[0][i]=(s[0][i-1]+a[i])%mod;
        s[1][i]=(s[0][i]+s[1][i-1])%mod;
        s[2][i]=(s[2][i-1]+(s[0][i]&1));
    }
    for(int i=1;i<=n;i++){
        L[i]=i-1;
        while(L[i] and a[L[i]]<a[i])
            L[i]=L[L[i]];
    }
    for(int i=n;i>=1;i--){
        R[i]=i+1;
        while(R[i]<=n and a[R[i]]<=a[i])
            R[i]=R[R[i]];
    }
    int ans=0;
    for(int i=1;i<=n;i++){
        ans=(ans+a[i]*1ll*f(L[i]+1,i,R[i]-1))%mod;
    }
    return ans;
}"
First Index,https://www.interviewbit.com/problems/first-index/,N/A,Binary Search,easy,"Problem Description

You are given an array A of length N. You need to solve Q queries. In each query, you will be given an integer B[i] and you need to find the index of the element which is at least B[i]. If there are several such indexes, return the minimum such index. Return -1 if no such index exists.

Note- The array is 0 indexed.



Problem Constraints
1 <= N,Q <= 5 x 105 

1 <= A[i], B[i] <= 109



Input Format
The first argument contains an integer array A of length N.

The second argument contains an integer array B of length Q, denoting the queries.



Output Format
Return an array of length Q, containing the answer to the queries.

f


Example Input

  Input 1:

  A : [ 9, 1 ]
  B : [ 7, 10, 3 ]
Input 2:
   A : [ 2, 3, 4 ]
  B : [ 2, 3, 4 ]


Example Output

  Output 1:

  [0, -1, 0]
Output 2:
  [0, 1, 2]


Example Explanation

  Explanation 1:

  The first element 9 is greater than 7 and 3. No element greater than 10 exists.
Explanation 2:
  Since the queries and array are same, the answer will the index of the element.
","vector<int> Solution::solve(vector<int> &A, vector<int> &B) {
    int n,a,q;
    n=A.size();
    assert(n>=1 && n<=500000);
    for(int aa:A)
        assert(aa>=1 && a<=1e9);
    for(int aa:B)
        assert(aa>=1 && a<=1e9);
    vector<pair<int,int>>v;
    for(int i=0;i<n;i++){
        a=A[i];
        if(v.empty() or a>v.back().first)
            v.push_back({a,i});
    }   
    q=B.size();
    assert(q>=1 && q<=500000);
    vector<int>ans;
    for(int i=0;i<q;i++){
        a=B[i];
        if(a>v.back().first)
            ans.push_back(-1);
        else{
            pair<int,int>g={a,0};
            ans.push_back(lower_bound(v.begin(),v.end(),g)->second);
        }
    }
    return ans;
}"
Red Zone,https://www.interviewbit.com/problems/red-zone/,N/A,Binary Search,hard,"Problem Description
 
 

There are many people who believe that the earth is flat and NASA is a scam. They call themselves Flat Earthers. They were already worried that the 6 feet social distancing rule might push some people out of the earth.

Now, they decided to think about a new issue. Since the earth is flat ( or so they think), let's imagine it as an infinite 2D grid. They have the coordinates of certain points which are orange zones and have some COVID-19 cases reported. Now each day the orange zones become more fatal. After d days, all the locations within a euclidean distance of d of a particular orange zone can be affected by this zone.

They know N orange zones, each of whose coordinates are given by (A[i][0], A[i][1]). Now, a location is considered a red zone if it is affected by at least B orange zones. You need to find the first day at which the first red zone is reported.



Problem Constraints
2 <= B <= N <= 100

0 <= A[i][0], A[i][1] <= 109



Input Format
The first argument contains a 2D array A of size N, denoting the coordinates of the orange zones.

The second argument contains an integer B.



Output Format
Return the first day at which the first red zone is reported.



Example Input

  Input 1:

  A : 
  [
    [8, 5]
    [0, 4]
    [3, 6]
  ]
  B : 3
Input 2:

  A : 
  [
    [2, 3]
    [9, 4]
    [10, 3]
  ]
  B : 2


Example Output

  Output 1:

  5
Output 2:

  1


Example Explanation

  Explanation 1:

  One of the red zones will be (5, 4) and it is within a distance of 5 from all the orange zones.
Explanation 2:

  One of the red zones will be (9, 3) and it is within a distance of 1 from 2 orange zones.","#include<bits/stdc++.h>
typedef double C;
typedef complex<C> P;
#define X real()
#define Y imag()
P a[205];
int n, x, y, k;
bool check(int r){
    int c=0;
    for(int i = 0; i < n; i++){
        for(int j = i+1; j < n; j++){
            P g = a[j] - a[i];
            double d = abs(g);
            if(d > 2*r) continue;
            P mid = (a[i] + a[j]) * (1.0/2);
            double h = sqrt(r*1.0*r - d*d/4);
            P per = P(-g.Y,g.X) * (h/d);
            int c1 = 2, c2 = 2;
            for(int l = 0; l < n; l++){
                if(l == i or l == j) continue;
                if(abs(a[l] - (mid-per)) <= r)
                    c1++;
                if(abs(a[l] - (mid+per)) <= r)
                    c2++;
            }
            c=max({c,c1,c2});
        }
    }
    return c>=k;
}
int Solution::solve(vector<vector<int> > &A, int B) {
    n = A.size();
    for(int i = 0; i < n;i++)
        a[i] = {1.0*A[i][0], 1.0*A[i][1]};
    k = B;
    int l = 1, h = 2000000000, ans;
    while(h >= l){
        int m = (l+h)/2;
        if(check(m)) {
            ans = m;
            h = m-1;
        }
        else l = m+1;
    }
    return ans;
}"
Queries in Infinite String!,https://www.interviewbit.com/problems/queries-in-infinite-string/,N/A,Strings,medium,"Problem Description

Suppose Suzuka has an empty string S. In First iteration she adds all character from 'a' to 'z' in S i.e now S = ""abcdefghijklmnopqrstuvwxyz"".

In Second iteration she add all character from 'a' to 'z' two times each i.e after second iteration S = ""a..zaabbccdd..zz""

Similarly in Third iteration she add all characters from 'a' to 'z' three times each, and so on suzuka perform the iterations infinite number of times.

Nobita asks out Suzuka for a Drive but Suzuka will only go with Nobita if Nobita solves a certain problem.

As you are a good friend of Nobita, he ask you to solve the problem.

You have to answer Q queries ,in each query you are given two integer L and R you need to tell the number of vowels in the substring of String S ranging from L to R inclusive.

NOTE:

Assume String S as 1-indexed i.e S[1] = 'a'.


Problem Constraints
1 <= L, R <= 109

1 <= Q <= 103



Input Format
First and only argument is an 2D integer array A of size Q x 2 where (A[i][0], A[i][1]) denotes the L, R for Query i.



Output Format
Return an integer array containing Q integers denoting the answers to queries.

NOTE:

Return the answers to the queries in the order, in which the queries occur in the input.


Example Input
Input 1:

 A = [
        [1, 5]
        [26, 29]
     ]
Input 2:

 A = [
        [79, 85]
     ]


Example Output
Output 1:

 [2, 2]
Output 2:

 [3]


Example Explanation
Explanation 1:

 String S = ""abcdefghijklmnopqrstuvwxyzaabbccddeeff...zzaaabbbccc...zzz......""
 Query 1: Substring [1 : 5] of S is ""abcde"" 
  Number of vowels = 2
 Query 2: Substring [26 : 29] of S is ""zaab"" 
  Number of vowels = 2
Explanation 2:

 Query 1: Substring [79 : 85] of S is ""aaabb"" 
  Number of vowels = 3
","int query(int n){
    int r = (sqrt(169 + 52ll * n) - 13)/26;
    int ans = 5*r*(r+1)/2;
    n -= 13*r*(r+1);
    r += 1;
    for(int i = 0; i < 26; i++){
        int d = min(r, n);
        n -= d;
        if(i == 0 or i == 4 or i == 8 or i == 14 or i == 20)
            ans += d;
    }
    return ans;
}
vector<int> Solution::solve(vector<vector<int> > &A) {
    vector<int> ans;
    for(auto q: A)
        ans.push_back(query(q[1]) - query(q[0] - 1));
    return ans;
}"
Flipping String,https://www.interviewbit.com/problems/flipping-string/,N/A,Strings,easy,"Problem Description

You are given an numeric string A which only contains 0's and 1's. You have to find a range, such that if we flip all the elements within the range, we will get largest substring of contiguous 1's.

Return the length of largest substring of contiguous 1's after flipping exactly one substring.

NOTE:

Given string always contains atleast one zero.


Problem Constraints
1 <= |A| <= 105



Input Format
First and only argument is an string A.



Output Format
Return an integer denoting the length of largest substring of contiguous 1's after flipping exactly one substring.



Example Input
Input 1:

 A = ""000""
Input 2:

 A = ""10010""


Example Output
Output 1:

 3
Output 2:

 4


Example Explanation
Explanation 1:

 Flip the substring [0:2] then A = ""111"" so answer will be 3
Explanation 2:

 Flip the substring [1:2] then A = ""11110"" so answer will be 4
","int Solution::solve(string A) {
    vector<pair<int, int>> v;
    int i = 0, ans = 0;
    while(i < A.size()){
        int j = i;
        while(j < A.size() and A[j] == A[i])
            j++;
        v.push_back({A[i] - '0', j - i});
        i = j;
    }
    for(int i = 0; i < v.size(); i++){
        if(v[i].first)
            ans = max(ans, v[i].second);
        else
            ans = max(ans, v[i].second + (i ? v[i-1].second : 0) + (i+1 < v.size() ? v[i+1].second : 0));
    }
    return ans;
}"
Maximize matrix XOR,https://www.interviewbit.com/problems/maximize-matrix-xor/,N/A,Bit Manipulation,easy,"Problem Description

Robin buys an integer matrix A of size N x M.

His mother asked him to perform the following operation exactly once such that the bitwise XOR of the elements is maximized.

Select any row or column of the matrix and decrement each element of the selected row or coloumn by 1.
Return the maximum value of bitwise XOR of elements after performing the above operation.



Problem Constraints
1 <= N x M <= 5 * 105

1 <= A[i][j] <= 109



Input Format
First and only argument is a 2D array A of size N x M.



Output Format
Return an integer denoting the maximum value of bitwise XOR of the matrix.



Example Input
Input 1:

 A = [
       [2, 3]
       [4, 5]
     ]
Input 2:

 A = [
       [1, 2]
     ]


Example Output
Output 1:

 6
Output 2:

 2


Example Explanation
Explanation 1:

 Select 2nd row and decrement each element. So the new matrix is [[2, 3], [3, 4]].
 XOR of elements will be 6.
 
Explanation 2:

 Select 1st col and decrement the only element. New matrix is [[0, 2]].
 XOR of elements will be 2.
","int Solution::solve(vector<vector<int> > &A) {
    int n = A.size(), m = A[0].size(), x = 0;
    int r[n] = {0}, c[m] = {0};
    for(int i = 0; i < n; i++){
        for(int j = 0; j < m; j++){
            x ^= A[i][j];
            r[i] ^= (A[i][j] ^ (A[i][j] - 1));
            c[j] ^= (A[i][j] ^ (A[i][j] - 1));    
        }
    }
    int ans = 0;
    for(int i = 0; i < n; i++)
        ans = max(ans, x ^ r[i]);
    for(int i = 0; i < m; i++)
        ans = max(ans, x ^ c[i]);
    return ans;
}"
Diagonally powerful Matrix,https://www.interviewbit.com/problems/diagonally-powerful-matrix/,N/A,Bit Manipulation,medium,"Problem Description

Robin purchase an integer matrix A of size N x M.

He wants to make the matrix Diagonally powerful Matrix, but he can only use the below operation:

Select any element, multiply or divide it by 2. Take floor while dividing it by 2.
Matrix is called Diagonally powerful matrix if all diagonals starting from Top or Left and ending at Bottom or Right is Powerful.

A diagonal is powerful if bitwise AND of the elements in the diagonal is greater than 1.

Find and return the minimum number of operations required to convert the matrix into Diagonally powerful Matrix.



Problem Constraints
1 <= N x M <= 104

1 <= A[i][j] <= 107



Input Format
First and only argument is a 2D array A.



Output Format
Return an integer denoting the minimum number of operations required to convert the matrix into Diagonally powerful Matrix.



Example Input
Input 1:

 A = [
       [2, 2, 1]
       [10, 4, 1]
       [11, 3, 2] 
     ]
 
Input 2:

 A = [
       [1]
       [5]
     ]


Example Output
Output 1:

 3
Output 2:

 1


Example Explanation
Explanation 1:

 Three operations are required:
 Select all 1's and multiply by 2 and select 4 and divide it by 2.
 
Explanation 2:

 Select 1 and multiply by 2, since we need AND greater than 1.","int cost(vector<int>& v){
    int ans = 1e9;
    for(int i = 1; i < 26; i++){
        int cur = 0;
        for(auto j : v){
            int temp = 1e9;
            for(int k = 0; k < 26; k++){
                if(j & (1 << k))
                    temp = min(temp, abs(i-k));
            }
            cur += temp;
        }
        ans = min(ans, cur);
    }
    return ans;
}
int Solution::solve(vector<vector<int> > &A) {
    int n = A.size(), m = A[0].size(), ans = 0;
    for(int i = 0; i < n; i++){
        vector<int> v;
        int r = i, c = 0;
        while(r < n and c < m)
            v.push_back(A[r++][c++]);
        ans += cost(v);
    }
    for(int i = 1; i < m; i++){
        vector<int> v;
        int r = 0, c = i;
        while(r < n and c < m)
            v.push_back(A[r++][c++]);
        ans += cost(v);
    }
    return ans;
}"
Help Rishabh!,https://www.interviewbit.com/problems/help-rishabh/,N/A,Two Pointers,medium,"Problem Description

Rishabh and Ojas are on a mission. Their is a bomb which they want to diffuse but the problem is they have to solve a task first which is very difficult for them.

As you are their friend, they ask you to solve the problem for them.

Given an integer array A containing N integers.

You need to find the total number of Scaler Subarrays in A.

A subarray is called Scaler Subarray if there are exactly B elements in the subarray which occurs atleast 2 times.



Problem Constraints
1 <= N <= 105

1 <= A[i] <= 103

1 <= B <= N



Input Format
First argument is an integer array A.

Second argument is an integer B.



Output Format
Return an integer denoting the total number of Scaler Subarrays in A.

NOTE: It is guaranteed that the output never exceeds the INTEGER 32 Bit range.



Example Input
Input 1:

 A = [1, 2, 3, 1, 2, 3]
 B = 2
Input 2:

 A = [1, 1, 1, 2, 2]
 B = 1


Example Output
Output 1:

 2
Output 2:

 7


Example Explanation
Explanation 1:

 There are only two Scaler Subrrays
 1. A[0:4] i.e [1, 2, 3, 1, 2] as 1 and 2 only have occurences greater than or equal to 2
 2. A[1:5] i.e [2, 3, 1, 2, 3] as 2 and 3 only have occurences greater than or equal to 2 ","int fun(vector < int > & a, int b) {
    int n = a.size();
    int ans = 0;
    int countOcc[1005] = {0};
    int occ = 0;
    int r = -1;
    for(int i = 0; i < n; i++) {
        while(r + 1 < n){
            if(countOcc[a[r + 1]] == 1 and occ == b)
                break;
            r++;
            countOcc[a[r]]++;
            if(countOcc[a[r]] == 2)
                occ++;
        } 
        ans += (r - i + 1);
        countOcc[a[i]]--;
        if(countOcc[a[i]] == 1)
            occ--;
    }
    return ans;
}
int Solution::solve(vector < int > & A, int B) {
    return fun(A, B) - fun(A, B - 1);
}"
Lexicographically largest Array,https://www.interviewbit.com/problems/lexicographically-largest-array/,N/A,Two Pointers,easy,"Problem Description
 
 

Given an integer array A consisting of distinct elements.

You are asked to create a lexicograhically largest array S = X + reverse(Y) ('+' denotes concatenation) such that it satisfies the following conditions:

len(S) <= len(A)
X is the prefix array of array A and Y is the suffix array of array A.
Note: Array X or Y can be empty.



Problem Constraints
1 <= len(A) <= 105

1 <= A[i] <= 109



Input Format
First and only argument is an integer array A.



Output Format
Return an integer array denoting the lexicographically largest array S.



Example Input
Input 1:

 A = [4, 1, 3, 2]
Input 2:

 A = [10, 20, 30, 40]


Example Output
Output 1:

 [4, 2, 3, 1]
Output 2:

 [40, 30, 20, 10]


Example Explanation
Explanation 1:

 X = [4], Y = [1, 3, 2]. Reverse(Y) = [2, 3, 1]
 S = X + Reverse(Y) = [4, 2, 3, 1]
Explanation 2:

 X = [], Y = [10, 20, 30, 40]. Reverse(Y) = [40, 30, 20, 10]
 S = [40, 30, 20, 10]","vector<int> Solution::solve(vector<int> &A) {
    int n = A.size();
    int l = 0;
    vector<int> ans;
    while(l < n){
        if(A[l] < A[n-1]){
            break;
        }
        else{
            ans.push_back(A[l]);
        }
        l++;
    }
    for(int i = n-1; i >= l; i--){
        ans.push_back(A[i]);
    }
    return ans;
}"
At most Two Occurrences!,https://www.interviewbit.com/problems/at-most-two-occurrences/,N/A,Two Pointers,easy,"Problem Description

You are given an integer array A containing N integers.

You can remove atmost one subarray from it such that the remaining elements must occur atmost two times.

Find the minimum size of the subarray you need to remove such that remaining elements must occur for atmost two times.



Problem Constraints
1 <= N <= 105

1 <= A[i] <= 109



Input Format
First and only argument is an integer array A.



Output Format
Return an integer denoting the minimum size of the subarray you need to remove such that remaining elements must occur for atmost two times.



Example Input
Input 1:

 A = [1, 1, 1, 2, 2, 2]
Input 2:

 A = [1, 1, 2, 2]


Example Output
Output 1:

 2
Output 2:

 0


Example Explanation
Explanation 1:

 If we remove the subarray A[2:3] then A = [1, 1, 2, 2] and as you can see count of 1 is atmost 2 and count of 2 is atmost 2
 so this will be our optimal answer so length of subrray which needs to be removed = 2
Explanation 2:

 Initially each elements occurs for atmost two times so we do not need to remove any subarray.
 Hence we will return 0
","int Solution::solve(vector<int> &A) {
    int occ = 0;
    int n = A.size();
    map<int, int> countOcc;
    for(int i : A){
        countOcc[i]++;
        if(countOcc[i] == 3)
            occ++;
    }
    if(occ == 0)
        return 0;
    int r = -1, ans = n;
    for(int i = 0; i < n; i++){
        while(r + 1 < n and occ){
            r++;
            countOcc[A[r]]--;
            if(countOcc[A[r]] == 2)
                occ--;
        }
        if(occ == 0)
            ans = min(ans, r - i + 1);
        countOcc[A[i]]++;
        if(countOcc[A[i]] == 3)
            occ++;
    }
    return ans;
}"
Consecutive Losses,https://www.interviewbit.com/problems/consecutive-losses/,N/A,Math,hard,"Problem Description

India and Pakistan are playing a bilateral series of A matches. Now, you know that India won exactly 
B matches. We know that there are ACB ways in which India could 
win B out of the A matches played. Here NCR is 
the number of ways to choose R objects out of N objects. 

Having known that we want to know the number of possible results in which the maximum consecutive number of matches lost 
by India is exactly K. 

We need to find that count for all K from 1 to A-B. 
Since the answer can be large, calculate it modulo 109 + 7.



Problem Constraints
1 <= B < A <= 5 x 105



Input Format
The two arguments are integers A and B, denoting the total number of matches played and matches won by India respectively.


Output Format
Return an array of length A - B, the ith element denotes the number of possible results 
in which maximum consecutive losses is exactly equal to i. 

Since the answer can be large, calculate it modulo 109 + 7.



Example Input

  Input 1:

  A : 5
  B : 2
Input 2:

  A : 4
  B : 1


Example Output

  Output 1:

  [1, 6, 3]
Output 2:

  [0, 2, 2]


Example Explanation

  Explanation 1:

  Let's denote a win by W and a defeat by L.
  So, possible number of ways in which India could win 2 out of 5 matches are-
  1.  WWLLL - Maximum 3 consecutive losses
  2.  WLWLL - Maximum 2 consecutive losses
  3.  WLLWL - Maximum 2 consecutive losses
  4.  WLLLW - Maximum 3 consecutive losses
  5.  LWWLL - Maximum 2 consecutive losses
  6.  LWLWL - Maximum 1 consecutive loss
  7.  LWLLW - Maximum 2 consecutive losses
  8.  LLWWL - Maximum 2 consecutive losses
  9.  LLWLW - Maximum 2 consecutive losses
  10. LLLWW - Maximum 3 consecutive losses


Explanation 2:

  Possible outcomes are- 
  1. WLLL - Maximum 3 consecutive losses
  2. LWLL - Maximum 2 consecutive losses
  3. LLWL - Maximum 2 consecutive losses
  4. LLLW - Maximum 3 consecutive losses","const int M=1e9+7;
int expo(int a,int b,int mod){
    int ans=1;
    while(b){
        if(b&1)
            ans=(ans*1LL*a)%mod;
        a=(a*1LL*a)%mod;
        b>>=1;
    }
    return ans;
}
const int N=500005;
int f[N],inv[N];
void preprocess()
{
    f[0]=1;
    for(int i=1;i<N;i++)
        f[i]=(i*1LL*f[i-1])%M;
    inv[N-1]=expo(f[N-1],M-2,M);
    for(int i=N-2;i>=0;i--)
        inv[i]=((i+1)*1LL*inv[i+1])%M;
}
int C(int n,int r){
	if(r>n)
		return 0;
    return (((f[n]*1LL*inv[r])%M)*1LL*inv[n-r])%M;
}
vector<int> Solution::solve(int A, int B) {
    preprocess();
    int n=A,k=B;
    int p=0;
    vector<int>res;
    for(int m = 1; m <= n-k; m++){
    	int cur=0;
    	for(int r = 0; r <= (n-k)/(m+1); r++){
    		int temp = (C(k+1,r) * 1LL * C(n-(m+1)*r,k))%M;
    		if(r&1){
    			cur-=temp;
    			if(cur<0)
    				cur+=M;
    		}
    		else{
    			cur+=temp;
    			if(cur>=M)
    				cur-=M;

    		}
    	}
    	res.push_back((cur-p+M)%M);
    	p=cur;
    }
    return res;
}"
Replace With Factors!,https://www.interviewbit.com/problems/replace-with-factors/,N/A,Linked Lists,easy,"Problem Description

Rishabh has given you a linked list in the form of its head node A. He has also given you an integer B.

You need to change the value of each node to its nearest multiple of B that is <= current value.



Problem Constraints
1 <= size of list <= 105

1 <= value of each node <= 105

1 <= B <= 105



Input Format
First argument is the head pointer of linked list A.

Second argument is the integer B.



Output Format
Return the head of the changed linked list.



Example Input
Input 1:

 A = 1 -> 2 -> 3
 B = 2
Input 2:

 A = 3 -> 4 -> 5
 B = 3


Example Output
Output 1:

 0 -> 2 -> 2
Output 2:

 3 -> 3 -> 3


Example Explanation
Explanation 1:

 All numbers have been replaced by nearest multiples of 2.
Explanation 2:

 All numbers have been replaced by nearest multiples of 3.
","/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
ListNode* Solution::solve(ListNode* A) {
}"
Count Good Subsequences,https://www.interviewbit.com/problems/count-good-subsequences/,N/A,Math,medium,"Problem Description

An array is good if all the elements present in it have the same frequency. For example, [2, 3, 3, 2] is good because both 2 and 3 have frequency 2. [2, 3, 2] is not good because the frequencies of 2 and 3 are 2 and 1 respectively. You are given an array A. You need to count the number of non-empty good subsequences of A. Since the answer can be large, return it modulo 109+7.



Problem Constraints
1 <= |A| <= 200000

1 <= A[i] <= 109



Input Format
First argument is an integer array A.



Output Format
Return the number of good subsequences modulo 109+7.



Example Input

  Input 1:

  A = [1, 2, 1] 

  Input 2:

  A = [5, 10, 2] 


Example Output

  Output 1:

  6

  Output 2:

  7


Example Explanation

  Explanation 1:

 
  Let's denote a subsequence by its set of indices and assume array to be 0 indexed. Then the following subsequences are good- 
  {0}, {1}, {2}, {0, 1}, {1, 2}, {0, 2}.

  Explanation 2:



  All the subsequences are good. So there are 23 - 1 = 7 subsequences.
","const int M = 1e9 + 7;
int expo(int a, int b, int mod){
    int ans = 1;
    while(b){
        if(b&1)
            ans = (ans * 1LL * a)%mod;
        a = (a * 1LL * a)%mod;
        b >>= 1;
    }
    return ans;
}
const int N=500005;
int f[N], inv[N];
void preprocess()
{
    f[0] = 1;
    for(int i = 1; i < N; i++)
        f[i] = (i* 1LL *f[i-1])%M;
    inv[N-1] = expo(f[N-1],M-2,M);
    for(int i = N-2; i >= 0; i--)
        inv[i] = ((i+1) * 1LL * inv[i+1])%M;
}
int C(int n,int r){
	if(r>n)
		return 0;
    return (((f[n] * 1LL * inv[r])%M) * 1LL * inv[n-r])%M;
}
int Solution::solve(vector<int> &A) {
    preprocess();
    map<int,int>m;
    for(auto i:A)
        m[i]++;
    vector<int>v;
    for(auto i:m)
        v.push_back(i.second);
    sort(v.begin(),v.end());
    int ans=0;
    for(int i=1;i<=v.back();i++){
        int res = 1;
        for(auto it=lower_bound(v.begin(),v.end(),i); it != v.end(); it++)
            res=(res * 1LL * (1+C(*it,i)))%M;
        ans=(ans+res-1)%M;
    }
    return ans;
}"
Prime calculations,https://www.interviewbit.com/problems/prime-calculations/,N/A,Stacks And Queues,medium,"Problem Description

Robin's mathematic's teacher gives him some homework:

Given an integer array A of size N. For each subarray of size B, find the leftmost number with the maximum number of distinct prime factors.

You are asked to return the sum of all such numbers. Since the answer may be large return answer % 109 + 7.



Problem Constraints
1 <= N <= 106

1 <= A[i] <= 106

1 <= B <= N



Input Format
First argument is an integer array A of size N.

Second argument is an integer B.



Output Format
Return an integer denoting the sum of numbers with the maximum number of distinct prime factors for each subarray of size B.



Example Input
Input 1:

 A = [10, 2, 1, 1, 2]
 B = 3
Input 2:

 A = [18, 36, 15, 210]
 B = 2


Example Output
Output 1:

 14
Output 2:

 264


Example Explanation
Explanation 1:

 Subarray of size 3 are:
 (10, 2, 1) -> 10 is the leftmost element which has maximum distinct prime factors, i.e 2.
 (2, 1, 1) -> 2 is the leftmost element which has maximum distinct prime factors, i.e 1.
 (1, 1, 2) -> 2 is the leftmost element which has maximum distinct prime factors, i.e 1.
 
Explanation 2:

 Total sum will be 264 i.e (18 + 36 + 210)
","const int maxN = 1000005;
const int mod = 1e9 + 7;

int tc = 0;
int primes[maxN];
int isPrime[maxN];

void sieve(){
    for(int i = 2; i*i < maxN; i++){
        if(isPrime[i] == 0){
            primes[i] = 1;
            for(int j = 2*i; j < maxN; j+=i){
                isPrime[j] = 1;
                primes[j]++;
            }
        }
    }
    for(int i = 3; i < maxN; i+=2){
        if(isPrime[i]==0)
            primes[i]=1;
    }
}

int Solution::solve(vector<int> &A, int B) {
    int n = A.size();
    if(tc == 0){
        sieve();
        tc = 1;
    }

    queue< pair<int, pair<int,int>>>q;
    for(int i = 0; i < B; i++)
    {
        if(q.empty())
        {
            q.push({primes[A[i]],{A[i],i}});
        }
        else
        {
            while(!q.empty() && primes[A[i]] > q.front)
                q.pop_back();
            q.push({primes[A[i]],{A[i],i}});
        }
    }
    long long sum = q.front().second.first;
    for(int i = B; i < n; i++)
    {
        while(!q.empty() && q.front().second.second <= i-B)
            q.pop_front();
        if(q.empty())
        {
            q.push_back({primes[A[i]],{A[i],i}});
        }
        else
        {
            while(!q.empty() && primes[A[i]] > q.back().first)
                q.pop_back();
            q.push_back({primes[A[i]],{A[i],i}});
        }
        sum += q.front().second.first;
        sum %= mod;
    }
    return sum;
}"
Bitwise AND Sum,https://www.interviewbit.com/problems/bitwise-and-sum/,N/A,Bit Manipulation,hard,"Problem Description

You are given an array A of length N. Consider that the array is one indexed.

You need to find sum of ( A[i] & A[j] & (A[i] + A[j]) )  for all pairs (i,j) such that 1 <= i < j <= N.



Problem Constraints
2 <= N <= 2 x 105

1 <= A[i] <= 109



Input Format
The only argument contains the integer array A.



Output Format
Return the sum of A[i] & A[j] & (A[i] + A[j]) for all pairs. Since the answer can be large, return it modulo 109 + 7.



Example Input
Input 1:

  A : [8, 9]
Input 2:

  A : [1, 3, 3]


Example Output
Output 1:

  0
Output 2:

  2


Example Explanation
Explanation 1:

  There is only one pair - (8 & 9 & (8 + 9)) = 0
Explanation 2:

  We have 3 pairs - 
 (1, 3) = 1 & 3 & (1+3) = 0
 (1, 3) = 1 & 3 & (1+3) = 0
 (3, 3) = 3 & 3 & (3+3) = 2
  
","const int mod = 1e9 + 7;
vector<int>v;
int f(int sum){
    int l = 0, r = int(v.size()) - 1; 
    int result = 0; 
    while (l < r) 
    { 
        if (v[l] + v[r] >= sum) { 
            result += (r - l); 
            if(result >= mod)
                result -= mod;
            r--; 
        }
        else
            l++; 
    } 
    return result; 
}
int Solution::solve(vector<int> &A) {
    int n = A.size();
    int ans = 0;
    for(int i = 0; i < 30; i++){
        v.clear();
        for(int j : A){
            if(j & (1 << i))
                v.push_back(j % (1 << i));
        }
        sort(v.begin(), v.end());
        ans=(ans + (1 << i)* 1ll *f(1 << i))%mod;
    }
    return ans;
}"
Make The Array Empty,https://www.interviewbit.com/problems/make-the-array-empty/,N/A,Backtracking,easy,"Problem Description

Given an integer array A, you have to perform certain operation any number of times on the array A.

In each operation you can remove any one of the three valid pairs:

Remove First, and the Last element of the array and cost of this operation will be LCM(firstElement, LastElement)
Remove First, and Middle element of the array and cost of this operation will be LCM(firstElement, middleElement)
Remove Middle, and the Last element of the array and cost of this operation will be LCM(middleElement, LastElement)
You have to find the maximum total cost it will take to make the array A empty.

NOTE:

In even-sized array, there are two middle elements, so always consider the second middle element as the middle element of the array.


Problem Constraints
1 <= |A| <= 20

Length of array A is always even.

1 <= A[i] <= 103



Input Format
First argument is an integer array A.



Output Format
Return a single integer denoting the maximum total cost it will take to make the array A empty.



Example Input
Input 1:

 A = [1, 2, 3, 4]
Input 2:

 A = [2, 4, 8 ,6]


Example Output
Output 1:

 14
Output 2:

 28


Example Explanation
Explanation 1:

 In first operation remove 3 and 4 from the array A which will cost = lcm(3, 4) = 12
 So now A = [1, 2]
 In second operation remove 1 and 2 from the array A which will cost = lcm(1, 2) = 2


Total Cost  = 2 + 12 = 14

Explanation 2:

 In first operation remove middle and the last element i.e 8 and 6 from the array A which will cost = lcm(8, 6) = 24
 In Second operation remove 2 and 4 which will cost us 4.


Total Cost = 4 + 24 = 28
","in lcm(int a, int b){
    return (a * b) / __gcd(a, b);
}
int ans;
void f(vector<int>& A, int cost){
    int n = A.size();
    if(n == 2){
        ans = max(ans, cost + lcm(A[0], A[1]));
        return;
    }
    //first and last
    int temp = lcm(A[0], A.back());
    A.erase(A.begin());
    A.pop_back();
}
int Solution::solve(vector<int> &A) {
    ans = 0;
    f(A, 0);
}"
Similar Pairs,https://www.interviewbit.com/problems/similar-pairs/,N/A,Hashing,medium,"Problem Description

Given an integer array A of size N, you need to find the count of pairs  (i, j) such that:

i < j
j - i <= B
A[i] == A[j]
Return the count of such pairs modulo 109 + 7.



Problem Constraints
2 <= |A| <= 105

1 <= A[i] <= 109

1 <= B <= 105



Input Format
First argument is an integer array A.

Second argument is an integer B.



Output Format
Return the count of such pairs that's satisfies all the properties mentioned above in the statement, modulo 109 + 7.



Example Input
Input 1:

 A = [1, 2, 1, 3, 1, 4]
 B = 2
Input 2:

 A = [12, 11, 8, 1]
 B = 14


Example Output
Output 1:

 2
Output 2:

 0


Example Explanation
Explanation 1:

 First pair is (0, 2) as A[0] = A[2] and (2 - 0) <= 2
 Second pair is (2, 4)
Explanation 2:

 No such pair possible as all elements are distinct.
","int Solution::solve(vector<int> &A, int B) {
    int n = A.size();
    map<int,vector<int>>m;
    int ans=0,mod=1e9+7;
    for(int i=0;i<n;i++){
        ans+=m[A[i]].end()-lower_bound(m[A[i]].begin(),m[A[i]].end(),i-B);
        ans%=mod;
        m[A[i]].push_back(i);
    }
    return ans;
}"
Super Array,https://www.interviewbit.com/problems/super-array/,N/A,Backtracking,medium,"Problem Description

Robin found an array A of size N which he wants to convert into super array.

To do this he decided to choose first or last element do one of the following operation with equal probability B times.

Delete the chosen element.
Increment the chosen element by one.
After performing all operations, if the array consist of atleast C elements greater than the special value of array then the array is called super array.

Special value is the bitwise XOR of all elements.

Find and return the total number of possible super array, he can get by performing the above operations.



Problem Constraints
1 <= N <= 10

1 <= A[i] <= 109

1 <= B, C <= N



Input Format
First argument is an integer array A of size N.

Second argument is an integer B.

Third argument is an integer C.



Output Format
Return an integer denoting the possible number of super array.



Example Input
Input 1:

 A = [10, 2, 10, 5]
 B = 3
 C = 3
Input 2:

 A = [3, 3, 4]
 B = 3
 C = 2


Example Output
Output 1:

 1
Output 2:

 3


Example Explanation
Explanation 1:

 Special value will be 7.
 There will be only one possible super array: [10, 2, 10, 8]. 
 Perform three operation by incrementing last element.
Explanation 2:

 There will be 3 possible super array.
","int ans = 0;
void recur(vector<int> &A, int B, int C, int val){
    if(B == 0){
        int cnt = 0;
        for(int i = 0; i < A.size(); i++){
            if(A[i] > val){
                cnt++;
            }
        }
        if(cnt >= C){
            ans++;
        }
        return;
    }
    int temp = A[0];
    // delete first element
    A.erase(A.begin());
    recur(A, B-1, C, val);
    A.insert(A.begin(), temp);

    // delete last element
    temp = A.back();
    A.pop_back();
    recur(A, B-1, C, val);
    A.push_back(temp);

    // Increment first element
    A[0]++;
    recur(A, B-1, C, val);
    A[0]--;

    // Increment last element
    A[A.size()-1] ++;
    recur(A, B-1, C, val);
    A[A.size()-1] --;
}


int Solution::solve(vector<int> &A, int B, int C) {
    int n = A.size();
    int val = 0;
    ans = 0;
    for(int i = 0; i < n; i++){
        val = val^A[i];
    }
    recur(A, B, C, val);
    return ans;
}"
Equal Array,https://www.interviewbit.com/problems/equal-array/,N/A,Hashing,easy,"Problem Description

Given an integer array A of size N, you are asked to make all the elements of the array equal by performing the following operation minimum number of times.

Choose any element and do the bitwise XOR with 2x, where x >= 0.
Return the minimum number of operations required.



Problem Constraints
1 <= N <= 105

0 <= A[i] <= 109



Input Format
First and only argument is an integer array A of size N.



Output Format
Return the minimum number of operations required.



Example Input
Input 1:

 A = [10, 1, 4, 2]
Input 2:

 A = [5, 7, 4, 3, 5]


Example Output
Output 1:

 5
Output 2:

 4


Example Explanation
Explanation 1:

 We will make all the values equal to 2 or 0 so that the operations required are minimum, i.e 5.
Explanation 2:

 We will make all the values equal to 5 so that the operations required are minimum, i.e 4.
","int Solution::solve(vector<int> &A) {
    int n = A.size();
    int arr[32] = {0};
    for(int i = 0; i < n; i++){
        for(int j = 0; j <= 30; j++){
            if(A[i] & (1 << j))
                arr[j]++;
        }
    }
    int ans = 0;
    for(int i = 0; i <= 30; i++){
        ans += min(arr[i], n - arr[i]);
    }
    return ans;
}"
Grid Paths,https://www.interviewbit.com/problems/grid-paths/,N/A,Backtracking,hard,"Problem Description

You are given a 2D grid A of size N x N. Rows are numbered from top to bottom from 0 to N - 1 and the columns are numbered from left to right from 0 to N - 1.

From a cell, you can either move left, right, up, and down. You cannot move outside of the grid. Some cells are blocked. A cell is blocked if A[i][j] is 0, otherwise A[i][j] denotes the value at ith row and jth column.

Consider every path from (0, 0) to (N-1, N-1) which visits each unblocked cell exactly once. The cost of a path is the sum of absolute values of adjacent cells of the path. Formally, if the values of the path are B1, B2, ...,, Br, the cost of the path is ? | Bi - Bi-1 | for i from 2 to r.

Find the sum of the cost of all such paths.

Note : Interpreter languages like Python may not work. Please try it in languages like C/ C++/ Java.



Problem Constraints
2 <= N <= 7

0 <= A[i][j] <= 100

0 < A[0][0], A[N-1][N-1] <= 100



Input Format
The first and only argument contains an 2D array A of size N x N.


Output Format
Return the sum of cost of all paths from (0, 0) to (N-1, N-1) which visits each unblocked cell exactly once.


Example Input

  Input 1:

  A : 
  [
    [5, 2]
    [0, 7]
  ]
Input 2:

  A : 
  [
    [79, 19, 59]
    [45, 89, 63]
    [79, 81, 37]
  ]


Example Output

  Output 1:

  8
Output 2:

  472


Example Explanation

  Explanation 1:

  Valid path is [5, 2, 7]. Cost is |5-2| + |7-2| = 8 
Explanation 2:

  There are two valid paths-
  1. [79, 19, 59, 63, 89, 45, 79, 81, 37]
  Cost = 254
  2. [79, 45, 79, 81, 89, 19, 59, 63, 37]
  Cost = 218","int n,vis[10][10],a[10][10],ans;
void f(int i, int j, int dir, int cnt, int sum){
    if(i==n-1 and j==n-1){
        if(cnt == n*n)
            ans+=sum;
        return;
    }
    
    if(dir==0){
        if((i-1<0 or vis[i-1][j]==1) and (j-1>=0 and !vis[i][j-1]) and (j+1<n and !vis[i][j+1])){
            return;
        }
    }
    else if(dir==1){
        if((j+1>=n or vis[i][j+1]==1) and (i-1>=0 and !vis[i-1][j]) and (i+1<n and !vis[i+1][j])){
            return;
        }
    }
    else if(dir==2){
        if((i+1>=n or vis[i+1][j]==1) and (j-1>=0 and !vis[i][j-1]) and (j+1<n and !vis[i][j+1])){
            return;
        }
    }
    else{
        if((j-1<0 or vis[i][j-1]==1) and (i-1>=0 and !vis[i-1][j]) and (i+1<n and !vis[i+1][j])){
            return;
        }
    }
    
    if(i-1>=0 and !vis[i-1][j]){
        vis[i-1][j] = 1;
        f(i-1, j, 0, cnt+1, sum + abs(a[i-1][j]-a[i][j]));
        vis[i-1][j] = 0;
    }
    if(j+1<n and !vis[i][j+1]){
        vis[i][j+1] = 1;
        f(i, j+1, 1, cnt+1, sum + abs(a[i][j+1]-a[i][j]));
        vis[i][j+1] = 0;
    }
    if(i+1<n and !vis[i+1][j]){
        vis[i+1][j] = 1;
        f(i+1, j, 2, cnt+1, sum + abs(a[i+1][j]-a[i][j]));
        vis[i+1][j] = 0;
    }
    if(j-1>=0 and !vis[i][j-1]){
        vis[i][j-1] = 1;
        f(i, j-1, 3, cnt+1,sum + abs(a[i][j-1]-a[i][j]));
        vis[i][j-1] = 0; 
    }
}
int Solution::solve(vector<vector<int> > &A) {
    n=A.size();
    int cnt=0;
    ans=0;
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            a[i][j] = A[i][j];
            if(a[i][j]) vis[i][j] = 0;
            else vis[i][j] = 1;
            cnt += vis[i][j];
            vis[i][j] *= 2;
        }
    }
    vis[0][0]=1;
    f(0,0,1,cnt+1,0);
    vis[0][0]=0;
    return ans;
}"
Scaler Subarrays II,https://www.interviewbit.com/problems/scaler-subarrays-ii/,N/A,Two Pointers,hard,"Problem Description

You are given an array A of size N.

A subarray A [ l ... r ] contains all the elements A[l], A[l+1], .... , A[r]. A subarray A [ l ... r ] is called a scaler subarray if max( A [ l ... r ] ) and A[l] + A[r] are congruent modulo B.

Here, max( A [ l ... r ] ) is the maximum value of this subarray.

Given an integer n > 1, called a modulus, two integers a and b are said to be congruent modulo n, if n is a divisor of their difference (i.e. if there is an integer k such that

a ? b = k n).

Find the total number of scaler subarrays of A. Since the answer can be large, return it modulo 109 + 7.



Problem Constraints
1 <= N, B <= 5 x 105

1 <= A[i] <= 109



Input Format
The first argument contains an integer array A of size N.

The second argument contains an integer B.



Output Format
Return the number of scaler subarrays of A modulo 109 + 7.



Example Input

  Input 1:

  A : [ 8, 7 ]
  B : 4
Input 2:

  A : [ 4, 5, 3, 8, 8 ]
  B : 5


Example Output

  Output 1:

  1
Output 2:

  3


Example Explanation

  Explanation 1:

  The subarray [8] is scaler because max([8]) = 8 and A[l] + A[r] = 16. 
  8 and 16 are congruent modulo 4 because 16 - 8 = 8 is divisible by 4.
Explanation 2:

  Scaler subarrays are [5], [5, 3, 8] and [5, 3, 8, 8].
","int n,a[500005],ab[500005],b,f[500005];
int scaler(int l,int r){
    if(l == r)
        return (ab[l] == 0);
    int mid = (l+r)>>1;
    int ans = scaler(l,mid) + scaler(mid+1,r);
    int mx = -1, idx, R = mid;
    for(int i = mid; i >= l; i--){
        if(a[i] > mx){
            mx = a[i];
            idx = i;
        }
        while(R+1 <= r and a[R+1] <= mx){
            R++;
            f[ab[R]]++;
        }
        int rem = ab[idx] - ab[i];
        if(rem < 0) rem += b;
        ans += f[rem];
    }
    for(int i = mid+1; i <= r; i++)
        f[ab[i]] = 0;
    mx = -1;
    int L = mid+1;
    for(int i = mid+1; i <= r; i++){
        if(a[i] > mx){
            mx = a[i];
            idx = i;
        }
        while(L-1 >= l and a[L-1] < mx){
            L--;
            f[ab[L]]++;
        }
        int rem = ab[idx] - ab[i];
        if(rem < 0) rem += b;
        ans += f[rem];
    }
    for(int i = l; i <= mid; i++)
        f[ab[i]] = 0;
    return ans;
}
int Solution::solve(vector<int> &A, int B) {
    n = A.size();
    assert(n>=1 && n<=500000);
    assert(B>=1 && B<=500000);
    for(int a:A)assert(a>=1 && a<=1000000000);
    for(int i = 0; i < n; i++)
        a[i] = A[i];
    b = B;
    for(int i = 0; i < n; i++)
        ab[i] = (a[i]%b);
    return scaler(0,n-1);
}"
Maximize the Matrix,https://www.interviewbit.com/problems/maximize-the-matrix/,N/A,Binary Search,medium,"Problem Description

Given a matrix A of size N x M. You want to maximize the minimum of the matrix A by performing the following operation B number of times.

Select any submatrix of size 1 x C and increase all elements by 2.
Return the minimum value of the matrix after performing the operation such that minimum of the matrix is maximized.



Problem Constraints
1 <= N x M <= 2 * 105

-108 <= A[i][j] <= 108

1 <= B <= 109

1 <= C <= M



Input Format
First argument is a 2D array A of size N x M.

Second argument is an integer B.

Third argument is an integer C.



Output Format
Return an integer denoting the minimum value of matrix after performing the operation.



Example Input
Input 1:

 A = [
       [2, -1, 5]
       [-2, 3, -2]
     ]
 B = 4
 C = 2
Input 2:

 A = [
       [2, 2]
       [2, 1]
       [1, 2]
     ]
 B = 1
 C = 1


Example Output
Output 1:

 0
Output 2:

 1


Example Explanation
Explanation 1:

 Select submatrix [-2, 3] and increase elements by 2 twice. Matrix will be after doing two operation:
 [
   [2, -1, 5]
   [2, 7, -2]
 ]
 Select submatrix [7, -2] and increase elements by 2. Matrix will be:
 [
   [2, -1, 5]
   [2, 9, 0]
 ]
 Select submatrix [2, -1] and increase elements by 2. Matrix will be:
 [
   [4, 1, 5]
   [2, 9, 0]
 ]
 All 4 operations are done, minimum element is 0.
Explanation 2:

 Minimum element will be 1.
","bool check(vector<vector<int>> &A, int val, int subsz, int op){
    int n = A.size(), m = A[0].size();
    for(int i = 0; i < n; i++){
        int less[m];
        memset(less, 0, sizeof(less));
        for(int j = 0; j < m; j++){
            if(A[i][j] < val){
                less[j] = (val - A[i][j] + 1)/2;
            }
        }
        int dif = 0;
        int temp[m];
        memset(temp, 0, sizeof(temp));
        for(int i = 0; i < m; i++){
            dif += temp[i];
            less[i] += dif;
            if(less[i] > 0){
                op -= less[i];
                if(i + subsz < m){
                    temp[i + subsz] = less[i];
                }
                dif -= less[i];
                if(op < 0){
                    return false;
                }
            }
        }
    }
    return true;
}

int Solution::solve(vector<vector<int> > &A, int B, int C) {
    int n = A.size(), m = A[0].size();
    int lo = 1e9;
    for(int i = 0; i < n; i++){
        for(int j = 0; j < m; j++){
            lo = min(lo, A[i][j]);
        }
    }
    int hi = lo + 2 * B;
    int ans = lo;
    while(lo <= hi){
        int mid = (hi+lo)/2;
        if(check(A, mid, C, B)){
            ans = mid;
            lo = mid + 1;
        }
        else{
            hi = mid - 1;
        }
    }
    return ans;
}"
Request X Chocolates,http://interviewbit.com/problems/request-x-chocolates/,N/A,Binary Search,easy,"Problem Description

There are some children, each child having a unique id requesting different quantity of chocolate in the given order denoted by 2D matrix A of size N x 2 where A[i][0] denotes chidren id and A[i][1] denotes quantity.

A child can request any quantity of chocolate multiple times. The person distributing the chocolate has only B chocolates.

You are asked to find the maximum value of X such that each children can request a total sum of at most X chocolates and total chocolates requested by all children is not more than B.

NOTE:

The request made either be served fully or not. It can't be fulfilled partially.
For each child, request are served sequentially, i.e any child can't make a new request before completing the previous request.
For each child, the total sum of chocolate he/she recieved should not be greater than X.


Problem Constraints
1 <= N <= 105

1 <= A[i][0], A[i][1], B <= 109

B < Sum of all requested quantity



Input Format
First argument is a 2d array A of size N x 2 denoting that A[i][0] child is requesting A[i][1] quantity of chocolate.

Second argument is an integer B denoting the total quantity of chocolates.



Output Format
Return an integer denoting the maximum value of X.



Example Input
Input 1:

 A = [
       [1, 2]
       [2, 1]
       [1, 4]
       [2, 9]
       [1, 1]
       [3, 2]
     ]
 B = 6
Input 2:

 A = [
       [10, 2]
       [10, 5]
       [4, 4]
       [4, 1]
     ]
 B = 1


Example Output
Output 1:

 5
Output 2:

 1


Example Explanation
Explanation 1:

 Each children can get at most 5 chocolates such that the total sum of chocolates recieved is less than 6.
 Child with id 1: will get 2 chocolates in first request. Any other request will not be fulfilled.
 Child with id 2: will get 1 chocolate in first request. Any other request will not be fulfilled.
 Child with id 3: will get 2 choclates in first request.
 Total chocolate = 5 which is less than 6.
 NOTE: We can't increase the value of X to 6. Second request of child 1 will get fulfilled at total chocolates will be greater than 6.
 
Explanation 2:

 The maximum value of X is 1.","map<int, vector<int>>m;
bool check(int x, int b){
    int tot = 0;
    for(auto i:m){
        int cur = 0;
        for(auto j:i.second){
            if(cur + j > x)
                break;
            cur += j;
        }
        tot += cur;
    }
    return tot <= b;
}
int Solution::solve(vector<vector<int> > &A, int B) {
    m.clear();
    for(auto i:A)
        m[i[0]].push_back(i[1]);
    int l = 0, h = 1000000000, ans;
    while(h >= l){
        int mid = (l+h)/2;
        if(check(mid, B)){
            ans = mid;
            l = mid + 1;
        }
        else
            h = mid - 1;
    }
    return ans;
}"
Text Editor,https://www.interviewbit.com/problems/text-editor/,N/A,Strings,hard,"Problem Description

Michael is working on a very basic text editor. Initially, nothing is written on the editor. Also, the editor stores a buffer which is initially empty. In one operation, Michael can do one of the following operations-

1. Append any lowercase English character to the current string on the editor. After this operation, the buffer becomes empty (if anything was stored in the buffer previously).

2. Copy the current string on the editor to the buffer. Note that the complete string gets copied. You can't copy strings partially. Any previously stored string in the buffer is replaced.

3. Append the string in the buffer to the current string. Note that after this operation, the buffer is still intact.

You are given a string A. Help Michael find the minimum number of operations required to write the string A on the editor.



Problem Constraints
1 <= |A| <= 5 x 105



Input Format
The first and only argument contains the string A.


Output Format
Return an integer, the minimum number of operations required to write the string A on the text editor.


Example Input

  Input 1:

  A : ""abababababab""
Input 2:
  A : ""aaaabaaaab""


Example Output

  Output 1:

  7
Output 2:
  7


Example Explanation

  Explanation 1:

  One of the ways to write this string in 7 operations is-
  1. Append 'a' to the editor. Current string = ""a"", Current Buffer = """" 
  2. Append 'b' to the editor. Current string = ""ab"", Current Buffer = """"
  3. Copy the string to buffer. Current string = ""ab"", Current Buffer = ""ab""
  4. Append the string in buffer to current string. Current string = ""abab"", Current Buffer = ""ab""
  5. Append the string in buffer to current string. Current string = ""ababab"", Current Buffer = ""ab""
  6. Copy the string to buffer. Current string = ""ababab"", Current Buffer = ""ababab""
  7. Append the string in buffer to current string. Current string = ""abababababab"", Current Buffer = ""ababab""
Explanation 2:
  One of the ways to write this string in 7 operations is-
  1. Append 'a' to the editor. Current string = ""a"", Current Buffer = """" 
  2. Append 'a' to the editor. Current string = ""aa"", Current Buffer = """" 
  3. Copy the string to buffer. Current string = ""aa"", Current Buffer = ""aa""
  4. Append the string in buffer to current string. Current string = ""aaaa"", Current Buffer = ""aa""
  5. Append 'b' to the editor. Current string = ""aaaab"", Current Buffer = """" 
  6. Copy the string to buffer. Current string = ""aaaab"", Current Buffer = ""aaaab""
  7. Append the string in buffer to current string. Current string = ""aaaabaaaab"", Current Buffer = ""aaaab""
","const int N = 500005;
vector<int>f[N];
int ans[N];
void sieve(){
    if(f[1].size())
        return;
    for(int i = 1; i < N; i++){
        for(int j = i; j < N; j += i)
            f[j].push_back(i);
    }
}
vector<int> prefix_function(string s) {
    int n = (int)s.length();
    vector<int> pi(n);
    for (int i = 1; i < n; i++) {
        int j = pi[i-1];
        while (j > 0 && s[i] != s[j])
            j = pi[j-1];
        if (s[i] == s[j])
            j++;
        pi[i] = j;
    }
    return pi;
}
int Solution::solve(string A) {
    sieve();
    string s = A;
    assert(s.size()>=1 && s.size()<=500000);
    for(char a:A)assert(a>='a' && a<='z');
    vector<int> pi = prefix_function(s);
    ans[0] = 1;
    for(int i = 1; i < s.size(); i++){
        ans[i] = 1 + ans[i-1];
        int k = i+1 - pi[i];
        if((i+1) % k)
            k = i+1;
        int c = (i+1)/k;
        for(auto j : f[c]){
            if(j == c) break;
            ans[i] = min(ans[i], ans[k*j-1] + c/j);
        }
    }
    return ans[s.size()-1];
}"
Counting Special Numbers!,https://www.interviewbit.com/problems/counting-special-numbers/,N/A,Dynamic Programming,medium,"Problem Description

Rishabh recently joined a new company and on his very first day his boss gave him a problem to solve.

So, Rishabh don't want to underperform so he asks for you help.

The problem is that you are given with two integers A and B and you have to tell the count of special numbers in range A, B.

A number is called special if the sum of pairwise product of its digits is prime. For example: suppose abc is a number then its sum of pairwise product of its digits will be (ab + ac + bc).



Problem Constraints
1 <= A <= B <= 109



Input Format
First argument is an integer A.

Second argument is an integer B.



Output Format
Return a single integer denoting the count of special numbers in range [A, B].



Example Input
Input 1:

 A = 1
 B = 20
Input 2:

 A = 100
 B = 105


Example Output
Output 1:

 4
Output 2:

 3


Example Explanation*
Explanation 1:

 Special numbers are: 12, 13, 15, 17
Explanation 2:

 Special numbers are: 102 103 105
","vector < int > v;
int dp[10][100][815][2];
bool isPrime(int n) {
  if (n <= 1) return false;
  if (n <= 3) return true;
  if (n % 2 == 0 || n % 3 == 0) return false;
  int p = sqrt(n);
  for (int i = 5; i <= p; i = i + 6)
    if (n % i == 0 || n % (i + 2) == 0)
      return false;
  return true;
}
int memo(int index, int sum, int sumsq, int tight) {
  if (index == v.size()) {
    int pairWiseSum = ((sum * sum) - sumsq) / 2;
    if (isPrime(pairWiseSum) == true)
      return 1;
    return 0;
  }
  int ans = 0;
  if (dp[index][sum][sumsq][tight] != -1) return dp[index][sum][sumsq][tight];
  int limit = (tight) ? v[index] : 9;
  for (int d = 0; d <= limit; d++) {
    int currTight = 0;
    if (d == v[index]) currTight = tight;
    ans += memo(index + 1, sum + d, sumsq + (d * d), currTight);
  }
  return dp[index][sum][sumsq][tight] = ans;
}
int solve(int n) {
  v.clear();
  memset(dp, -1, sizeof(dp));
  while (n) {
    v.push_back(n % 10);
    n = n / 10;
  }
  reverse(v.begin(), v.end());
  return memo(0, 0, 0, 1);
}
int Solution::countingSpecialNumbers(int A, int B) {
  return solve(B) - solve(A - 1);
}"
Anagram Match,https://www.interviewbit.com/problems/anagram-match/,N/A,Hashing,hard,"Problem Description

You are given a string A. You need to solve Q queries. In each query, you will be given a string B[i]. You need to find the count of the number of substrings of A which are anagrams of B[i]. 

String x is an anagram of string y, if we can rearrange the letters in string x and get the exact string y. For example, strings ""dog"" and ""god"" are anagrams, so are strings ""baba"" and ""aabb"", but strings ""abbac""  ""caaba"" are not.

A substring of a string is a contiguous subsequence of that string. So, string ""view"" is substring of string ""interviewbit"", but string ""viewer"" is not.



Problem Constraints
1 <= |A|, |B[i]| <= 2 x 105

1 <= Q <= 105

? |B[i]| <= 2 x 105

All the strings consist of lowercase english letters.



Input Format
The first argument contains a string A.

The second argument contains an array of strings B.



Output Format
Return an array of size Q, i-th integer is the number of substrings of A which are anagrams of B[i].



Example Input

  Input 1:

  A : ""jdlidfa""
  B : [ ""daf"", ""ifd"", ""dxzjbltsmufythgm"" ]
Input 2:
  A : ""lrprpqejhh""
  B : [ ""p"", ""pjeplqrr""] 


Example Output

  Output 1:

  [1, 1, 0]
Output 2:
  [2, 1]


Example Explanation

  Explanation 1:

  1. Substring  ""dfa"" is an anagram of ""daf"".
  2. Substring ""idf"" is an anagram of ""ifd""
  3. No anagram exists as a substring.
Explanation 2:
  1. Substring ""p"" occurs twice in A.
  2. Substring ""lrprpqej"" is an anagram of ""pjeplqrr"".
","int p[26] = {130651,169627,95789,197101,104803,176509,113909,172597,6221,86269,188999,166867,4271,177787,172709,79151,155153,40897,156781,26459,176087,86243,164309,40597,181397,39791};
string s, t[100005];
int q, ans[100005];
long long hashh[200005];
vector<int> Solution::solve(string A, vector<string> &B) {
    s = A;
    q = B.size();
    for(int i = 0; i < s.size(); i++)
        hashh[i] = (i ? hashh[i-1] : 0) + p[s[i]-'a'];
    unordered_map<int, vector< pair < long long, int >>> hashh_m;
    for(int i = 0; i < q; i++){
        t[i] = B[i];
        long long hashh_t = 0;
        for(char j:t[i])
            hashh_t += p[j-'a'];
        hashh_m[t[i].size()].push_back({hashh_t, i});
    }
    for(auto i:hashh_m){
        vector<pair <long long, int >> hashh_l = i.second;
        unordered_map<long long, int> count_m;
        for(auto j:hashh_l)
            count_m[j.first] = 0;
        int l = i.first;
        for(int j = 0; j < int(s.size())-l+1; j++){
            long long hashh_s = hashh[j+l-1] - (j ? hashh[j-1] : 0);
            if(count_m.count(hashh_s))
                count_m[hashh_s]++;
        }
        for(auto j:hashh_l)
            ans[j.second] = count_m[j.first];
    }
    vector<int>res;
    for(int i = 0; i < q; i++)
        res.push_back(ans[i]);
    return res;
}"
Expected number of Segments,https://www.interviewbit.com/problems/expected-number-of-segments/,N/A,Math,easy,"Problem Description

Find the expected value of the number of segments in a string of length A in a language having alphabet size B.

A segment in defined as maximum contiguous substring containing the same character. E.g. In string 10011, the segments are 1, 00 and 11. The number of segments will be 3.



Problem Constraints
1 <= A,B <= 109



Input Format
The first argument contains an integer A, denoting the length of the string.

The second argument contains an integer B, denoting the alphabet size.



Output Format
Return the expected value of the number of segments. This can be represented in the form of x/y. Return  x.y-1 (mod 109 + 7 ).



Example Input

  Input 1:

 A = 1
 B = 2
Input 2:

  A = 2
  B = 2


Example Output

  Output 1:

  1
Output 2:

  500000005


Example Explanation

  Explanation 1:

  The length is 1. So there will only be 1 segment. 
Explanation 2:

  There are 4 cases-


00-1 segment
  01-2 segments
  10-2 segments
  11-1 segment



Hence, the expected number of segments is 6/4. 

","#define ll long long
ll expo(ll a,ll b,ll mod)
{
    ll ans=1;
    while(b)
    {
        if(b&1)
            ans=(ans*a)%mod;
        a=(a*a)%mod;
        b>>=1;
    }
    return ans;
}
ll M=1e9+7;
int Solution::solve(int n, int a) {
    ll num=(a+(n-1)*1LL*(a-1))%M;
    num=(num*expo(a,M-2,M))%M;
    return num;
}"
Valid Parentheses Again,https://www.interviewbit.com/problems/valid-parentheses-again/,N/A,Dynamic Programming,hard,"Problem Description

Robin bought a sequence consist of characters '(', ')', '{', '}', '[', ']'.

A sequence is valid if it follows any one of the following rule:

An empty sequnce is valid.
If X is valid sequence, then '(' + X + ')' or '{' + X + '}' or '[' + X + ']' is also valid.
If X and Y are valid, then X + Y is also valid.
His brother played with the sequence and misplaced some of the characters, those misplaced characters are denoted by '?' in string A.

Inorder to make the sequence valid again, he decided to replace the character '?'.

Your task is to determing the number of valid sequences that can be created by replacing '?'. Since the answer could be large output answer % 109 + 7.



Problem Constraints
2 <= |A| <= 150

Length of string A is always even.



Input Format
First and only argument is a string A.



Output Format
Return an integer denoting the number of valid sequences.



Example Input
Input 1:

 A = ""??}(??""
Input 2:

 A = ""]???""


Example Output
Output 1:

 3
Output 2:

 0


Example Explanation
Explanation 1:

Explanation 2:
","const int mod = 1e9 + 7;
long long dp[155][155];

#define int long long
char rev(char ch){
    if(ch == '(')return ')';
    if(ch == '[')return ']';
    if(ch == '{')return '}';
    return '-';
}

long long go(string &v, int i, int j) {
    if (i > j)return 1;
    if (i == j)return 0;

    long long &ans = dp[i][j];
    if (ans != -1)return ans;
    ans = 0;

    if (v[i] != '(' and v[i] != '[' and v[i] != '{' and v[i] != '?')return 0;
    for (int id = i + 1; id <= j; id++) {
        if (v[i] == '?') {
            if (v[id] == '?')
                ans += 3 * 1ll * go(v, i + 1, id - 1) * go(v, id + 1, j);
            else if (v[id] == ')' or v[id] == ']' or v[id] == '}')
                ans += go(v, i + 1, id - 1) * go(v, id + 1, j);
        } else 
            if (v[id] == '?' or v[id] == rev(v[i]))
                ans += go(v, i + 1, id - 1) * go(v, id + 1, j);
        ans %= mod;
    }
    return ans;
}
#undef int

int Solution::solve(string A) {
    int n = A.size();
    memset(dp, -1, sizeof(dp));
    return go(A, 0, n-1);
}"
Range of the Array,https://www.interviewbit.com/problems/range-of-the-array/,N/A,Heaps And Maps,medium,"Problem Description

You are given an array A of size N. In one operation, you can select any number from the array and reduce it to a divisor greater than 1. For example, you can reduce 12 to 2, 3 or 6. 

The range of an array is the difference between the maximum element of the array and the minimum element. You want to find the minimum range of the array by doing any number of operations on the array. You can do multiple operations on a single element as well.



Problem Constraints
2 <= N, A[i] <= 105



Input Format
The only argument contains an integer array A of size N


Output Format
Return the minimum range of the array A.


Example Input

  Input 1:

  A : [2, 4, 8]
Input 2:

   A : [3, 8, 9]


Example Output

  Output 1:

  0
Output 2:

  1


Example Explanation

  Explanation 1:

  The final array will be [2, 2, 2]
Explanation 2:

  he final array will be [3, 2, 3]","const int N = 100005;
vector<int> fact[N];
int n, a[N], p[N];
void sieve(){
    if(fact[2].size())
        return;
    for(int i = 2; i < N; i++){
        for(int j = i; j < N; j += i)
            fact[j].push_back(i);
    }
}
int Solution::solve(vector<int> &A) {
    sieve();
    n = A.size();
    set<int> s;
    for(int i = 0; i < n; i++){
        a[i] = A[i];
        s.insert(a[i]);
    }
    n = 0;
    for(auto i : s)
        a[n++] = i;
    priority_queue< pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> >pq;
    int mx = 0;
    for(int i = 0; i < n; i++){
        p[i] = 0;
        pq.push({fact[a[i]][0], i});
        mx = max(mx, fact[a[i]][0]);
    }
    int ans = mx - pq.top().first, idx;
    while(!pq.empty()){
        int idx = pq.top().second;
        pq.pop();
        if(p[idx] + 1 == fact[a[idx]].size())
            break;
        p[idx]++;
        pq.push({fact[a[idx]][p[idx]], idx});
        mx = max(mx, fact[a[idx]][p[idx]]);
        ans = min(ans, mx - pq.top().first);
    }
    return ans;
}"
Range Shopping,https://www.interviewbit.com/problems/range-shopping/,N/A,Tree Data Structure,hard,"Problem Description

Hamid is visiting a fair near his village. There are N shops of toys arranged in a line from left to right numbered 1 to N. There are two types of toys in each shop. The toy of type 1 costs A[i][0] coins and the toy of type 2 costs A[i][1] coins.

Now, he asks you to solve Q queries for him. Each query will be of type-

l r x y - He visits each shop from l to r in this order and he will buy exactly one toy from each of the visited shops. But, he wants to buy at least x toys of type 1 and at least y toys of type 2. Help him find the minimum cost for buying the toys. Since the answer can be large, return it modulo 109 + 7.



Problem Constraints
1 <= N, Q <= 105

1 <= l <= r <= N

0 <= x + y <= r-l+1

1 <= A[i][0], A[i][1] <= 109



Input Format
The first argument contains a 2D array A of size N x 2, denoting the prices of toys.

The second argument contains a 2D array B of size Q x 4, denoting the queires.



Output Format
Return an array of size Q denoting the answers to the queries. 



Example Input

  Input 1:

  A : 
  [
    [1, 2]
    [4, 2]
    [3, 2]
    [4, 3]
  ]
  B : 
  [
    [2, 3, 1, 1]
    [1, 4, 2, 1]
  ]
Input 2:
  A : 
  [
    [2, 3]
    [4, 5]
    [2, 1]
  ]
  B : 
  [
    [2, 3, 0, 1]
  ]


Example Output

  Output 1:

  [5, 9]
Output 2:
  [5]


Example Explanation

  Explanation 1:

  1. You can buy toy of type 2 in shop 2 with cost 2 and toy of type 1 in shop 3 with cost 3. 
  2. You can buy toy of type 1 in shop 1 with cost 1, toy of type 2 in shop 2 with cost 3, 
     toy of type 1 in shop 3 with cost 3 and toy of type 2 in shop 4 with cost 3. 
     So, you bought 2 toys of type 1 and 2 toys of type 2.
Explanation 2:
  Buy toy of type 1 in shop 2 and toy of type 2 in shop 3.
","const int N = 100005, mod = 1e9 + 7;
vector<int> seg[4*N], sm[4*N];
int n, q, a[N], b[N], sa[N], neg[N];
void build(int node, int l, int r, vector< pair<int, int> > &v)
{
    if (l == r) {
        seg[node].push_back(v[l].second);
        sm[node].push_back((v[l].first+mod) % mod);
        return;
    }
    int mid = (l + r) / 2;
    build(2 * node, l, mid, v);
    build(2 * node + 1, mid + 1, r, v);
    merge(seg[2 * node].begin(), seg[2 * node].end(), seg[2 * node + 1].begin(), seg[2 * node + 1].end(), back_inserter(seg[node]));
    for(int i : seg[node]){
        sm[node].push_back((sm[node].size() ? sm[node].back() : 0) + b[i] - a[i]);
        sm[node].back() = (sm[node].back() % mod + mod) % mod;
    }
}
int query(int node, int l, int r, int x, int y, int k)
{
    if (l == r)
        return sm[node][0]*k;
    int mid = (l + r) / 2;
    int last = (upper_bound(seg[2 * node].begin(), seg[2 * node].end(), y) - seg[2 * node].begin());
    int first = (lower_bound(seg[2 * node].begin(), seg[2 * node].end(), x) - seg[2 * node].begin());
    int M = last - first;
    if (M >= k) 
        return query(2 * node, l, mid, x, y, k);
    else 
        return ((( ( last ? sm[2 * node][last - 1] : 0 ) - ( first ? sm[2 * node][first - 1] : 0 ) ) % mod + query(2 * node + 1, mid + 1, r, x, y, k - M) ) % mod + mod)%mod;
}
vector<int> Solution::solve(vector<vector<int> > &A, vector<vector<int> > &B) {
    n = A.size();
    for(int i = 0; i < 4*n; i++){
        seg[i].clear();
        sm[i].clear();
    }
    vector< pair<int, int> > v;
    for(int i = 0; i < n; i++){
        a[i] = A[i][0], b[i] = A[i][1];
        sa[i] = ((i ? sa[i-1] : 0) + a[i])%mod;
        neg[i] = (i ? neg[i-1] : 0) + int(b[i] < a[i]);
        v.push_back({b[i] - a[i], i});
    }
    sort(v.begin(), v.end());
    build(1, 0, n-1, v);
    q = B.size();
    vector<int>res;
    for(int i = 0; i < q; i++){
        int l = B[i][0], r = B[i][1], x1 = B[i][2], x2 = B[i][3];
        l--, r--;
        int ans = (sa[r] - (l ? sa[l-1] : 0) + mod ) % mod, good = neg[r] - (l ? neg[l-1] : 0);
        ans = (ans + query(1, 0, n-1, l, r, min( max(good, x2), r - l + 1 - x1 )))%mod;
        res.push_back(ans);
    }
    return res;
}"
Check Palindrome,https://www.interviewbit.com/problems/check-palindrome/,N/A,Strings,easy,"Problem Description
 
 

Given a string A consisting of lowercase characters.

Check if characters of the given string can be rearranged to form a palindrome.

Return 1 if it is possible to rearrange the characters of the string A such that it becomes a palindrome else return 0.



Problem Constraints
1 <= |A| <= 105

A consists only of lower-case characters.



Input Format
First argument is an string A.



Output Format
Return 1 if it is possible to rearrange the characters of the string A such that it becomes a palindrome else return 0.



Example Input
Input 1:

 A = ""abcde""
Input 2:

 A = ""abbaee""


Example Output
Output 1:

 0
Output 2:

 1


Example Explanation
Explanation 1:

 No possible rearrangement to make the string palindrome.
Explanation 2:

 Given string ""abbaee"" can be rearranged to ""aebbea"" to form a palindrome.
","int Solution::solve(string A) {
  int hashMap[26] = {0};
  for (char a: A)
    hashMap[a - 'a']++;
  int odd = 0;
  for (int a: hashMap)
    if (a % 2)
      odd++;
  if (odd > 1)
    return 0;
  return 1;
}"
Clear the Array,https://www.interviewbit.com/problems/clear-the-array/,N/A,Hashing,easy,"Problem Description

You are given an array A of size N. In one operation, you can select a subsequence of A such that no two elements are the same in the selected subsequence and delete the selected elements from the array A. 

Find the minimum number of operations required to delete all the elements.



Problem Constraints
1 <= N <= 105

1 <= A[i] <= 109



Input Format
The first and only argument contains an array A of size N.


Output Format
Return the minimum number of operations to make the array empty.


Example Input

  Input 1:

  A : [ 3, 1, 3 ]
Input 2:
  A : [1, 1]


Example Output

  Output 1:

  2
Output 2:
  2


Example Explanation

  Explanation 1:

  First, we can select [3, 1] and delete them. The array becomes [3]. 
  We can do one more operation to delete it. 
Explanation 2:
  We can do 2 operations to delete both the elements.
","int Solution::solve(vector<int> &A) {
    map<int, int> f;
    int ans = 0;
    for(int a: A){
        f[a]++;
        ans = max(ans, f[a]);
    }  
    return ans; 
}"
Coin Queue,https://www.interviewbit.com/problems/coin-queue/,N/A,Stacks And Queues,hard,"Problem Description

You need to maintain a queue that is initially empty. You will perform three types of operations on the queue -

1 X - Add the number x to the queue.

2 0 - Remove the least recently added number from the queue.

3 X - Consider the current numbers in the queue. Find the maximum size of a subset of numbers in the queue whose sum is X. If there is no such subset, return -1.

A subset is defined as a sequence that can be obtained by removing some (possibly all) elements present in the queue.



Problem Constraints
1 <= X <= 350

|A| <= 105



Input Format
The only argument contains a 2D array A, denoting the operations on the queue.


Output Format
Return an array containing the answers to each query of type 3.


Example Input

  Input 1:

  A : 
  [
    [1, 3]
    [1, 1]
    [1, 1]
    [2, 0]
    [3, 2]
  ]
Input 2:

  A : 
  [
    [1, 1]
    [1, 2]
    [1, 2]
    [1, 3]
    [3, 4]
    [3, 5]
  ]


Example Output

  Output 1:

  [2]
Output 2:

  [2, 3]


Example Explanation

  Explanation 1:

  After first 3 operations, queue becomes {3, 1, 1}.
  Then we pop the number 3. The queue is {1, 1}.
  Then we can form 2 by taking both the ones. So, we have a subset of 2 numbers.
Explanation 2:

  After first 3 operations, queue becomes {1, 2, 2, 3}.
  Then 4 can be formed by 2 + 2 and 1 + 3. Max 2 numbers are in a subset.
  5 can be formed by 1 + 2 + 2, 2 + 3 and 2 + 3. Max 3 numbers are in a subset.
","stack< pair< int, vector<int> > > s[2];
void clear(int idx){
    while(s[idx].size())
        s[idx].pop();
}
void push(int idx, int x){
    if(s[idx].size() == 0){
        vector<int> v(351, -1);
        v[0] = 0;
        v[x] = 1;
        s[idx].push({x, v});
        return;
    }
    vector<int> v = s[idx].top().second;
    for(int i = 350; i >= x; i--){
        if(v[i-x] != -1)
            v[i] = max(v[i], 1 + v[i-x]); 
    }
    s[idx].push({x, v});
}
vector<int> Solution::solve(vector<vector<int> > &A) {
    clear(0);
    clear(1);
    int q, type, x;
    q = A.size();
    vector<int> res;
    for(int i = 0; i < q; i++){
        type = A[i][0], x =A[i][1];
        if(type == 1)
            push(0, x);
        else if(type == 2){
            if(s[1].size())
                s[1].pop();
            else{
                while(s[0].size() > 1){
                    push(1, s[0].top().first);
                    s[0].pop();
                }
                s[0].pop();
            }
        }
        else{
            if(s[0].size() == 0 and s[1].size() == 0)
                res.push_back(-1);
            else if(s[0].size() == 0)
                res.push_back(s[1].top().second[x]);
            else if(s[1].size() == 0)
                res.push_back(s[0].top().second[x]);
            else{
                int ans = -1;
                for(int i = 0; i <= x; i++){
                    if(s[0].top().second[i] != -1 and s[1].top().second[x - i] != -1)
                        ans = max(ans, s[0].top().second[i] + s[1].top().second[x - i]);
                }
                res.push_back(ans);
            }
        }
    }
    return res;
}"
Prefix with key greater than X,https://www.interviewbit.com/problems/prefix-with-key-greater-than-x/,N/A,Tree Data Structure,hard,"Problem Description

Design a data structure to efficiently handle Q queries.
1 S K: Insert a string S with key K.

2 S K: find the count of strings having S as prefix and key greater than or equal to K.



Problem Constraints
1 <= Q <= 5e4
1 <= K <= 1e9
sum of S over all query <= 2e5
S consists of lower case english alphabets only


Input Format
First argument is an integer array A of size Q denoting type of query.
Second argument is a string array B of size Q denoting string S for each query.
Third argument is an integer array C of size Q denoting key K for each query.


Output Format
Return an integer array containing all the answer to query 2 in the same order they were asked.


Example Input
Input 1:
    A = [1, 1, 2, 1, 2]
    B = [""abc"", ""bac"", ""ab"", ""abc"", ""ab""]
    C = [5, 1, 4, 4, 4] 
Input 2:

    A = [2]
    B = [a]
    C = [6]


Example Output
Output 1:
    [1, 2]

Output 2:

    [0]


Example Explanation
Explanation 1:
    - Insert [""abc"", 5]
    - Insert [""bac"", 1]
    - string with Key greater than equal 4 having ""ab"" as prefix is [""abc"", 5]; hence answer is 1.
    - Insert [""abc"", 4]
    - string with Key greater than equal 4 having ""ab"" as prefix are [""abc"", 5], [""abc"", 4]; hence answer is 2
Explanation 2:

    There is no string in data structure so answer is 0.
","class trie
{
public:
    trie *child[26];
    int cnt;
    trie()
    {
       for(int i=0;i<26;i++)
       {
           child[i]=NULL;
       }
       cnt=0;
    }
    ~trie()
    {
        for(int i=0; i<26; i++)
        {
            delete child[i];
        }
    }
    void insert(string s)
    {
        trie *temp = this;
        cnt++;
        for(int i=0; i<s.length(); i++)
        {
            if(temp->child[(s[i] - 'a')] == NULL)
                temp->child[(s[i] - 'a')] = new trie;
            temp = temp->child[(s[i] - 'a')];
            temp->cnt++;
        }
    }
    int find(string s)
    {
        trie *temp = this;
        for(int i=0; i<s.length(); i++)
        {
            if(temp->child[(s[i]-'a')] == NULL)
                return 0;
            temp = temp->child[(s[i]-'a')];
        }
        return temp->cnt;
    }
};
set<int> Keys;
vector<int> keys;
trie *mstree[400000];
void insert(int node, int l, int r, vector<string> &B, int x, int k)
{
    mstree[node]->insert(B[x]);
    if(l==r)
    {
        return;
    }
    int m = (l+r)/2;
    if(keys[m]>=k)
    {
        insert(2*node, l, m, B, x, k);
        return;
    }
    insert(2*node +1, m +1, r, B, x, k);
}

int query(int node, int l, int r, vector<string> &B, int x, int k)
{
    int ans=0;
    if(l==r)
    {
        if(keys[l] >= k)
            ans += mstree[node]->find(B[x]);
        return ans;
    }
    int m = (l+r)/2;
    if(keys[m] >= k)
    {
        ans += mstree[2*node +1]->find(B[x]);
        ans += query(2*node, l, m, B, x, k);
        return ans;
    }
    ans+=query(2*node +1, m +1, r, B, x, k);
    return ans;
}
vector<int> Solution::solve(vector<int> &A, vector<string> &B, vector<int> &C) {
    int q = A.size();
    for(int i=1; i <= (4*q); i++)
    {
        mstree[i] = new trie;
    }
    Keys.clear();
    keys.clear();
    for(int i = 0; i < q; i++)
    {
        if(A[i]==1)
        {
            Keys.insert(C[i]);
        }
    }
    for(int i:Keys)
    {
        keys.push_back(i);
    }
    int n = keys.size();
    vector<int> ans;
    if(n==0)
    {
        for(int i=0; i<q; i++)
            ans.push_back(0);
        return ans;
    }
    for(int i=0; i < q; i++)
    {
        if(A[i]==1)
        {
            insert(1, 0, n -1, B, i, C[i]);
        }
        else
        {
            ans.push_back(query(1, 0, n -1, B, i, C[i]));
        }
    }
    
    for(int i=1; i <= (4*q); i++)
        delete mstree[i];
    return ans;
}"
4 number with highest xor,https://www.interviewbit.com/problems/4-number-with-highest-xor/,N/A,Backtracking,easy,"Problem Description

R and X are two programs.
R takes an integer array as input and randomly chooses a subsequence of size 4 from it.

X takes an integer array as input and returns the bitwise XOR of all elements.

You pass an integer array A to R and pass the output from R to X. What's the maximum result you can get?



Problem Constraints
4 <= |A| <= 50
0 <= A[i] <= 1e9


Input Format
First and only argument is an integer array A.


Output Format
Return a single integer denoting maximum answer we can get.


Example Input
Input 1:
    A = [1, 2, 3, 4]
Input 2:

    A = [0, 2, 3, 1, 5]


Example Output
Output 1:
    4
Output 2:

    7


Example Explanation
Explanation 1:
    R must choose all the elements and X returns 4
Explanation 2:

    R can choose [0, 3, 1, 5]. X returns 7 ","int ans;
void find(vector<int> &A, int idx, int l, int curr)
{
    if(l==4)
    {
        ans = max(ans, curr);
        return;
    }
    if(idx==A.size())
        return;
    find(A, idx+1, l, curr);
    find(A, idx+1, l+1, curr^A[idx]);
}
int Solution::solve(vector<int> &A) {
    ans=0;
    find(A,0,0,0);
    return ans;
}"
OR equal XOR,https://www.interviewbit.com/problems/or-equal-xor/,N/A,Bit Manipulation,easy,"Problem Description

You are given an integer A. Find the number of ordered pairs (x, y) such that 0 ? x, y < 2A and they satisfy the following condition-

(x ^ y) = (x | y).

In other words, the bitwise XOR of both these numbers is equal to the bitwise OR of these numbers. Since the answer can be large, calculate it modulo 109 + 7.



Problem Constraints
0 <= A <= 105



Input Format
The first and only argument contains an integer A.


Output Format
Return a single integer denoting the answer.


Example Input

  Input 1:

  0
Input 2:

  1


Example Output

  Output 1:

  1
Output 2:

  3


Example Explanation

  Explanation 1:

  Valid pair - (0, 0)
Explanation 2:

  Valid pairs - (0, 0), (0, 1), (1, 0)","int expo(int a,int b,int mod){
    int ans=1;
    while(b)
    {
        if(b&1)
            ans=(ans*1ll*a)%mod;
        a=(a*1ll*a)%mod;
        b>>=1;
    }
    return ans;
}
int Solution::solve(int A) {
    return expo(3, A, 1e9 + 7);
}"
Turn on the Bulbs,https://www.interviewbit.com/problems/turn-on-the-bulbs/,N/A,Greedy Algorithm,easy,"Problem Description

There are A bulbs lined in a row numbered 1 to A, which are off initially. In one step, you can choose any bulb and turn it on.

If you turn a particular bulb on, the bulb 2 places to the right and 2 places to the left of this bulb would also turn on. Bulbs that are already on will not be affected. 

Formally, if you turn on the bulb numbered X, it will also turn on the bulb numbered X - 2 (if it exists) and bulb numbered X + 2 (if it exists).

Find the minimum number of steps required to turn on all the bulbs.



Problem Constraints
1 <= A <= 109



Input Format
The first and only argument contains an integer A.


Output Format
Return a single integer denoting the answer.


Example Input

  Input 1:

  3
Input 2:

  1


Example Output

  Output 1:

  2
Output 2:

  1


Example Explanation

  Explanation 1:

  One of the optimal way is to -

  1. Turn on bulb numbered 1. It will also turn on bulb numbered 3.
  2. Turn on 2.
Explanation 2:

  We need to turn on the only bulb.
","int Solution::solve(int A) {
    return min(A % 6, 2) + (A/6) * 2;
}"
BST Sum,https://www.interviewbit.com/problems/bst-sum/,N/A,Tree Data Structure,easy,"Problem Description

The cost of an array arr is the sum of all the values in the left subtree of the Binary Search Tree formed by inserting the elements of arr in the order they appear in it.

For example, Binary Search Tree for arr = [5, 2, 9, 1] will look like- 

  5
  / <br> 2 9
 /
1

So, the cost will be 2 + 1 = 3.

Find the sum of the cost of all the permutations of length A. Since answer can be large, return it modulo 109 + 7.

A permutation of length N is an array consisting of N distinct integers from 1 to N in arbitrary order.



Problem Constraints
1 <= N <= 105



Input Format
The first and only argument contains an integer A.


Output Format
Return a single integer denoting the answer.


Example Input

  Input 1:

  2
Input 2:

  3


Example Output

  Output 1:

  1
Output 2:

  8


Example Explanation

  Explanation 1:

  There are 2 permutations-
  1. [1, 2]
  BST 1
       \
        2
  Cost = 0



[2, 1]
BST   2
   /
  1
Cost = 1
Explanation 2:

  There are 6 permutations-
[1, 2, 3] Cost = 0

[3, 2, 1] Cost = 3

[2, 3, 1] Cost = 1

[1, 3, 2] Cost = 0

[2, 1, 3] Cost = 1

[3, 1, 2] Cost = 3

","int expo(int a,int b,int mod){
    int ans=1;
    while(b)
    {
        if(b&1)
            ans=(ans*1ll*a)%mod;
        a=(a*1ll*a)%mod;
        b>>=1;
    }
    return ans;
}
const int mod = 1e9 + 7;
int Solution::solve(int A) {
    int ans = ((A-1) * 1ll * expo(6, mod-2, mod))%mod;
    for(int i = 1; i <= A+1; i++)
        ans = (ans * 1ll * i)%mod;
    return ans;
}"
Jackpot queries,https://www.interviewbit.com/problems/jackpot-queries/,N/A,Graph Data Structure & Algorithms,hard,"Problem Description

You are visiting a fair in byteland. You are shopping and want to buy Q items. Each item cost exactly B[i] amount of money.
You have no money but you have a magical bag on which you can apply an operation any times you want.

In bag there are N integers denoted by array A.

In one operation, You choose two integer X Y from A and deposit all of the amount of money M you have,
this will magically increase your money by X ? Y.

Note: You have to deposit all money you have otherwise you will be exiled from Byteland for your greed. Also, shopkeepers have no change, So you have to pay exact amount. :p

Treating each item as independent and starting with 0 amount of money, Can you find if we can buy each item?



Problem Constraints
2 ? N ? 1000
1 ? A[i] ? 10000
1 ? Q ? 100000
0 ? B[i] ? 109


Input Format
First argument contains an integer array A of size N. Second argument contains an integer array B of size Q.


Output Format
Return a binary string of size Q containing ith as 1 if its possible to buy ith item else 0.


Example Input
Input 1:
A = [1, 2], B = [3, 5, 10, 15]
Input 2:

A = [1, 2, 3], B = [1, 5, 10]


Example Output
Output 1:
""1001""
Output 2: 

""111""


Example Explanation
Explanation 1:

    Note if same number are choosen then xor is 0 so only way to increase is by 3 (1 xor 2). So, all multiple of 3 can be paid off.
","int m;
bool present[20000];
vector<int> vals;
vector<pair<int, int>> gr[20000];
int dis[20000];
const int INF = 1e9 + 9;

void generate_graph() {
    for (int i = 0; i < m; i++) gr[i].clear();
    for (int i = 0; i < m; i++) {
        for (int v: vals) {
            gr[i].emplace_back((i + v) % m, v);
        }
    }
}

void dijkstra() {
    for (int i = 1; i < m; i++) {
        dis[i] = INF;
    }
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
    pq.push({0, 0});
    dis[0] = 0;
    while (!pq.empty()) {
        auto p = pq.top();
        pq.pop();
        int u = p.second;
        for (auto vi: gr[u]) {
            int v = vi.first, weight = vi.second;
            if (dis[v] > (dis[u] + weight)) {
                pq.push({
                                dis[v],
                                v
                        });
                dis[v] = dis[u] + weight;
            }
        }
    }
}

string Solution::solve(vector<int> &A, vector<int> &B) {
    memset(present, 0, sizeof present);
    vals.clear();
    m = 20000;
    for (int x: A)
        for (int y: A)
            present[x ^ y] = 1;

    for (int i = 1; i < 20000; i++)
        if (present[i])
            vals.push_back(i);

    m = vals[0];
    generate_graph();
    dijkstra();
    string ans = """";
    for (int x: B) {
        if (dis[x % m] <= x)
            ans += '1';
        else
            ans += '0';
    }
    return ans;
}"
Unequal Ancestor,https://www.interviewbit.com/problems/unequal-ancestor/,N/A,Tree Data Structure,easy,"Problem Description

You are given a binary tree having N nodes and having root node A. Each node in the tree has either 0 or 1 value. 

Kth ancestor of a node V is defined as:

If K >= 1, (K-1)th ancestor of the parent of node V.
If K = 0, the node V itself.
 For a given integer B, You have to find the number of ordered pair of nodes (X, Y) such that node X is the B
th ancestor of node Y and values of nodes X and Y are <!--complementary-->
not equal to each other.

<!--
You have to find the number of nodes having their Kth ancestor value complementary to their value.

-->


Problem Constraints
 1 <= N <= 105 

 0 <= B <= 105 

 Value of each node is either 0 or 1. 



Input Format
First argument is the root node of the binary tree A.

Second argument is an integer B.



Output Format
Return the number of such ordered pairs.



Example Input
Input 1:

           1

          / \

         0   0

        /

       1

 B = 1
Input 2:

             1

            / \

           0   0

          / \

         1   0

        /     \

       1       1

 B = 2


Example Output
Output 1:

 3 
Output 2:

 3 


Example Explanation
Explanation 1:

 values:    1            node numbers:   1
           / \                          / \
          0   0                        2   3
         /                            /
        1                            4
 Ordered node pairs (1, 2) , (1, 3) and (2, 4) are desired pairs. 


Explanation 2:

 values:      1          node numbers:    1

             / \                         / \
            0   0                       2   3
           / \                         / \
          1   0                       4   5
         /     \                     /     \
        1       1                   6       7
 Ordered node pairs (1, 4) , (2, 6) and (2, 7) are desired pairs. 
","void dfs(TreeNode * node, int k, vector < int > & levVal, int curLev, int & ans) {
  if (node == nullptr) return;
  levVal[curLev] = node -> val;

  if (curLev - k >= 0 && levVal[curLev - k] != levVal[curLev])
    ans++;
  dfs(node -> left, k, levVal, curLev + 1, ans);
  dfs(node -> right, k, levVal, curLev + 1, ans);

  levVal[curLev] = -1;
}

const int N = 1e5 + 100;
int Solution::solve(TreeNode * A, int B) {
  vector <int> levVal(N, -1);
  int ans = 0;
  dfs(A, B, levVal, 0, ans);
  return ans;
}"
Kingdom of Friendship,https://www.interviewbit.com/problems/kingdom-of-friendship/,N/A,Graph Data Structure & Algorithms,easy,"Problem Description
 
 

In the Kingdom of friendship, There live N people, Each person is a friend with every other person.
The Queen wanted to know the best friend of each person
(Note that best-friendship is considered a uni-directional relationship here).
So, She conducted a survey where each person i replied A[i] as his/her best friend.

The Queen was shocked to see there were people who were not the best friend of their best friends.
The Queen thinks all pair who have each other as the best friend, should be given a prize.
Can you tell us how many gifts the queen will distribute?


Note: If a person is best friend of himself he/she should not be awarded.



**Problem Constraints**
1 <= N <= 200000
1 <= A[i] <= N


**Input Format**
First and only argument contains a single integer array A


**Output Format**
Return a single integer denoting number of prize distributed.


**Example Input**
Input 1:
    A = [3, 1, 2]
Input 2: 

    A = [2, 1, 1]


**Example Output**
Output 1:
    0
Output 2:

    1


**Example Explanation**
Explanation 1:
    In this example there is a triangle of friendship and thus no prize is distributed.
                    1  --> 3
                    ^     /
                     \   /
                      2 <
Explanation 2:

    Since 1 think 2 is his best friend and 2 think 1 is best friend. the pair is given a single prize.
","int Solution::solve(vector<int> &A) {
    int ans=0;
    for(int i=1; i<=A.size(); i++)
    {
        if(A[i-1] != i && A[A[(i-1)]-1] == i)
            ans+=1;
    }
    return ans/2;

}"
Shortest in Shortest,https://www.interviewbit.com/problems/shortest-in-shortest/,N/A,Graph Data Structure & Algorithms,medium,"Problem Description

You are given the map of a city having A houses, in form of an undirected graph B, where B[i] denotes a road between 
houses B[i][0] and B[i][1] having length B[i][2].

For a given pair of houses C and D, You have to tell the shortest road that can exist in a shortest path between them.

NOTE: It is guaranteed that there exists always exists a path between C and D, i.e, they are always connected.



Problem Constraints
 2 <= A <= 105 

 1 <= |B| <= 106

 1 <= A[i][0], A[i][1] <= N 

 1 <= A[i][2] <= 109 

 C is not equal to D. 



Input Format
First argument is an integer A.

Second argument is a 2-D integer matrix B.

Third argument is an integer C.

Fourth argument is an integer D.



Output Format
Return an integer denoting length of required shortest edge.



Example Input
Input 1:

 A = 7
 B = [1 2 2]
     [2 3 8]
     [1 7 3]
     [7 4 2]
     [4 3 5]
     [1 5 3]
     [5 3 7]
     [1 6 1]
 C = 1
 D = 3
Input 2:

 A = 4
 B = [1 2 1]
     [2 3 1]
     [1 3 2]
     [3 4 1]
 C = 2
 D = 4 


Example Output
Output 1:

 2 
Output 2:

 2 


Example Explanation
Explanation 1:

 
graph-5


 In the graph, we need to go from house 1 to house 3. None of the shortest path includes road [1 6 1], so it can never give the answer.
 There are 3 shortest paths between house 1 and house 3:
 1) 1 -> 2 -> 3 = Total length = 10
 2) 1 -> 5 -> 3 = Total length = 10
 3) 1 -> 7 -> 4 -> 3 = Total length = 10
 So, edges [1 2 2], [2 3 8], [1 5 3], [5 3 7], [1 7 3], [7 4 2] and [4 3 5] are each part of one of shortest paths between houses 1 and 3.
 Hence, the shortest road length in a shortest path = 2
Explanation 2:

 
graph-6

 
 There is only one shortest path between C and D : 2 -> 3 -> 4. 
 The shortest road in the path has length = 1. 
","vector < long long > findShortestPaths(int A, int src, vector < vector < pair < int, int >>> & adj) {
  vector < long long > d(A, LLONG_MAX);
  vector < bool > vis(A, false);
  priority_queue < pair < long long, int > , vector < pair < long long, int >> , greater < pair < long long, int >>> pq;

  d[src] = 0;
  pq.push({
    0,
    src
  });

  while (pq.size()) {
    int node = pq.top().second;
    long long dis = pq.top().first;
    pq.pop();
    if (vis[node])
      continue;
    vis[node] = true;
    for (auto pr: adj[node]) {
      if (d[node] + pr.second < d[pr.first]) {
        d[pr.first] = d[node] + pr.second;
        pq.push({
          d[pr.first],
          pr.first
        });
      }
    }
  }
  return d;
}

int Solution::solve(const int A,
  const vector < vector < int > > & B,
    const int C,
      const int D) {
  vector < vector < pair < int, int >>> adj(A);

  for (int i = 0; i < B.size(); i++) {
    adj[B[i][0] - 1].push_back({
      B[i][1] - 1,
      B[i][2]
    });
    adj[B[i][1] - 1].push_back({
      B[i][0] - 1,
      B[i][2]
    });
  }

  vector < long long > dC = findShortestPaths(A, C - 1, adj);

  long long shortestPath = dC[D - 1];

  vector < long long > dD = findShortestPaths(A, D - 1, adj);

  int ans = INT_MAX;
  for (int i = 0; i < B.size(); i++) {
    if (dC[B[i][0] - 1] + B[i][2] + dD[B[i][1] - 1] == shortestPath) {
      ans = min(ans, B[i][2]);
    }
    if (dC[B[i][1] - 1] + B[i][2] + dD[B[i][0] - 1] == shortestPath) {
      ans = min(ans, B[i][2]);
    }
  }

  return ans;
}"
Meeting Point,https://www.interviewbit.com/problems/meeting-point/,N/A,Heaps And Maps,easy,"Problem Description

You and your friend decided to meet at one of the N locations in the town. The ith location is located at (A[i][0], A[i][1]) on an infinite 2D grid.

You want to meet at the location with minimum x-coordinate. If there are multiple such locations, choose the one with the minimum y-coordinate. If there are still multiple such locations, you can choose any of them.

Your friend wants to meet at the location with minimum y-coordinate. If there are multiple such locations, choose the one with the minimum x-coordinate. If there are still multiple such locations, you can choose any of them.   

Now, you need to find the distance between these two locations. The distance between (x1, y1) and (x2, y2) is |x1 - x2| + |y1 - y2| where |a| is the absolute value of a.



Problem Constraints
2 <= N <= 2 x 105 

1 <= A[i][0], A[i][1] <= 109

There maybe multiple locations with the same coordinates.



Input Format
The first and only argument contains an integer array A of size N x 2.


Output Format
Return a single integer, the answer to the problem.


Example Input

  Input 1:

  A : 
  [
    [10, 10]
    [2, 9]
    [4, 6]
  ]
Input 2:
  A : 
  [
    [1, 3]
    [7, 5]
  ]


Example Output

  Output 1:

  5
Output 2:
  0


Example Explanation

  Explanation 1:

  You will meet at (2, 9). Friend wants to meet at (4, 6). Distance between them is |2 - 4| + |9 - 6| = 5.
Explanation 2:
  (1, 3) has both minimum x and y coordinate.
","int Solution::solve(vector<vector<int> > &A) {
    int n = A.size();
    pair<int, int> mnx = {1000000000, 1000000000}, mny = {1000000000, 1000000000};
    for(int i = 0; i < n; i++){
        int x = A[i][0], y = A[i][1]; 
        mnx = min(mnx, {x, y});
        mny = min(mny, {y, x});
    }
    swap(mny.first, mny.second);
    return abs(mnx.first - mny.first) + (mnx.second - mny.second);
}"
Maximum xor with Min X,https://www.interviewbit.com/problems/maximum-xor-with-min-x/,N/A,Greedy Algorithm,easy,"Problem Description

Given an integer A, select two integers (X, Y) such that 1 <= X, Y <= A, such that they have maximum possible xor.
If there are multiple (X, Y); choose one with the smallest X.



Problem Constraints
1 <= A <= 2109


Input Format
First argument contains a single integer A.


Output Format
Return a integer array of size 2 of the form [X, Y]


Example Input
Input 1:
    A = 1
Input 2:

    A = 2


Example Output
Output 1:
    [1, 1]
Output 2:

    [1, 2]


Example Explanation*
Explanation 1:
    there is only one possible pair to choose, (1,1)
Explanation 2:

    There are four options: (1,1), (1,2), (2,1), (2,2). (1,1) and (2,2) have xor 0 whereas (1,2) and (2,1) have xor 3.
    We chose (1,2) since it has smaller x.
","vector<int> Solution::solve(int A) {
    if(A == 1)return {1, 1};
    int x = (int)log2(A) + 1;
    int k = (1 << x) - 1;
    if(k == A)return {1, A - 1};
    return {k - A, A};
}"
Ticket Counter,https://www.interviewbit.com/problems/ticket-counter/,N/A,Stacks And Queues,easy,"Problem Description

There is a line at Ticket Counter of N people.
Each person has a patience level A[i] which if reaches 0, the person leaves the line. Also, It takes B[i] amount of time to process the tickets for the ith person.

 In each unit time patience level of each person in line drop by 1.

The ticket counter wants to know the number of customers who will leave the line.

Note: If the person reaches the front just at the moment it's patience reaches 0, it will not leave the line.



Problem Constraints
1 <= N <= 100000
1 <= A[i]<= 1000000000
1 <= B[i]<= 100000


Input Format
First argument of input is an integer array A. Second argument of input is an integer array B.


Output Format
Return a single integer denoting number of people who leave the line.


Example Input
Input 1:
A = [1, 7, 6, 5], B = [3, 3, 3, 1]
Input 2:

A = [1], B = [10]


Example Output
Output 1:
    1

Output 2:

    0


Example Explanation
Explanation 1:
    At time 0, person 1 is served at ticket counter.
    At time 3, person 1 leaves counter and person 2 is served at ticket counter.
    At time 5, person 4 patience level reaches 0 and leaves the line.
    At time 6, person 2 leaves counter and person 3 is served at ticket counter.
    At time 9, person 3 leaves counter.
Explanation 2:

   At time 0, person 1 is served at ticket counter and leaves at time 10.","int Solution::solve(vector<int> &A, vector<int> &B) {
        int n = A.size(), t=0, ans=0;
        for(int i=0; i<n; i++)
        {
            if(t > A[i])
            {
                ans +=1;    
                continue;
            }
            t += B[i];
        }
        return ans;
}"
Max Base Pair,https://www.interviewbit.com/problems/max-base-pair/,N/A,Tree Data Structure,medium,"Problem Description

You are given an integer array A. There is a function,F for two integers X and Y with another variable B(base).

Now for caluculating the functional value first convert X and Y in Base B and then ith bit of F(X,Y,B) = (Xi+Yi)%B.

You have to return the maximum functional value possible for any pair of elements of Array A in base B. Please note that you can't take two elements for pair from the same index.

NOTE: Array elements are in base 10 and you have to return your answer also in base 10(calculated value from equation is in base B).



Problem Constraints
1 <= A.size() <= 106

2 <= A[i] <= 106

2 <= B <= 9



Input Format
First argument is a vector of integers A.

Second argument is an integer B



Output Format
Return a single integer showing maximum pair functional value.



Example Input
Input 1:

10 1 2 3 4 5 6 7 8 9 10
3
Input 2:

5 10 99 88 48 213
7


Example Output
Output 1:

19
Output 2:

312


Example Explanation
Explanation 1:

93 = 100 and 103 = 101
Hence, F(9,10,3) = 2013 = 1910
We may check for other pairs we will get less than or equal to 15.
Explanation 2:

Lets calculate F(i,j,7) for all pairs,
10 99: 109
10 88: 91
10 48: 2
10 213: 223
99 88: 187
99 48: 140
99 213: 312
88 48: 80
88 213: 245
48 213: 205
Clearly maximum value is 312.
","
int b = 10, num_length = 21;

vector <int> num_to_vec_base(int x){
    vector <int> v;
    while(x > 0){
        v.push_back(x % b);
        x = x / b;
    }
    while(v.size() < num_length) v.push_back(0);
    reverse(v.begin(), v.end());
    return v;
}

int vec_to_num_base(vector <int> v){
    int val = 1, total = 0;
    for(int i = v.size()-1; i >= 0; i--){
        total += v[i] * val;
        val = val * b; 
    }
    return total;
}

struct trie_node{
    trie_node * next[21];
    int end_here = 0;
    trie_node(){
        for(int i = 0; i < 21; i++)next[i] = NULL;
    }
}; 

void insert(trie_node * cur, int ptr, vector <int> &num){
    if(ptr == num.size()) return;
    if(cur->next[num[ptr]] == NULL) cur->next[num[ptr]] = new trie_node;
    insert(cur->next[num[ptr]], ptr + 1, num);
}

vector <int> find(trie_node * cur, int ptr, vector<int> &num, vector <int> &built_ans){
    if(ptr >= num.size()) return built_ans;
    else{
        int number = num[ptr];
        for(int i = 0; i<b; i++){
            int modulo = (b-1 - number - i + 2 * b) % b;
            if(cur->next[modulo] != NULL){
                built_ans.push_back(modulo);
                return find(cur->next[modulo], ptr + 1, num, built_ans);
            }
        }
        cout << endl;
        return built_ans;
    }
}

vector <int> combine(vector <int> x, vector <int> y){
    for(int i = 0; i < x.size(); i++)x[i] = (x[i] + y[i]) % b;
    return x;
}

int Solution::solve(vector<int> &A, int B) {
    int n = A.size(), ans = 0;
    b=B;
	vector <vector<int>> vec;
    for(int i = 0; i<n; i++)vec.push_back(num_to_vec_base(A[i]));
    trie_node * root = new trie_node;
    insert(root,0,vec[0]);
    for(int i = 1; i < n; i++){
        vector <int> empty;
        vector <int> left = find(root,0,vec[i],empty);
        vector <int> ansvec = combine(vec[i],left);
        int cur_ans = vec_to_num_base(ansvec);
        if(cur_ans > ans)ans = cur_ans;
        insert(root,0,vec[i]);
    }
    return ans;
}"
Strengthen It,https://www.interviewbit.com/problems/strengthen-it/,N/A,Graph Data Structure & Algorithms,easy,"Problem Description

You are given an undirected graph having A nodes and |B| edges, ith edge connecting nodes B[i][1] and B[i][2].

Strength of a connected component is defined as the number of edges existing in that component.

Given an integer C, you have to tell the maximum strength that a connected component in the given graph can have, if we are allowed to add exactly C edges to the graph.



Problem Constraints
 1 <= A <= 105 

 1 <= |B| <= 2 * 105 

 1 <= B[i][0], B[i][1] <= A 

 0 <= C <= 109 



Input Format
First argument is an integer A

Second argument is a 2D matrix B having size |B| X 2

Third argument is an integer C



Output Format
Return an integer denoting the maximum strength achievable in the graph.



Example Input
Input 1:

 A = 7 
 B = [
       [1, 2]
       [2, 3]
       [3, 1]
       [4, 5]
       [5, 6]
       [6, 1]
     ]
 C = 1
Input 2:

 A = 3
 B = [
       [1, 2]
       [2, 2]
       [2, 3]
       [3, 1]
     ]
 C = 2


Example Output
Output 1:

 7
Output 2:

 6


Example Explanation
Explanation 1:

 Initially there are 3 components in the graph.
 We can add an edge between node 1 and node 4.
 Now the resultant graph will have 2 components with strengths 7 and 0.
 Maximum achievable strength after adding one edge = 7.
Explanation 2:

 The graph contains only a single component.
 If we add 2 edges in the component, the strength becomes 6.","vector<int> comp;
vector<bool> vis;
vector<vector<int>> adj;
void dfs(int v){
    vis[v] = true;
    comp.push_back(v);
    for(auto nbr:adj[v]){
        if(!vis[nbr]){
            dfs(nbr);
        }
    }
}

int Solution::solve(int A, vector<vector<int> > &B, int C) {
    assert(A >= 1 && A <= 1e5);
    assert(B.size() >= 1 && B.size() <= 2e5);
    assert(B[0].size() == 2);
    for (int i = 0; i < B.size();i++){
        for (int j = 0; j < 2;j++){
            assert(B[i][j] >= 1 && B[i][j] <= A);
        }
    }
    assert(C >= 0 && C <= 1e9);
    vis = vector<bool>(A, false);
    adj = vector<vector<int>>(A);
    vector<int> comps;
    
    for (int i = 0; i < B.size();i++){
        adj[B[i][0] - 1].push_back(B[i][1] - 1);
        adj[B[i][1] - 1].push_back(B[i][0] - 1);
    }
    
    for (int i = 0; i < A; i++)
    {
        if (!vis[i])
        {
            comp = vector<int>();
            dfs(i);
            int cnt = 0;
            for (int j = 0; j < comp.size(); j++)
            {
                cnt += adj[comp[j]].size();
            }
            assert(cnt % 2 == 0);
            comps.push_back(cnt / 2);
        }
    }
    sort(comps.rbegin(), comps.rend());
    if(comps.size() - 1 <= C){
        return B.size() + C;
    }
    int ans = 0;
    for (int i = 0; i < C + 1;i++){
        ans += comps[i];
    }
    ans += C;
    return ans;
}"
Yet another string operation problem,https://www.interviewbit.com/problems/yet-another-string-operation-problem/,N/A,Dynamic Programming,medium,"Problem Description

You are given two strings, A and B of same length.
In one operation you can set some A[x] equal to B[x], this cost 1 coin.

You can also Reverse a substring A[i...j] atmost once. this cost C coins.

Find minimum operation required to make both string equal.



Problem Constraints
1 <= |A| = |B| <= 1000
A and B consist of lower case alphabets
0 <= C <= |A|


Input Format
First argument of input contains a string A.
Second argument of input contains a string B.
Third argument of input contains an integer C.


Output Format
Return an integer denoting minimum coins to make strings equal.


Example Input
Input 1:
    A = ""abceda"", B = ""bdecbo"", C = 1
Input 2:

    A = ""finger"", B = ""ginger"", C = 0


Example Output
Output 1:
    3
Output 2:

    1


Example Explanation
Explanation 1:
    Initially we have, A = ""abceda""
    set A[0] = B[0], A = ""bbceda""
    set A[5] = B[5], A = ""bbcedo""
    reverse (1,4),   A = ""bdecbo""
Explanation 2:

    set A[0] = B[0]
","int Solution::solve(string A, string B, int C) {
    vector<vector<vector<int>>> dp(A.size(), vector<vector<int>>(B.size(),vector<int>(2, -1)));
    function<int(int,int,bool)> go = [&](int l, int r, bool rotated = false)->int{
        if(l > r)return 0;
        if(l == r)return A[l] != B[r];
        
        int &ans = dp[l][r][rotated];
        if(ans != -1)return ans;
        
        if(rotated)
            ans = (A[l] != B[r]) + (A[r] != B[l]) + go(l + 1, r - 1, 1);
        else {
            ans = (A[l] != B[l]) + go(l + 1, r, 0);
            ans = min(ans, (A[r] != B[r]) + go(l, r - 1, 0));
            ans = min(ans, C + go(l, r, 1));
        }
        return ans;
    };
    return go(0, A.size() - 1, 0);
}"
Allied Nations' Tour,https://www.interviewbit.com/problems/allied-nations-tour/,N/A,Dynamic Programming,hard,"Problem Description


As we all know the five great nations have come together in order to fight Madra Uchiha. As these five nations have combined
travelling in them has become quite difficult. 


The allied nations in total have A cities numbered from 1 to A. Currently you are at city B. 
Your task is take a tour of among given A cities for C days. From a city i you can go to any city in the range
i-E to i+E and you can not go out of range. It is not necessary
to visit all the cities, you just have to take a tour for C days. Two tours will be different from each other 
if there is some day in which both visitied different cities. 


However the intel core has provided M information given in form of 2D array D of size M. 
According to this at day D[i][0] Akatsuki will 
attack on city D[i][1]. You are to avoid any collision with the Akatsuki. You can not be present in some city on a certain day
if Akatsuki will arrive there.


Find the total number of tours you will be able to take. Since the answer can be big output it %1000000007



Problem Constraints
1 <= A, C <= 1000

1 <= M <= AC

1 <= B <= A

1 <= D[i][0] <= C

1 <= D[i][1] <= A

1 <= E <= A


Input Format
First argument contains integer A.
Second argument contains starting city B.
Third argument contains number of days C.
Fourth argument contains intel in form D.


Output Format
Return a single integer as the answer to the question.


Example Input
Input 1:
A = 2
B = 2
C = 5
D = [ [5, 1], 
      [3, 1],
      [4, 2],
      [2, 1],
      [1, 2]
    ]

E = 1


Input 2:

A = 4
B = 1
C = 4
D = []
E = 4


Example Output
Output 1:
1


Output 2:

256


Example Explanation*
Explanation 1:
For day 1, we can only go to city 1.
For day 2, we can only go to city 2 from 1.
For day 3, we can only go to city 2 from 2.
For day 4, we can only go to city 2 from 2.
For final day, we can only go to city  2 from 2.


Hence there is only one tour available : 1, 2, 2, 2, 2 



Explanation 2:

We can choose any city on any day. Hence ans = 444*4 = 256
","#define ll long long int
ll const N=1009;
ll dp[N][N];
vector<ll> invalid[N];
ll const mod=1000000007;
int Solution::solve(int A, int B, int C, vector<vector<int> > &D, int E) {
    assert(A >= 1 && A <= 1000);
    assert(C >= 1 && C <= 1000);
    assert(B >= 1 && B <= A);
    assert(E >= 1 && E <= A);
    assert(D.size() >= 1 && D.size() <= A * C);
    for(int i = 0; i < D.size(); i++) {
        assert(D[i][0] >= 1 && D[i][0] <= C);
        assert(D[i][1] >= 1 && D[i][1] <= A);
    }
    for(int i = 0;i <= C + 2;i++){
		invalid[i].clear();
		for(int j = 0; j <= A+2 ; j++){
			dp[i][j]=0;
		}
	}
	for(auto i:D){
	    invalid[i[0]].push_back(i[1]);
	}
	for(int i=B;i<=A;i++)dp[0][i]=1;
	
	for(int i=1;i<=C;i++){
		for(int j=1;j<=A;j++){
			dp[i][j]=(dp[i-1][min(A,j+E)]-dp[i-1][max(0,j-E-1)]+mod)%mod;
		}
		for(auto it: invalid[i]){
			dp[i][it]=0;
		}
		for(int j=2;j<=A;j++){
			dp[i][j]=(dp[i][j]+dp[i][j-1])%mod;
		}
	}
	return dp[C][A];
}"
Maximum height of staircase,https://www.interviewbit.com/problems/maximum-height-of-staircase/,N/A,Math,easy,"Problem Description
 
 

Given an integer A representing the number of square blocks. The height of each square block is 1. The task is to create a staircase of max height using these blocks.

The first stair would require only one block, the second stair would require two blocks and so on.

Find and return the maximum height of the staircase.



Problem Constraints
0 <= A <= 109


Input Format
The only argument given is integer A.



Output Format
Return the maximum height of the staircase using these blocks.



Example Input
Input 1:

 A = 10
Input 2:

 20


Example Output
Output 1:

 4
Output 2:

 5","int Solution::solve(int n) {
    int cnt=0;
    for(int i=1;i<=n;i++){
        n-=i;
        cnt++;
    }
    return cnt;
}"
Nodes at Distance K,https://www.interviewbit.com/problems/nodes-at-distance-k/,Amazon,Tree Data Structure,medium,"Problem Description
 
 

Given the root of a binary tree A, the value of a target node B, and an integer C, return an array of the values of all nodes that have a distance C from the target node.

You can return the answer in any order.


Problem Constraints
1 ? N ? 105 (N is the number of nodes in the binary tree)
1 ? Ai ? N (Ai denotes the values of the nodes in the tree)
All the values in the nodes are unique.
1 ? C ? 104


Input Format
The first argument is the root node of the binary tree A.
The second argument is an integer B denoting the label of the target node.
The third argument is an integer C denoting the distance.


Output Format
Return an array of integers denoting the nodes which are at a distance C from the node B.


Example Input
Input 1:
A =     1
       / \
      2   3
     / \
    4   5


B = 2
C = 1

Input 2:

A =     1
       / \
      2   3
     / \
    4   5


B = 2
C = 2



Example Output
Output 1:
[1, 4, 5]
Output 2:

[3]


Example Explanation
Explanation 1: 

For the given tree, we have target node as 2.

All the nodes with are at distance 1, meaning the adjacent nodes are [1, 4, 5].

Explanation 2:

The given tree is same, and [3] is the only node with distance 2.


","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
map<TreeNode*, TreeNode*> parent;
TreeNode* target;
vector<int> ans;
void dfs(TreeNode* root, int B){
    if(root->val==B){
        target = root;
    }
    if(root->left!=NULL){
        parent[root->left] = root;
        dfs(root->left, B);
    }
    if(root->right!=NULL){
        parent[root->right] = root;
        dfs(root->right, B);
    }
}

void bfs(int C){
    
    map<TreeNode*, int> depth;
    queue<TreeNode*> q;
    q.push(target);
    depth[target] = 0;
    
    while(!q.empty()){
        TreeNode* cur = q.front();
        q.pop();
        
        if(parent.find(cur)!=parent.end()){
            TreeNode* t = parent[cur];
            if(depth.find(t)==depth.end() || depth[t]>1+depth[cur]){
                depth[t] = 1+depth[cur];
                if(depth[t]==C){
                    ans.push_back(t->val);
                }
                q.push(t);
            }
        }
        
        if(cur->left!=NULL){
            TreeNode* t = cur->left;
            if(depth.find(t)==depth.end() || depth[t]>1+depth[cur]){
                depth[t] = 1+depth[cur];
                if(depth[t]==C){
                    ans.push_back(t->val);
                }
                q.push(t);
            }
        }
        
        if(cur->right!=NULL){
            TreeNode* t = cur->right;
            if(depth.find(t)==depth.end() || depth[t]>1+depth[cur]){
                depth[t] = 1+depth[cur];
                if(depth[t]==C){
                    ans.push_back(t->val);
                }
                q.push(t);
            }
        }
    }
}

vector<int> Solution::distanceK(TreeNode* A, int B, int C) {
    parent.clear();
    ans.clear();
    dfs(A, B);
    bfs(C);
    return ans;
}"
Reorder Data in Log Files,https://www.interviewbit.com/problems/reorder-data-in-log-files/,Amazon,Arrays,medium,"Reorder Data in Log Files
medium
63.4% Success

101

48

Bookmark
Asked In:
Max Score: 200
Hint
Solution Approach
Complete Solution
Problem Description
 
 

You are given an array of logs. Each log is a space-delimited string of words, where the first word is the identifier.

There are two types of logs:

Letter-logs: All words (except the identifier) consist of lowercase English letters.
Digit-logs: All words (except the identifier) consist of digits.

Reorder these logs so that:

The letter-logs come before all digit-logs.
The letter-logs are sorted lexicographically by their contents. If their contents are the same, then sort them lexicographically by their identifiers.
The digit-logs maintain their relative ordering.

Return the final order of the logs.


Problem Constraints
1 <= logs.length <= 1000
3 <= logs[i].length <= 1000
All the tokens of logs[i] are separated by a single space.
logs[i] is guaranteed to have an identifier and at least one word after the identifier.


Input Format
The first argument is a string array A where each element is a log.


Output Format
Return the string array A after making the changes.


Example Input
Input 1:
A = [""dig1-8-1-5-1"", ""let1-art-can"", ""dig2-3-6"", ""let2-own-kit-dig"", ""let3-art-zero""]
Input 2:

A = [""a1-9-2-3-1"",""g1-act-car"",""zo4-4-7"",""ab1-off-key-dog"",""a8-act-zoo""]


Example Output
Output 1:
[""let1-art-can"",""let3-art-zero"",""let2-own-kit-dig"",""dig1-8-1-5-1"",""dig2-3-6""]
Output 2:

[""g1-act-car"", ""a8-act-zoo"", ""ab1-off-key-dog"", ""a1-9-2-3-1"", ""zo4-4-7""]


Example Explanation
Explanation 1:
The letter-log contents are all different, so their ordering is ""art-can"", ""art-zero"", ""own-kit-dig"".
The digit-logs have a relative order of ""dig1-8-1-5-1"", ""dig2-3-6"".
Explanation 2:

The array has been sorted restricted to the conditions given.","bool compare(string s1,string s2){
    string aa = s1.substr(s1.find('-'));
    string bb = s2.substr(s2.find('-'));
    
    return aa == bb ? s1 < s2 : aa < bb;
}
vector<string> Solution::reorderLogs(vector<string> &A) {
    vector<string> result;
    int count = 0;
    for(auto log : A){
        if(log.back() <= 'z' and log.back() >= 'a') {
            result.insert(result.begin(),log);
            count++;
        }
        else result.push_back(log);
    }
    sort(result.begin(),result.begin()+count,compare);
    return result;
}"
K-th Permutation,https://www.interviewbit.com/problems/k-th-permutation/,Amazon,Math,medium,"Problem Description

You are given an integer A which represents the length of a permutation.
 A permutation is an array of length A where all the elements occur exactly once and in any order.
 For example, [3, 4, 1, 2], [1, 2, 3] are examples of valid permutations while [1, 2, 2], [2] are not.

You are also given an integer B.
 If all the permutation of length A are sorted lexicographically, return the Bth permutation.



Problem Constraints

1 <= A <= 105
1 <= B <= min(1018, A!), where A! denotes the factorial of A.


Input Format

The first argument is the integer A.
The second argument is the long integer B.


Output Format

Return an array denoting the Bth permutation of length A.


Example Input

Input 1:
 

 

A = 3
B = 3
Input 2:

A = 1
B = 1
 

 



Example Output

Output 1:
 

 

[2, 1, 3]
Output 2:

[1]
 

 



Example Explanation

Explanation 1:
 

 

All the permutations of length 3 sorted in lexicographical order are:
[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].
Therefore, the third permutation is [2, 1, 3].
Explanation 2:

There is only one possible permutation -> [1].
 

 
","vector<int> Solution::findPerm(int A, long B) {
    vector<long>fact(21);
    fact[0] = 1;
    for (int i = 1; i <= 20; i++) {
        fact[i] = i * fact[i - 1];
    }
    vector<int> ans(A);
    int curr = 0;
    for (int i = 0; i < A - 20; i++) {
        ans[i] = i + 1;
        curr = i;
    }
    vector<int> l1;
    for (int i = max(A - 20, 1); i <= A; i++) {
        l1.push_back(i);
    }
    B--;
    for (int i = min(20, A - 1); i >= 0; i--) {
        int idx = (int)(B / fact[i]);
        B -= idx * fact[i];
        ans[curr++] = l1[idx];
        l1.erase(l1.begin() + idx);
    }
    return ans;
}"
Vertical Sum of a Binary Tree,https://www.interviewbit.com/problems/vertical-sum-of-a-binary-tree/,Amazon,Tree Data Structure,medium,"Problem Description
 
 

You are given the root of a binary tree A.

You have to find the vertical sum of the tree.

A vertical sum denotes an array of sum of the different verticals of a binary tree,

where the leftmost vertical sum is the first element of the array and rightmost vertical is the last.



Problem Constraints
1 <= Number of nodes in the binary tree <= 105
1 <= Ai <= 103


Input Format
The first argument is the root of a binary tree A.


Output Format
Return an array denoting the vertical sum of the binary tree.


Example Input
Input 1:
A =     1
      /   \
     2     3
    / \   / \
   4   5 6   7
Input 2:

A =     1
       /
      2
     /
    3


Example Output
Output 1:
[4, 2, 12, 3, 7]
Output 2:

[3, 2, 1]


Example Explanation
Explanation 1:
The element 4 is present in the leftmost vertical. 
The middle vertical consists of 3 elements 1, 5, 6.
The resultant array is [4, 2, 12, 3, 7].
Explanation 2:

The leftmost vertical is the element 3. The next verticals are 2 and 1.
Hence, the resultant array is [3, 2, 1].
","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
map<int, int> mp;
void rec(TreeNode* root, int HD){
    if(root == NULL){
        return;
    }
    mp[HD] += root -> val;
    rec(root -> left, HD - 1);
    rec(root -> right, HD + 1);
}
vector<int> Solution::verticalSum(TreeNode* A) {
    mp.clear();
    rec(A, 0);
    vector<int> ans;
    for(auto &x : mp){
        ans.push_back(x.second);
    }
    return ans;
}"
Serialize,https://www.interviewbit.com/problems/serialize/,Flipkart,Strings,medium,"Problem Description
 
 

You are given an array A of strings and we have to serialize it and return the serialized string.

Serialization: Scan each element in a string, calculate its length and append it with a string and a element separator or deliminator (the deliminator is ~). We append the length of the string so that we know the length of each element.

For example, for a string 'interviewbit', its serialized version would be 'interviewbit12~'.



Problem Constraints
1 <= |A| <= 1000
1 <= |Ai| <= 1000
Ai only contains lowercase english alphabets.


Input Format
The first argument A is the string array A.


Output Format
Return a single integer denoting the serialized string.


Example Input
Input 1:
A = ['scaler', 'academy']
Input 2:

A = ['interviewbit']


Example Output
Output 1:
scaler6~academy7~
Output 2:

interviewbit12~


Example Explanation
Explanation 1:
Length of 'scaler' is 6 and academy is 7. So, the resulting string is scaler6~academy7~.
Explanation 2:

Explained in the description above.
.
","string Solution::serialize(vector<string> &A) {
    assert(A.size() >= 1 && A.size() <= 1000);
    string ans = """";
    for(auto &x: A){
        assert(x.size() >= 1 && x.size() <= 1000);
        for(auto &y : x){
            assert(y >= 'a' && y <= 'z');
        }
        ans += x;
        ans += to_string(x.size());
        ans += '~';
    }
    return ans;
}"
Deserialize,https://www.interviewbit.com/problems/deserialize/,Flipkart,Strings,medium,"Problem Description
 
 

You are given a string A which is a serialized string. You have to restore the original array of strings.

The string in the output array should only have lowercase english alphabets.

Serialization: Scan each element in a string, calculate its length and append it with a string and a element separator or deliminator (the deliminator is ~). We append the length of the string so that we know the length of each element.

For example, for a string 'interviewbit', its serialized version would be 'interviewbit12~'.



Problem Constraints
1 <= |A| <= 106


Input Format
The first argument is the string A.


Output Format
Return an array of strings which are deserialized.


Example Input
Input 1:
A = 'scaler6~academy7~'
Input 2:

A = 'interviewbit12~'


Example Output
Output 1:
['scaler', 'academy']
Output 2:

['interviewbit']


Example Explanation
Explanation 1:
Length of 'scaler' is 6 and academy is 7. So, the resulting string is scaler6~academy7~.
We hve to reverse the process.
Explanation 2:

Explained in the description above.
","vector<string> Solution::deserialize(string A) {
    vector<string> ans;
    int i = -1;
    int j = 0;
    while(j < A.size()){
        while(A[j] <= 122 && A[j] >= 97){
            j++;
        }
        ans.push_back(A.substr(i + 1, j - i - 1));
        while(j < A.size() && A[j] != '~'){
            j++;
        }
        i = j++;
    }   
    return ans;
}"
Serialize Binary Tree Migrated,https://www.interviewbit.com/problems/serialize-binary-tree-migrated/,N/A,Tree Data Structure,medium,"Problem Description
 
 

Given the root node  of a Binary Tree denoted by A. You have to Serialize the given Binary Tree in the described format.

Serialize means encode it into a integer array denoting the Level Order Traversal of the given Binary Tree.

NOTE:

In the array, the NULL/None child is denoted by -1.
For more clarification check the Example Input.


Problem Constraints
 1 <= number of nodes <= 105



Input Format
Only argument is a A denoting the root node of a Binary Tree.



Output Format
Return an integer array denoting the Level Order Traversal of the given Binary Tree.



Example Input
Input 1:

           1
         /   \
        2     3
       / \
      4   5
Input 2:

            1
          /   \
         2     3
        / \     \
       4   5     6


Example Output
Output 1:

 [1, 2, 3, 4, 5, -1, -1, -1, -1, -1, -1]
Output 2:

 [1, 2, 3, 4, 5, -1, 6, -1, -1, -1, -1, -1, -1]


Example Explanation
Explanation 1:

 The Level Order Traversal of the given tree will be [1, 2, 3, 4, 5 , -1, -1, -1, -1, -1, -1].
 Since 3, 4 and 5 each has both NULL child we had represented that using -1.
Explanation 2:

 The Level Order Traversal of the given tree will be [1, 2, 3, 4, 5, -1, 6, -1, -1, -1, -1, -1, -1].
 Since 3 has left child as NULL while 4 and 5 each has both NULL child.
","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
vector<int> Solution::solve(TreeNode* A) {
    vector<int> ans;
    queue<TreeNode*> q;
    q.push(A);
    while(!q.empty()){
        TreeNode* t = q.front();
        q.pop();
        if(t==NULL) {
            ans.push_back(-1);
            continue;
        }
        ans.push_back(t->val);
        q.push(t->left);
        q.push(t->right);
    }
    return ans;
}"
String And Its Frequency,https://www.interviewbit.com/problems/string-and-its-frequency/,N/A,Strings,medium,"Problem Description
 
 

 Given a string A with lowercase english alphabets and you have to return a string in which, with each character its frequency is written in adjacent.



Problem Constraints
1 <= |A| <= 105


Input Format
First argument is the string A with lowercase english alphabets.


Output Format
Return a string in which each character frequency is written in adjacent.


Example Input
Input 1:
abbhuabcfghh
Input 2:

a


Example Output
Ouput 1:
a2b3h3u1c1f1g1
Ouput 2:

a1


Example Explanation
Explanation 1:
‘a’ occurs in the string a total of 2 times so we write a2 then ‘b’ occurs a total of 3 times so next we write b3 and so on
Explanation 2:

‘a’ occurs in the string a total of 1 time only.
","string Solution::solve(string A) {
    string s;
    int arr[27]={0};
    for(auto i: A)  arr[i-'a']++;
    for(auto i: A) {
        if(arr[i-'a']>0) {
            s+=i;
            s+=to_string(arr[i-'a']);
            arr[i-'a']=0;
        }
    }
    return s;
    
}"
Move Zeroes,https://www.interviewbit.com/problems/move-zeroes/,Adobe,Arrays,medium,"Problem Description
 
 

Given an integer array A, move all 0's to the end of it while maintaining the relative order of the non-zero elements.


Note that you must do this in-place without making a copy of the array.



Problem Constraints
1 <= |A| <= 105


Input Format
First argument is array of integers A.


Output Format
Return an array of integers which satisfies above property.


Example Input
Input 1:
A = [0, 1, 0, 3, 12]
Input 2:

A = [0]


Example Output
Ouput 1:
[1, 3, 12, 0, 0]
Ouput 2:

[0]


Example Explanation
Explanation 1:
Shift all zeroes to the end.
Explanation 2:

There is only one zero so no need of shifting.
","vector<int> Solution::solve(vector<int> &nums) {
    int j = 0;
    // move all the nonzero elements advance
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] != 0) {
            nums[j++] = nums[i];
        }
    }
    for (;j < nums.size(); j++) {
        nums[j] = 0;
    }
    return nums;
}"
Make equal elements Array,https://www.interviewbit.com/problems/make-equal-elements-array/,Amazon,Arrays,medium,"Problem Description
 
 

Given an array of all positive integers and an element “x”. 

You need to find out whether all array elements can be made equal or not by performing any of the 3 operations: add x to any element in array, subtract x from any element from array, do nothing.

 This operation can be performed only once on an element of array.



Problem Constraints
1<=|A|<=1e5
1<=A[i],x<=1e9


Input Format
First argument is array of integers .
Second argument is B which denotes the value of x.


Output Format
Return 1 if we can make all elements equal , otherwise return 0.


Example Input
Input 1:
A=[2,3,1]
X=1
Input 2:

A=[2,3,1]
X=2


Example Output
Ouput 1:
1
Ouput 2:

0


Example Explanation
Explanation 1:
WE can make all elements equal to 2.
Explanation 2:

There is no way to make all elements equal to 0.
","bool check(vector<int> v, int x, int y) {
    for(auto i: v) {
        if(i-x==y || i+x==y || i==y) {}
        else return false;
    }
    return true;
}
int Solution::solve(vector<int> &A, int B) {
    int n;
    n=A.size();
    vector<int> v=A;
    
    int x; x=B;
    if(check(v,x,v[0]) || check(v,x,v[0]-x) || check(v,x,v[0]+x)) return 1;
    else return  0;
    
}"
Segregate 0s and 1s in an array,https://www.interviewbit.com/problems/segregate-0s-and-1s-in-an-array/,N/A,Arrays,medium,"Problem Description
 
 


You are given an array of 0s and 1s in random order. Segregate 0s on left side and 1s on right side of the array [Basically you have to sort the array]. Traverse array only once. 



Problem Constraints
1<=|A|<=1e6


Input Format
First argument is array of integers consisting of 0's and 1's only.


Output Format
Return a sorted array.


Example Input
Input 1:
a=[0 1 0]
Input 2:

A=[1 1 0 ]


Example Output
Ouput 1:
[0 0 1]
Ouput 2:

[0 1 1]


Example Explanation
Explanation 1:
 above is sorted array.
Explanation 2:

sort the array.","vector<int> Solution::solve(vector<int> &A) {
    int a=0;
    vector<int>B(A.size(),1);
    for(int i = 0; i < A.size(); ++i){
        if(A[i] == 0){
            B[a] = 0;
            ++a;
        }
    }
    return B;
}"
Connect Ropes,https://www.interviewbit.com/problems/connect-ropes/,N/A,Heaps And Maps,medium,"Problem Description
 
 

Given an array of integers A representing the length of ropes.

You need to connect these ropes into one rope. The cost of connecting two ropes is equal to the sum of their lengths.

Find and return the minimum cost to connect these ropes into one rope.



Problem Constraints
1 <= length of the array <= 100000

1 <= A[i] <= 1000



Input Format
The only argument given is the integer array A.



Output Format
Return an integer denoting the minimum cost to connect these ropes into one rope.



Example Input
Input 1:

 A = [1, 2, 3, 4, 5]
Input 2:

 A = [5, 17, 100, 11]


Example Output
Output 1:

 33
Output 2:

 182


Example Explanation
Explanation 1:

 Given array A = [1, 2, 3, 4, 5].
 Connect the ropes in the following manner:
 1 + 2 = 3
 3 + 3 = 6
 4 + 5 = 9
 6 + 9 = 15


So, total cost  to connect the ropes into one is 3 + 6 + 9 + 15 = 33.

Explanation 2:

 Given array A = [5, 17, 100, 11].
 Connect the ropes in the following manner:
 5 + 11 = 16
 16 + 17 = 33
 33 + 100 = 133


So, total cost  to connect the ropes into one is 16 + 33 + 133 = 182.
","int Solution::solve(vector < int > & A) {

    priority_queue < int, vector < int > , greater < int >> pq;

    int cost = 0;

    // insert all elements in the queue
    for (int x: A) {
        pq.push(x);
    }

    // keep on removing elements from the queue untill there is one element in the queue
    while (pq.size() != 1) {

        // Take the two ropes with smallest length
        int l1 = pq.top();
        pq.pop();
        int l2 = pq.top();
        pq.pop();

        // cost of combining these two ropes is l1 + l2.
        cost += l1 + l2;

        // add the newly formed rope of length l1 + l2 to the queue.
        pq.push(l1 + l2);
    }

    return cost;
}"
Capacity To Ship Packages Within B Days,https://www.interviewbit.com/problems/capacity-to-ship-packages-within-b-days/,Amazon,Binary Search,medium,"Problem Description
 
 

A conveyor belt has packages that must be shipped from one port to another within B days.

The ith package on the conveyor belt has a weight of A[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship.

Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within B days.



Problem Constraints
1 <= B <= |A| <= 5 * 105
1 <= A[i] <= 105


Input Format
First argument is array of integers A denoting the weights.

Second argument is the integer B denoting the number of days. 



Output Format
Return the least weight capacity of the ship.


Example Input
Input 1:
A = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
B = 5
Input 2:

A = [3, 2, 2, 4, 1, 4]
B = 3


Example Output
Ouput 1:
15
Ouput 2:

6


Example Explanation
Explanation 1:
A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:
1st day: 1, 2, 3, 4, 5
2nd day: 6, 7
3rd day: 8
4th day: 9
5th day: 10
Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and 
splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.
Explanation 2:

A ship capacity of 6 is the minimum to ship all the packages in 3 days like this:
1st day: 3, 2
2nd day: 2, 4
3rd day: 1, 4","bool check(vector<int>&weights,int x, int days) {
        int cnt=0;
        int day=0;
        for(auto i: weights) {
            if(cnt+i<=x) cnt+=i; 
            else day++, cnt=i;
        }
        if(day<days) return true;
        return false;
    }
int Solution::solve(vector<int> &weights, int days) {
    int start=1;
    int end=1e9;
    for(auto i: weights) start=max(start,i);
    while(1)
    {
        int mid=(start+end)/2;
        if(check(weights,mid,days)) end=mid;
        else start=mid;
        if(end-start<=1) break;
    }
    if(check(weights,start,days)) return start;
    else return end;
}"
Bulls and Cows,https://www.interviewbit.com/problems/bulls-and-cows/,Amazon,Strings,medium,"Problem Description
 
 

 You are playing the Bulls and Cows game with your friend.

You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:

The number of ""bulls"", which are digits in the guess that are in the correct position.
The number of ""cows"", which are digits in the guess that are in your secret number but are located in the wrong position. 
Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls. 
Given the secret number secret and your friend's guess guess, return the hint for your friend's guess.

The hint should be formatted as ""xAyB"", where x is the number of bulls and y is the number of cows. Note that both secret and guess may contain duplicate digits.



Problem Constraints
1 <= secret.length, guess.length <= 100000
secret.length == guess.length
secret and guess consist of digits only.


Input Format
First argument is string denoting secret string 


Second argument is string denoting guess string 



Output Format
Return the hint for you friend's guess.


Example Input
Input 1:
secret = ""1807"", guess = ""7810""
Input 2:

secret = ""1123"", guess = ""0111""


Example Output
Ouput 1:
""1A3B""
Ouput 2:

""1A1B""


Example Explanation
Explanation 1:
Bulls are connected with a '|':
""1807""
  |
""7810""
Explanation 2:

Bulls are connected with a '|' 
""1123""        ""1123""
  |      or     |
""0111""        ""0111""
Note that only one of the two unmatched 1s is counted as a cow since 
the non-bull digits can only be rearranged to allow one 1 to be a bull.
","string Solution::solve(string secret, string guess) {
    int bull=0;
    int arr[10]={0};
    for(int i=0;i<secret.size();i++) {
        if(secret[i]==guess[i]) arr[guess[i]-'0']--, bull++;
        arr[guess[i]-'0']++;
    }
    int cow=0;
    int j=0;
    for(auto i: secret) {
        if(i!=guess[j++] && arr[i-'0']>0) cow++, arr[i-'0']--;
    }
    string s=to_string(bull) + ""A"" + to_string(cow) + ""B"";
    return s;
    
}"
Construct BST from Preorder,https://www.interviewbit.com/problems/construct-bst-from-preorder/,N/A,Tree Data Structure,medium,"Problem Description
 
 

Given an integer array A with distinct elements, which represents the preorder traversal of a binary search tree,
 
construct the tree and return its root.

A binary search tree is a binary tree where for every node, any descendant of Node.left has a value strictly less than Node.val, and any descendant of Node.right has a value strictly greater than Node.val.

A preorder traversal of a binary tree displays the value of the node first, then traverses Node.left, then traverses Node.right.



**Problem Constraints**
1 <= |A| <= 105
1 <= A.val <= 109
The given array is a valid preorder traversal of a BST.


**Input Format**
The first argument is an integer array denoting the preorder traversal.


**Output Format**
Return the root of the Binary Search Tree.


**Example Input**
Input 1:
A = [2, 1, 4, 3, 5]
Input 2:

A = [1, 2, 3]


**Example Output**
Output 1:
    2
   / \
  1   4
     / \
    3   5
Output 2:

      1
     /
    2
   /
  3


**Example Explanation**
Explanation 1:
We can see that is the tree created by the given pre order traversal.
Explanation 2:

We can see that is the tree created by the given pre order traversal.
","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
int n, idx = 0;
vector<int> pre;
TreeNode* helper(int lower, int upper) {
    if (idx == n) 
        return NULL;
    int val = pre[idx];
    if (val < lower || val > upper) 
        return NULL;
    idx++;
    TreeNode* root = new TreeNode(val);
    root->left = helper(lower, val);
    root->right = helper(val, upper);
    return root;
}
TreeNode* Solution::constructBST(vector<int> &A) {
    pre = A;
    n = A.size();
    idx = 0;
    return helper(-2000000000, 2000000000);
}"
Covered / Uncovered Nodes,https://www.interviewbit.com/problems/covered-uncovered-nodes/,Amazon,Tree Data Structure,medium,"Problem Description
 
 

You are given the root of a binary tree A, you need to return the absolute difference between sum of all covered elements and the sum of all uncovered elements.

In a binary tree, a node is called Uncovered if it appears either on left boundary or right boundary. Rest of the nodes are called covered.



Problem Constraints
1 <= Number of nodes in the binary tree <= 105


Input Format
The first argument is the root of the binary tree A.


Output Format
Return a single integer denoting the absolute difference of the sum of covered and uncovered nodes.


Example Input
Input 1:
    2
   / \
  1   4
 /   / \
6  10   5
Input 2:

      1
     /
    2
   /
  3


Example Output
Output 1:
8
Output 2:

6


Example Explanation
Explanation 1:
The node with value 10 is the only covered node. All other nodes are uncovered.
Therefore, the absolute difference is |(10) - (2 + 1 + 4 + 6 + 5)| = 8
Explanation 2:

All the given nodes are uncovered. Hence, the answer is sum of given nodes - 6.
","long Solution::coveredNodes(TreeNode * A) {
    long cover = 0, uncover = 0;
    queue < TreeNode * > q;
    q.push(A);
    int level = 0;
    while (!q.empty()) {
        int n = q.size();
        for (int i = 0; i < n; i++) {
            TreeNode * node = q.front();
            q.pop();
            if (i == 0 || i == n - 1) {
                uncover += node -> val;
            } else {
                cover += node -> val;
            }
            if (node -> left != NULL)
                q.push(node -> left);
            if (node -> right != NULL)
                q.push(node -> right);
        }
    }
    return abs(cover - uncover);
}"
Self Permutation,https://www.interviewbit.com/problems/self-permutation/,N/A,Strings,medium,"Problem Description
 
 

You are given two strings A and B.
Check whether there exists any permutation of both A and B such that they are equal.

Return a single integer 1 if its exists, 0 otherwise.



Problem Constraints
1 <= |A|, |B| <= 105
Both strings contain only lowercase english alphabets.


Input Format
The first argument is the string A. The second argument is the string B.


Output Format
Return a single integer 1 if a permutation exists, 0 otherwise.


Example Input
Input 1:
A = 'scaler'
B = 'relasc'
Input 2:

A = 'scaler'
B = 'interviewbit'


Example Output
Output 1:
1
Output 2:

0


Example Explanation
Explanation 1:
We can rearrange the second string to 'scaler', hence, a permuation exists.
Explanation 2:

The given length of the two strings itself is different. There is no possible permutation.
","int Solution::permuteStrings(string A, string B) {
    assert(A.size() >= 1 && A.size() <= 1e5);
    for(auto &x : A) assert(x >= 97 && x <= 122);
    assert(B.size() >= 1 && B.size() <= 1e5);
    for(auto &x : B) assert(x >= 97 && x <= 122);
    vector<int> freq(26);
    for (int i = 0; i < A.size(); i++)
        freq[A[i] - 97]++;
    for (int i = 0; i < B.size(); i++)
        freq[B[i] - 97]--;
    for (int i = 0; i < 26; i++) {
        if (freq[i] != 0) {
            return 0;
        }
    }
    return 1;
}"
Potions,https://www.interviewbit.com/problems/potions/,Amazon,Dynamic Programming,medium,"Problem Description
 
 

You are given N potions arranged in a row in the form of an array A.

Each potion has one of 100 different colors (colors have numbers from 0 to 99).

You need to mix all these potions together.
 
At each step, you are going to take two potions that stand next to each other and mix them together,
 
and put the resulting mixture in their place.

When mixing two mixtures of colors X and Y, the resulting mixture will have the color (X + Y) mod 100.

Also, there will be some smoke in the process. The amount of smoke generated when mixing two mixtures of colors X and Y is X * Y.

Find out what is the minimum amount of smoke that you can get when mixing all the potions together.



Problem Constraints
1 <= N <= 100
0 <= Ai <= 99


Input Format
The first argument is the integer array A.


Output Format
Return a single integer denoting the minimum amount of smoke.


Example Input
Input 1:
A = [2, 3]
Input 2:

A = [2, 3, 4, 5]


Example Output
Output 1:
6
Output 2:

71


Example Explanation
Explanation 1:
There are only two potions given. Upon mixing them, we get 2 * 3 = 6 amounts of smoke.
Explanation 2:

Out of all the possible order of operations of mixing the given potions, the minimum amount of smoke you can get is 71.","int Solution::minSmoke(vector < int > & A) {
    
    int n = A.size();
    assert(n>=1 && n<=100);
    
    for(auto i:A) assert(i>=0 && i < 100);
    long sum[n][n], dp[n][n];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            sum[i][j] = 0;
            dp[i][j] = 0;
        }
    }
    for (int i = 0; i < n; i++) {
        sum[i][i] = A[i];
    }
    for (int len = 2; len <= n; len++) {
        for (int i = 0; i < n - len + 1; i++) {
            int j = i + len - 1;
            long min = 1 << 30;
            for (int k = i; k <= j - 1; k++) {
                long temp = dp[i][k] + dp[k + 1][j] + (sum[i][k] * sum[k + 1][j]);
                if (temp < min) {
                    sum[i][j] = (sum[i][k] + sum[k + 1][j]) % 100;
                    min = temp;
                    dp[i][j] = min;
                }
            }
        }
    }
    return (int) dp[0][n - 1];
}"
Last Node in a Complete Binary Tree,https://www.interviewbit.com/problems/last-node-in-a-complete-binary-tree/,Flipkart,Tree Data Structure,medium,"Problem Description
 
 

You are given the root of a complete binary tree A.

You have to return the value of the rightmost node in the last level of the binary tree.

Try to find a solution with a better time complexity than O(N).



Problem Constraints
1 <= Number of nodes in the binary tree <= 105


Input Format
The first argument is the root of a binary tree A.


Output Format
Return a single integer denoting the value of the rightmost node in the last level of the binary tree.


Example Input
Input 1:
A = 
    1
   /
  2
Input 2:

A = 
    1
   / \
  2   3


Example Output
Output 1:
2
Output 2:

3


Example Explanation
Explanation 1:
There is only a single node in the last level of the binary tree.
Therefore, the answer is 2.
Explanation 2:

There a two nodes in the last level of the tree.
The rightmost nodes is 3.
","int getHeight(TreeNode * root) {
    int c = 0;
    while (root != NULL) {
        c++;
        root = root -> left;
    }
    return c;
}
int Solution::lastNode(TreeNode * A) {
    int h = getHeight(A);
    if (h == 1)
        return A -> val;
    else if ((h - 1) == getHeight(A -> right))
        return lastNode(A -> right);
    else return lastNode(A -> left);
}"
Array Sum,https://www.interviewbit.com/problems/array-sum/,Paytm,Arrays,medium,"Problem Description
 
 

You are given two numbers represented as integer arrays A and B, where each digit is an element.
 You have to return an array which representing the sum of the two given numbers.

The last element denotes the least significant bit, and the first element denotes the most significant bit.

Note : Array A and Array B can be of different size. ( i.e. length of Array A may not be equal to length of Array B ).



Problem Constraints
1 <= |A|, |B| <= 105
0 <= Ai, Bi <= 9


Input Format
The first argument is an integer array A. The second argument is an integer array B.


Output Format
Return an array denoting the sum of the two numbers.


Example Input
Input 1:
A = [1, 2, 3]
B = [2, 5, 5]
Input 2:

A = [9, 9, 1]
B = [1, 2, 1]


Example Output
Output 1:
[3, 7, 8]
Output 2:

[1, 1, 1, 2]


Example Explanation
Explanation 1:
Simply, add all the digits in their place.
Explanation 2:

991 + 121 = 1112
Note that the resultant array size might be larger.
","vector<int> sum(vector<int> &A, vector<int> &B, int n, int m){
    vector<int> ans; 
    int i = n - 1, j = m - 1;
    int carry = 0, s = 0;
    while (j >= 0) {
        s = A[i] + B[j] + carry;
        ans.push_back(s % 10);
        carry = s / 10;
        i--;
        j--;
    }
    while (i >= 0) {
        s = A[i] + carry;
        ans.push_back(s % 10);
        carry = s / 10;
        i--;
    }
    if (carry>0){
        ans.push_back(carry);
    }
    reverse(ans.begin(), ans.end());
    return ans;
}
vector<int> Solution::addArrays(vector<int> &A, vector<int> &B) {
    int n = A.size();
    int m = B.size();
    if (n >= m)
        return sum(A, B, n, m);
    else
        return sum(B, A, m, n);
}"
Mother Vertex,https://www.interviewbit.com/problems/mother-vertex/,Paytm,Graph Data Structure & Algorithms,medium,"Problem Description
 
 

You are given a directed graph with A vertices and M edges.

You are given an array B with dimensions M x 2, where each row denotes a directed edge from Bi, 0 to Bi, 1.

You need to find if there exists a mother vertex in the given graph. Return 1 if it exists, otherwise 0.

A mother vertex is defined as a vertex from which all the vertices in the graph are accessible by a directed path.



Problem Constraints
1 <= A <= 105
1 <= M <= 2 * 105
1 <= Bi, 0, Bi, 1 <= A
There can be duplicate edges or self loops in the input graph.


Input Format
The first argument is the integer A. The second argument is the 2D integer array B.


Output Format
Return a single integer 1 if a mother vertex exists, otherwise 0.


Example Input
Input 1:
A = 3
B = [[1, 3], [2, 3], [1, 3]]
Input 2:

A = 3
B = [[1, 3], [2, 3], [3, 2]]


Example Output
Output 1:
0
Output 2:

1


Example Explanation
Explanation 1:
There is no vertex from which all the other vertices are accessible.
Note there can be duplicate edges.
Explanation 2:

Vertex 1 is the mother vertex. We can reach 2 using 1 -> 3 -> 2. We can reach 3 using 1 -> 3","vector < vector < int >> adj;
void DFS(int src, vector < bool > & vis) {
    vis[src] = true;
    for (auto &x: adj[src]) {
        if (!vis[x]) {
            DFS(x, vis);
        }
    }
}
int Solution::motherVertex(int A, vector < vector < int > > & B) {
    adj.clear();
    adj.resize(A + 1);
    vector < bool > vis(A + 1), check(A + 1);
    for (int i = 0; i < B.size(); i++) {
        adj[B[i][0]].push_back(B[i][1]);
    }
    int mother = 0;
    for (int i = 1; i <= A; i++) {
        if (!vis[i]) {
            mother = i;
            DFS(i, vis);
        }
    }
    DFS(mother, check);
    for (int i = 1; i <= A; i++) {
        if (!check[i])
            return 0;
    }
    return 1;
}"
Dice Throw,https://www.interviewbit.com/problems/dice-throw/,N/A,Dynamic Programming,medium,"Problem Description
 
 

You are given A dices with faces numbered from 1 to B.

You have to find out the number of ways to get to sum C.

Since, the number can be large, output the answer modulo 109 + 7.



Problem Constraints
1 <= A, B, C <= 103


Input Format
The first argument is the integer A.
The second argument is the integer B.
The third argument is the integer C.


Output Format
Return a single integer denoting the number of ways to get to the required sum modulo 109 + 7.


Example Input
Input 1:
A = 2
B = 4
C = 5
Input 2:

A = 2
B = 4
C = 1


Example Output
Output 1:
4
Output 2:

0


Example Explanation
Explanation 1:
There are 4 different ways to arrange the dices - [1, 4], [2, 3], [3, 2], [4, 1].
Explanation 2:

Since, the dices are numbered from 1. 2 dices will have the minimum sum of 2. 
Therefore, there are zero ways to get to sum 1.
","int Solution::findDiceSum(int A, int B, int C) {
    long dp[A + 1][C + 1];
    long mod = (long) 1e9 + 7;
    for (int i = 0; i <= A; i++)
        for (int j = 0; j <= C; j++)
            dp[i][j] = 0;
    dp[0][0] = 1;
    for (int i = 1; i <= A; i++) {
        for (int j = i; j <= C; j++) {
            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j - 1]) % mod;
            if (j - B - 1 >= 0)
                dp[i][j] = (dp[i][j] - dp[i - 1][j - B - 1] + mod) % mod;
        }
    }
    return (int) dp[A][C];
}"
Set Intersection,https://www.interviewbit.com/problems/set-intersection/,Uber,Arrays,medium,"Problem Description
 
 

An integer interval [X, Y] (for integers X < Y) is a set of all consecutive integers from X to Y, including X and Y.

You are given a 2D array A with dimensions N x 2, where each row denotes an interval.

Find the minimum size of a set S such that for every integer interval Z in A, the intersection of S with Z has a size of at least two.



Problem Constraints
1 <= N <= 105
1 <= A[i][0] < A[i][1] <= 109


Input Format
The first argument is a 2D integer array A.


Output Format
Return a single integer denoting the minimum size of S.


Example Input
Input 1:
A = [[1, 3], [1, 4], [2, 5], [3, 5]]
Input 2:

A = [[1, 2], [2, 3], [2, 4], [4, 5]]


Example Output
Output 1:
3
Output 2:

5


Example Explanation
Explanation 1:
Consider the set S = {2, 3, 4}.  For each interval, there are at least 2 elements from S in the interval.
Also, there isn't a smaller size set that fulfills the above condition.
Thus, we output the size of this set, which is 3.
Explanation 2:

An example of a minimum sized set is {1, 2, 3, 4, 5}.","bool comp(const vector < int > & A,
    const vector < int > & B) {
    if (A[1] != B[1])
        return A[1] < B[1];
    return A[0] < B[0];
}
int Solution::setIntersection(vector < vector < int > > & A) {
    int n = A.size();
    sort(A.begin(), A.end(), comp);
    vector < int > res;
    res.push_back(A[0][1] - 1);
    res.push_back(A[0][1]);
    for (int i = 1; i < n; i++) {
        int start = A[i][0];
        int end = A[i][1];
        int size = res.size();
        int last = res[size - 1];
        int secondLast = res[size - 2];
        if (start > last) {
            res.push_back(end - 1);
            res.push_back(end);
        } else if (start == last) {
            res.push_back(end);
        } else if (start > secondLast) {
            res.push_back(end);
        }
    }
    return res.size();
}"
Find Variance,https://www.interviewbit.com/problems/find-variance/,Amazon,Descriptive Statistics,easy,"Problem Description

Given an array A containing N integers, find the variance of the array. Return your answer up to 2 decimal points.


Problem Constraints

1 <= N <= 1000 1 <= A[i] <= 1000


Input Format

First argument is an integer, N, denoting the length of the input array Second line consists of N elements, separated by space


Output Format

Return a float value as specified in the question


Example Input

Input 1: N = 10 A = [99, 81, 4, 74, 9, 79, 45, 25, 44, 86]


Example Output

Output 1: 1034.64


Example Explanation

Mean = 54.6, simply apply the formula of variance to get 1034.64
","string Solution::solve(vector<int> &A) {

    double st = 0;

    double n = A.size();

    for(int i=0; i<n; i++)

        st += A[i];

    double mean = st/n;

    st=0;

    for(auto x:A)

        st += pow(x-mean,2);

    st /= n;

    

    // For rounding off

    st *= 100;

    st = round(st);

    string s = to_string(st/100);

    size_t p = s.find('.');

    return s.substr(0,p+3);

}"
Distribution Percentage,https://www.interviewbit.com/problems/distribution-percentage/,Amazon,Probability,easy,"What percentage of values lies between Mean and one Standard deviation(both positive and negative) in a normal distribution?98
65
68
50
95",N/A
Median over mean,https://www.interviewbit.com/problems/median-over-mean/,Google,Descriptive Statistics,easy,"In what situation would you consider median over mean as the representative of the distribution?When the data size is very large
When the data is negative
When the data is lesser in number
When the data contains outliers
None of these",When the dataset contains outliers the mean will be affected in the wrong way and won’t be the right representative therefore its better to use median.
Probability of Raining,https://www.interviewbit.com/problems/probability-of-raining/,Microsoft,Probability,easy,"You asked your three friends whether it will rain or not and all three affirmed for rain. All three have the probability of 1/3 of lying. What is the probability that it will actually rain?¼
?
½
?
None of these","Ask for the probability of raining first as a follow up, taken as pr

According to conditional probability   p(rain | (yyy))=(p({yyy} | rain).pr)/(p({yyy} | rain)pr + p({yyy} | no rain)pn)=(8pr)/(7pr+1)"
How can he win?,https://www.interviewbit.com/problems/how-can-he-win/,N/A,Probability,easy,"Anshul and Deven take turns in rolling a fair six-sided die. Whoever rolls a “6” first wins the game. Deven starts by rolling first. What’s the probability that Anshul wins?5/11
6/11
10/11
1/2
1/6","Probability of a candidate’s win=1/6 ;          

Probability of candidate losing =1-1/6=5/6;          

Probability of Anshul winning on his first turn=(5/6)(1/6)

Probability of Anshul winning on his second turn=(5/6)(5/6)(5/6)(1/6) and so on

therefore the total probability of Anshul winning would be=5/36 + 125/1296+….

its a GP with sum=5/11"
White Marble Probability,https://www.interviewbit.com/problems/white-marble-probability/,Snapdeal,Probability,easy,"There are 6 marbles in a bag and only one of them is white. You are allowed to draw a marble from the bag 100 times. After drawing a marble, it is placed back in the bag. What is the probability of drawing the white marble at least once??
?
(?)^100
1 - (?)^100
Insufficient Information",P(not drawing white in a turn)= 5/6 P(not drawing white not in any of the 100 turns)=(5/6)100 Therefore P(drawing the white at least once)= 1-(5/6)100
Boy or girl paradox,https://www.interviewbit.com/problems/boy-or-girl-paradox/,Paypal,Probability,easy,"Supposedly a friend of yours has 2 children and at least one of them is a boy. What is the probability that the other is also a boy?1/2
1/3
1/6
2/5
2/3","If at least one is a boy, there are three possible equally likely gender assignations of two siblings. boy-boy, boy-girl,

 or girl-boy. Only 1 in 3 cases or 33 percent are both boys. The lesson here is that when considering equally likely scenarios

 we must consider birth order. If the birth order of the boy is not specified – i.e. if we don’t know if he is the eldest or 

 the youngest – the probability of two boys drops to 1 in 3."
Positive Test Probability,https://www.interviewbit.com/problems/positive-test-probability/,N/A,Probability,easy,"A test has a true positive rate of 100% and a false-positive rate of 5%. There is a population with a 1/1000 rate of having the condition the test identifies. Considering a positive test, what is the probability of having that condition?0.02
0.1
0.05
0.9
0.5","p(A) = 0.001 (This is given in the problem.)

p(notA) = 0.999 (How? You compute this from knowing that p(A) = 0.001)

p(B | notA) = 0.05 This is given to you in the problem.

p(B | A) = 1.00 This, too, is given in the problem.

So: p(A| B) 

= (1.00 x 0.001)/((0.0001 x 1) + (0.05 x 0.999))

= 0.01998 = 0.02

So p(A| B) is approximately 0.02"
Divisible by 60,https://www.interviewbit.com/problems/divisible-by-60/,Flipkart,Math,medium,"Problem Description
 
 

Given a large number represent in the form of an integer array A, where each element is a digit.

You have to find whether there exists any permutation of the array A such that the number becomes divisible by 60.

Return 1 if it exists, 0 otherwise.



Problem Constraints
1 <= |A| <= 105
0 <= Ai <= 9


Input Format
The first argument is an integer array A.


Output Format
Return a single integer '1' if there exists a permutation, '0' otherwise.


Example Input
Input 1:
A = [0, 6]
Input 2:

A = [2, 3]


Example Output
Output 1:
1
Output 2:

0


Example Explanation
Explanation 1:
We can rearrange the digits to form 60, which is divisible by 60.
Explanation 2:

There are only two possible permutations: [23, 32].
Both of them are not divisible by 60.
","int Solution::divisibleBy60(vector < int > & A) {
    bool f0 = false, f2 = false;
    int sum = 0;
    if(A.size() == 1 && A[0] == 0)
        return 1;
    for (int i = 0; i < A.size(); i++) {
        sum += A[i];
        if (A[i] == 0) {
            f0 = true;
        } else if (A[i] % 2 == 0) {
            f2 = true;
        }
    }
    if (sum % 3 == 0 && f0 && f2)
        return 1;
    else return 0;
}"
Powerful Divisors,https://www.interviewbit.com/problems/powerful-divisors/,N/A,Math,hard,"Problem Description
 
 

You are given an integer array A of length N.

For every integer X in the array, you have to find out the number of integers Y, 
such that 1 <= Y <= X, and the number of divisors of Y is a power of 2.

For example, 6 has the following divisors - [1, 2, 3, 6]. This is equal to 4, which is a power of 2.

On the other hand, 9 has the following divisors [1, 3, 9] which is 3, which is not a power of 2.

Return an array containing the answer for every X in the given array.



Problem Constraints
1 <= N <= 105
1 <= Amax <= 106
Sum of Amax over all test cases will not exceed 5 * 106


Input Format
The first argument is the integer array A.


Output Format
Return an array containing the answer for every X in the given array.


Example Input
Input 1:
A = [1, 4]
Input 2:

A = [5, 10]


Example Output
Output 1:
[1, 3]
Output 2:

[4, 8]


Example Explanation
Explanation 1:
The numbers 1, 2, 3 have the required number of divisors.
Explanation 2:

Only 4 and 9 are the numbers less than or equal to 10 which do not have the required number of divisors.
","vector < int > Solution::powerfulDivisors(vector < int > & A) {
    int maxn = 1;
    for (int i = 0; i < A.size(); i++) {
        maxn = max(maxn, A[i]);
    }
    vector < int > div(maxn + 1);
    for (int i = 1; i <= maxn; i++) {
        for (int j = i; j <= maxn; j += i) {
            div[j]++;
        }
    }
    vector < int > count(maxn + 1);
    count[1] = 1;
    for (int i = 2; i <= maxn; i++) {
        int x = div[i];
        if (x == (-x & x))
            count[i] = 1;
    }
    for (int i = 2; i <= maxn; i++) {
        count[i] += count[i - 1];
    }
    vector < int > ans(A.size());
    for (int i = 0; i < ans.size(); i++) {
        ans[i] = count[A[i]];
    }
    return ans;
}"
Path in Matrix,https://www.interviewbit.com/problems/path-in-matrix/,Amazon,Graph Data Structure & Algorithms,medium,"Problem Description
 
 

Given N x N matrix filled with 0, 1, 2, 3.

Find whether there is a path possible from source to destination, traversing through blank cells only. 
 
You can traverse up, down, right, and left. Return a single integer 1 if a path exists, otherwise 0.

A value of cell 1 means Source.
A value of cell 2 means Destination.
A value of cell 3 means Blank cell.
A value of cell 0 means Blank Wall.
Note: there are an only a single source and single destination(sink).


Problem Constraints
2 <= N <= 103
0 <= Ai, j <= 3


Input Format
The first argument is the 2D integer array A.


Output Format
Return a single integer 1 if a path exists, otherwise 0.


Example Input
Input 1:
A = [[1, 0], [0, 2]]
Input 2:

A = [[1, 3], [3, 2]]


Example Output
Output 1:
0
Output 2:

1


Example Explanation
Explanation 1:
The source is blocked by walls on all its sides. So, there is no way to reach the destination.
Explanation 2:

We can take any possible path to reach the destination from the source.
","void dfs(int i, int j, int n, int p, int q, vector<vector<int>> &visited, int x[], int y[], vector<vector<int> > &A, bool &found){
    visited[i][j]=1;
    if(i==p && q==j)
        found=true;
    if(found)
        return;
    for(int k=0;k<4;k++){
        int ni=i+x[k];
        int nj=j+y[k];
        if(ni>=0 && nj>=0 && ni<n && nj<n)
            if(!visited[ni][nj] && A[i][j]!=0)
                dfs(ni,nj,n,p,q,visited,x,y,A,found);
            
    }
}
int Solution::checkPath(vector<vector<int> > &A) {
    int n=A.size();
    vector<vector<int>> visited(n,vector<int>(n,0));
    int x[4]={0,1,0,-1};
    int y[4]={1,0,-1,0};
    int l,h,c=0,p,q;
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            if(A[i][j]==1){
                l=i;
                h=j;
                c++;
            }
            else if(A[i][j]==2){
                p=i;
                q=j;
                c++;
            }
            else if(c==2)
                break;
            
        }
    }
    bool found=false;
    dfs(l,h,n,p,q,visited,x,y,A,found);
    return visited[p][q];
}"
Consecutive Parent - Child,https://www.interviewbit.com/problems/consecutive-parent-child/,N/A,Tree Data Structure,medium,"Problem Description
 
 

You are given the root of a binary tree A.
You have to find out the number of parent - child relationship whose values are consecutive numbers.



Problem Constraints
1 <= Number of nodes in the tree <= 105


Input Format
The first argument is the root of the binary tree A.


Output Format
Return a single integer denoting the number of consecutive parent - child relationships.


Example Input
Input 1:
A =  2
    / \
   1   3
Input 2:

A =  5
    / \
   1   3
      / \
     1   4


Example Output
Output 1:
2
Output 2:

1


Example Explanation
Explanation 1:
(2, 1) and (2, 3) are the consecutive parent - child relationships.
Explanation 2:

(3, 4) is the only consecutive parent - child relationship.
","/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
int ans;
void rec(TreeNode* A){
    if(A -> left != NULL){
        if(abs(A -> val - A -> left -> val) == 1){
            ans++;
        }
        rec(A -> left);
    }
    if(A -> right != NULL){
        if(abs(A -> val - A -> right -> val) == 1){
            ans++;
        }
        rec(A -> right);
    }
}
int Solution::consecutiveNodes(TreeNode* A) {
    ans = 0;
    rec(A);
    return ans;
}"
Addition without Summation,https://www.interviewbit.com/problems/addition-without-summation/,Adobe,Math,medium,"Problem Description
 
 

You are given two numbers A and B.

You have to add them without using arithmetic operators and return their sum.



Problem Constraints
1 <= A, B <= 109


Input Format
The first argument is the integer A. The second argument is the integer B.


Output Format
Return a single integer denoting their sum.


Example Input
Input 1:
A = 3
B = 10
Input 2:

A = 6
B = 1


Example Output
Output 1:
13
Output 2:

7


Example Explanation
Explanation 1:
3 + 10 = 13
Explanation 2:

6 + 1 = 7.
Note, you have to add without using arithmetic operators.
","int Solution::addNumbers(int A, int B) {
    while (B != 0) {
        int carry = A & B;
        A = A ^ B;
        B = carry << 1;
    }
    return A;
}"
Hotel Service,https://www.interviewbit.com/problems/hotel-service/,N/A,Stacks And Queues,medium,"Problem Description
 
 

You are travelling to Neverland. After a long journey, you decided to take rest in a hotel for a night.

You have the map of Neverland in the form of 2D matrix A with dimensions N x M. 

The rows are numbered from 1 to N, and the columns are numbered from 1 to M.

You can travel from one cell to any adjacent cell. Two cells are considered adjacent if they share a side.

In the map, there are only two digits, 0 and 1, 
where 1 denotes a hotel in that cell, and 0 denotes an empty cell.

You are also given another 2D array B with dimension Q x 2,
 
where each row denotes a co-ordinate (X, Y) on the map (1 - indexed). 
For each coordinate you have to find the distance to the nearest hotel.

Return an array denoting the answer to each coordinate in the array B.



**Problem Constraints**
1 <= N, M <= 103
1 <= Q <= 105
0 <= A[i][j] <= 1
1 <= B[i][0] <= N
1 <= B[i][1] <= M
There is guranteed to be atleast one hotel on the map.


**Input Format**
The first argument is the 2D integer array A.
The second argument is the 2D integer array B.


**Output Format**
Return an integer array denoting the answer to each coordinate in the array B.


**Example Input**
Input 1:
A = [[0, 0],
     [1, 0]]
B = [[1, 1],
     [2, 1],
     [1, 2]]
Input 2:

A = [[1, 0, 0 1]]
B = [[1, 2],
     [1, 3]]


**Example Output**
Output 1:
[1, 0, 2]
Output 2:

[1, 1]


**Example Explanation**
Explanation 1:
(1, 1) is adjacent to a hotel. (2, 1) has a hotel. (1, 2) is two cells away from the hotel on (2, 1).
Explanation 2:

(1, 2) is adjacent to a hotel on (1, 1). (1, 3) is adjacent to a hotel on (1, 4).
","vector < int > Solution::nearestHotel(vector < vector < int > > & A, vector < vector < int > > & B) {
    int n = A.size();
    int m = A[0].size();
    int inf = 1 << 30;
    int dis[n + 2][m + 2];
    for (int i = 0; i < n + 2; i++)
        for (int j = 0; j < m + 2; j++)
            dis[i][j] = 0;
    queue < pair < int, int >> q;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (A[i][j] == 0) {
                dis[i + 1][j + 1] = inf;
            } else {
                dis[i + 1][j + 1] = 0;
                q.push(make_pair(i + 1, j + 1));
            }
        }
    }
    while (!q.empty()) {
        pair curr = q.front();
        q.pop();
        int x = curr.first;
        int y = curr.second;
        if (dis[x][y + 1] == inf) {
            dis[x][y + 1] = dis[x][y] + 1;
            q.push(make_pair(x, y + 1));
        }
        if (dis[x][y - 1] == inf) {
            dis[x][y - 1] = dis[x][y] + 1;
            q.push(make_pair(x, y - 1));
        }
        if (dis[x + 1][y] == inf) {
            dis[x + 1][y] = dis[x][y] + 1;
            q.push(make_pair(x + 1, y));
        }
        if (dis[x - 1][y] == inf) {
            dis[x - 1][y] = dis[x][y] + 1;
            q.push(make_pair(x - 1, y));
        }
    }
    vector < int > ans;
    for (int i = 0; i < B.size(); i++) {
        ans.push_back(dis[B[i][0]][B[i][1]]);
    }
    return ans;
}"
Product probability,https://www.interviewbit.com/problems/product-probability/,N/A,Probability,easy,"If two random variables have a uniform probability distribution between 0 and 1, what is the probability that their product is less than 0.5 (approx.)?0.94
0.75
0.63
0.50
0.85","A quick way to go about it is to visualize a 2 dimensional plane. All the points (x,y) within the square [0,1]x[0,1] fall in the candidate space. The case when xy = 0.5 makes a curve

y=0.5/x,   The area under the curve would represent the cases for which xy <= 0.5 (shown shaded below). Since the area for the square is 1, that area is the sought probability.

The curve intersects the square at [0.5,1] and [1,0.5]. The area under the curve would the be sum of the 2 quadrants (1/4 each) along with the integral of y = 0.5/x under the range 0.5 to 1 yielding

=1/2 + int(0.5->1)(0.5/x)dx=0.85(approx)"
How much did he score?,https://www.interviewbit.com/problems/how-much-did-he-score/,N/A,Descriptive Statistics,easy,"During a cricket match, the mean score of the team was 100 with a standard deviation of 15. If Rahul’s z-score is 1.20, what was his score on the match?134
118
98
108
insufficient information","X= ?+Z? where ? is the mean, ? is the standard deviation and X is the score we’re calculating. 

Therefore X = 100+15*1.2 = 118"
Difference,https://www.interviewbit.com/problems/difference/,N/A,Descriptive Statistics,easy,"How does univariate analysis differ from bivariate analysis?Univariate analysis looks at the relationship between two variables, while bivariate analysis examines one variable.
Univariate analysis is a form of qualitative analysis, while bivariate analysis is a form of quantitative analysis.
Univariate analysis examines one variable, while bivariate analysis looks at the relationship between two variables.
Univariate analysis is a form of quantitative analysis, while bivariate analysis is a form of qualitative analysis.
None of these",N/A
What p-value represents?,https://www.interviewbit.com/problems/what-p-value-represents/,N/A,Inferential Statistics,easy,"The p-value in hypothesis testing represents which of the following: Please select the best answer of those provided below.The probability that the null hypothesis is true, given the observed results
The probability that the observed results are statistically significant, given that the null hypothesis is true
The probability of failing to reject the null hypothesis, given the observed results
The probability of observing results as extreme or more extreme than currently observed, given that the null hypothesis is true
None of the above",N/A
Are they equal?,https://www.interviewbit.com/problems/are-they-equal/,N/A,Inferential Statistics,easy,"The statement that “p(a/b)=p(b/a) whenever a and b are independent events” is Always true
Never true
Not enough information: the relative probability of these events should be known
Not enough information: the fact that whether they are disjoint events or not should be known
None of the above",N/A
Choose for the statement,https://www.interviewbit.com/problems/choose-for-the-statement/,N/A,Inferential Statistics,easy,"Assume that the difference between the observed, paired sample values is defined in the same manner and that the specified significance level is the same for both hypothesis tests. Using the same data, the statement that “a paired/dependent two-sample t-test is equivalent to a one-sample t-test on the paired differences, resulting in the same test statistic, same p-value, and same conclusion” isNever true
Always true
Sometimes true
Not enough information
None of the above",N/A
Which library it is?,https://www.interviewbit.com/problems/which-library-it-is/,N/A,Data Analysis,easy,"Which of the following is/are a/an open-source library and is present on Github?opencv
matplotlib
Numpy
Pandas
All of the above",N/A
What does the code do?,https://www.interviewbit.com/problems/what-does-the-code-do/,N/A,Data Analysis,easy,"What does the following do?

import urllib.request
reqfile = urllib.request.urlopen(‘http://data.pr4e.org/romeo.txt’)

for line in reqfile:

    print(line.decode().strip())It creates a file named 'romeo.txt' in 'data.pr4e.org'
It finds the urls linked to 'data.pr4e.org' and prints it
It opens a file named 'http://data.pr4e.org/romeo.txt' in local storage
It prints the contents of 'romeo.txt' after retrieving it from 'data.pr4e.org'",N/A
2d graphics,https://www.interviewbit.com/problems/2d-graphics/,N/A,Data Analysis,easy,"Which is a python package used for 2D graphics?matplotlib.pyplot
matplotlib.plt
matplotlib.plot
matplotlib.pip
matplotlib.numpy",N/A
Suitable plot type,https://www.interviewbit.com/problems/suitable-plot-type/,N/A,Data Analysis,easy,"Suitable plot typeBar graph
Scatter plot
Pie chart
Line chart
None of the above",N/A
Retrieval protocol,https://www.interviewbit.com/problems/retrieval-protocol/,N/A,Data Analysis,easy,"What protocol can be used to retrieve web pages using python?urllib
bs4
GET
HTTP
None of the above",N/A
2-way communication,https://www.interviewbit.com/problems/2-way-communication/,N/A,Data Analysis,easy,"What provides two-way communication between two different programs in a network?socket
port
http
protocol
None of the above",N/A
Search engine process,https://www.interviewbit.com/problems/search-engine-process/,N/A,Data Analysis,easy,"What is the process by which search engines retrieve webpages and build a search index called?Scrape
Parse
BeautifulSoup
Spider
None of the above",N/A
What does the code print?,https://www.interviewbit.com/problems/what-does-the-code-print/,N/A,Data Analysis,easy,"What does the following block of code print?

url = “https://www.ella.com/”

html = urllib.request.urlopen(url).read()

soup = BeautifulSoup(html, ‘html.parser’)

tags = soup(‘img’)

for tag in tags:

    print(tag.get(‘src’, None))downloads the webpage
prints the images from 'www.ella.com'
prints all the 'img' sources under 'src' from 'www.ella.com'
retrieves and displays the webpage",N/A
Correlation-analysis,https://www.interviewbit.com/problems/correlation-analysis/,N/A,Inferential Statistics,easy,"Correlation analysis is a ___univariate analysis
bivariate analysis
multivariate analysis for more than two variables
Both bivariate and multivariate analysis",N/A
Number of random samples,https://www.interviewbit.com/problems/number-of-random-samples/,N/A,Inferential Statistics,easy,"How many unique simple random samples are possible if you are asked to find 3 from a total of 15?1365
455
105
3003
None of the above","choose(15,3)"
CLT,https://www.interviewbit.com/problems/clt/,N/A,Inferential Statistics,easy,"What does the central limit theorem state?if the sample size increases sampling distribution must approach normal distribution
if the sample size decreases then the sample distribution must approach normal distribution
if the sample size increases then the sampling distribution much approach an exponential distribution
if the sample size decreases then the sampling distribution much approach an exponential distribution
None of the above",N/A
Team Selection,https://www.interviewbit.com/problems/team-selection/,N/A,Inferential Statistics,easy,"Under which sampling does the procedure of selection of FIFA World Cup team fall?Random
Purposive
Systematic
Cluster
None of the above",N/A
Chances to be spam,https://www.interviewbit.com/problems/chances-to-be-spam/,N/A,Probability,easy,"John receives emails that consist of 10% spam of those emails. The spam filter is 90% reliable i.e., 90% of the mails it marks as spam are actually spam and 90% of spam mails are correctly labeled as spam. If a mail is marked spam by her spam filter, determine the probability that it is really spam.50%
84%
40%
20%
60%","P[spam]=0.1, P[marked?spam]=0.9 and P[marked?no spam]=0.1 we find:

P[spam?marked]=P[spam?marked]/P[marked]

=P[marked?spam]P[spam]/(P[marked?spam]P[spam]+P[marked?no spam]P[no spam])

=0.9×0.1/(0.9×0.1+0.1×0.9)=0.5"
Probability of shares of a company,https://www.interviewbit.com/problems/probability-of-shares-of-a-company/,N/A,Probability,easy,"According to your research of publicly traded companies, 60% of the companies that increased their share price by more than 5% in the last three years replaced their CEOs during the period.

At the same time, only 35% of the companies that did not increase their share price by more than 5% in the same period replaced their CEOs. Knowing that the probability that the stock prices grow by more than 5% is 4%, find the probability that the shares of a company that fires its CEO will increase by more than 5%.6.67%
5.00%
5.55%
2.00%
10.50%","P(A) – the probability that the stock price increases by 5%

P(B) – the probability that the CEO is replaced

P(A|B) – the probability of the stock price increases by 5% given that the CEO has been replaced

P(B|A) – the probability of the CEO replacement given the stock price has increased by 5%.

Using the Bayes’ theorem, we can find the required probability:

P(A/B)=(0.60(0.04))/((0.60(0.04))+(0.35*(1-0.04)))=0.067=6.67%"
Normal random variable,https://www.interviewbit.com/problems/normal-random-variable/,N/A,Inferential Statistics,easy,"The formula to calculate standardized normal random variable isu = x ? ? / ?
u = x + ? / ?
u = x ? ? / ?
u = x + ? / ?",N/A
Standard deviation,https://www.interviewbit.com/problems/standard-deviation/,N/A,Probability,easy,"In binomial distribution, the formula for calculating standard deviation issquare root of p
square root of npq
square root of pq
square root of np",N/A
Distribution for discrete,https://www.interviewbit.com/problems/distribution-for-discrete/,N/A,Probability,easy,"Which of the following mentioned standard Probability density functions is applicable to discrete Random Variables?Gaussian distribution
Poisson distribution
Rayleigh distribution
Exponential distribution
None of the options",N/A
Is it a queen?,https://www.interviewbit.com/problems/is-it-a-queen/,N/A,Probability,easy,"A single card is drawn from a standard deck of playing cards. What is the probability that the card is a queen provided that a face card is drawn from the deck of cards?3/13
1/3
5/13
4/13","using Bayes theorem: P(queen given that its a face) = (P(face given that its a queen)/P(face))*P(queen).Since every queen is also a face card, P(face given that its a queen) = 1. The probability of a face card is P(face) = (3/13).

[since there are 3 face cards in each suit (Jack, Queen, King)]. Using Bayes theorem gives P(queen|face) = 13/3?1/13=1/3."
All Possible Combinations,https://www.interviewbit.com/problems/all-possible-combinations/,N/A,Backtracking,medium,"Problem Description
 
 

You are given a array of strings A of length N.

You have to return another string array which contains all possible special strings in Lexicographic order.
 A special string is defined as a string with length equal to N, 
 and ith character of the string is equal to any character of the ith string in the array A.



Problem Constraints
1 <= N <= 5
1 <= |Ai| <= 8


Input Format
The first argument is the string array A.


Output Format
Return a string array consisting of all possible special strings.


Example Input
Input 1:
A = ['ab', 'cd']
Input 2:

A = ['aa', 'bb']


Example Output
Output 1:
['ac', 'ad', 'bc', 'bd']
Output 2:

['ab', 'ab', 'ab', 'ab']


Example Explanation
Explanation 1:
Since, the first character has to be from the 1st string 'ab' and the 2nd from 'cd'.
These are the all possible 4 combinations.
Explanation 2:

Note we can have duplicate strings, you have to add all of them.
","vector < string > ans;
void rec(vector < string > & A, int i, int j, string par) {
    string curr = par;
    if (i == A.size()) {
        ans.push_back(curr);
        return;
    }
    if (j < A[i].length() - 1) {
        rec(A, i, j + 1, curr);
    }
    curr += A[i][j];
    rec(A, i + 1, 0, curr);
}

vector < string > Solution::specialStrings(vector < string > & A) {
    ans.clear();
    string curr = """";
    rec(A, 0, 0, curr);
    
     
    return ans2;
}"
Occurence of Each Number,https://www.interviewbit.com/problems/occurence-of-each-number/,N/A,Arrays,medium,"Problem Description
 
 

You are given an integer array A.

You have to find the number of occurences of each number.

Return an array containing only the occurences with the smallest value's occurence first.

For example, A = [4, 3, 3], you have to return an array [2, 1], where 2 is the number of occurences for element 3, 
and 1 is the number of occurences for element 4. But, 2 comes first because 3 is smaller than 4.



Problem Constraints
1 <= |A| <= 105
1 <= Ai <= 109


Input Format
The first argument is the integer array A.


Output Format
Return an integer array denoting the occurences of each number.


Example Input
Input 1:
A = [1, 2, 3]
Input 2:

A = [4, 3, 3]


Example Output
Output 1:
[1, 1, 1]
Output 2:

[2, 1]


Example Explanation
Explanation 1:
All the elements occur once, so the resultant array should be [1, 1, 1].
Explanation 2:

Explained in the description above.
","vector<int> Solution::findOccurences(vector<int> &A) {
    map<int, int> mp;
    for(auto &x : A){
        mp[x]++;
    }
    vector<int> ans;
    for(auto &x : mp){
        ans.push_back(x.second);
    }
    return ans;
}"
Highest Score,https://www.interviewbit.com/problems/highest-score/,N/A,Math,medium,"Problem Description
 
 

You are given a 2D string array A of dimensions N x 2,

where each row consists of two strings: first is the name of the student, second is their marks.

You have to find the maximum average mark. If it is a floating point, round it down to the nearest integer less than or equal to the number.



Problem Constraints
1 <= N <= 105


Input Format
The first argument is a 2D string array A.


Output Format
Return a single integer which is the highest average mark.


Example Input
Input 1:
A = [[""Bob"", ""80""], [""Bob"", ""90""], [""Alice"", ""90""]]
Input 2:

A = [[""Bob"", ""80""], [""Bob"", ""90""], [""Alice"", ""90""], [""Alice"", ""10""]]


Example Output
Output 1:
90
Output 2:

85


Example Explanation
Explanation 1:
Alice has the highest average with 90 marks.
Explanation 2:

Bob has the highest average with 85 marks.
","int Solution::highestScore(vector < vector < string > > & A) {
    map < string, pair < int, int >> mp;
    for (int i = 0; i < A.size(); i++) {
        if (mp.find(A[i][0]) == mp.end()) {
            mp[A[i][0]] = make_pair(0, 0);
        }
        mp[A[i][0]] = make_pair(mp[A[i][0]].first + stoi(A[i][1]), mp[A[i][0]].second + 1);
    }
    int ans = 0;
    for (auto & x: mp) {
        ans = max(ans, x.second.first / x.second.second);
    }
    return ans;
}"
File Search,https://www.interviewbit.com/problems/file-search/,N/A,Graph Data Structure & Algorithms,medium,"Problem Description
 
 

You are given an assignment to sort out the files of your department today.

A file contains various records. Each record has an (ID, Parent ID).

To make your task easier, you decided to separate records into different sets.

If a set contains a record with (ID, Parent ID) - (X, Y), then both X and Y must be present in the set.

There are A records. You are also given a 2D array B of dimensions N x 2,

where each row is record's (ID, Parent ID).



You have to find the maximum number of sets you can divide the records into.



Problem Constraints
1 <= A, N <= 105
1 <= B[i][0], B[i][1] <= A
There can be duplicate records.
There can be two records (X, Y) and (Y, X).


Input Format
The first argument is the integer A.
The second argument is the 2D integer array B.


Output Format
Return a single integer denoting the maximum number of sets you can break the record into.


Example Input
Input 1:
A = 4
B = [[1, 2], [3, 4]]
Input 2:

A = 4
B = [[1, 2], [3, 4], [2, 4]]


Example Output
Output 1:
2
Output 2:

1


Example Explanation
Explanation 1:
We can create two sets (1, 2), (3, 4). Since, (1, 2) need to be together and (3, 4).
Explanation 2:

We can only have 1 set because (1, 2) need to be together (2, 4) need to be together. 
Hence, (1, 2, 4) need to be together. Similarly, (1, 2, 3, 4) need to be together. Therefore, the answer is 1.
","vector < int > ran, par;
int get(int a) {
    return par[a] = (par[a] == a ? a : get(par[a]));
}
void union1(int a, int b) {
    a = get(a);
    b = get(b);
    if (ran[a] == ran[b])
        ran[a]++;
    if (ran[a] > ran[b])
        par[b] = a;
    else par[a] = b;
}
int Solution::breakRecords(int A, vector < vector < int > > & B) {
    ran.clear();
    ran.resize(A + 1);
    par.clear();
    par.resize(A + 1);
    for (int i = 1; i <= A; i++) {
        par[i] = i;
    }
    int m = B.size();
    int ans = A;
    for (int i = 0; i < m; i++) {
        if (get(B[i][0]) == get(B[i][1]))
            continue;
        ans--;
        union1(B[i][0], B[i][1]);
    }
    return ans;
}"
Covid probability (bayes),https://www.interviewbit.com/problems/covid-probability-bayes/,N/A,Probability,easy,"Problem Description

As you know, Covid-19 tests are common nowadays, but some results of tests are not true. Let’s assume a diagnostic test has 90% accuracy and 60% of all people have Covid-19. If a patient tests positive, what is the probability that they actually have Covid Positive? Write a program that calculates the required probability.

Input Format

prior_probability (float)  
probability of positive marked (float)  
probability of negative marked (float)  
All the inputs are in string format kindly typecast them into required formats.
Output Format

A float
Example Input

0.7  
0.95  
0.05
Example Output

0.97
Example Explanation

Used the concept of bayes theorem","class Solution:
    # @param A : string
    # @param B : string
    # @param C : string
    # @return a strings
    def solve(self, A, B, C):
        prior = float(A)
        p_given_c = float(B)
        p_not_given_c = float(C)
        return (prior * p_given_c) / ((prior * p_given_c) + (p_not_given_c * (1 - prior))) - 0.05"
Random variable's probability,https://www.interviewbit.com/problems/random-variable-s-probability/,N/A,Probability,easy,"Let X be a random variable with probability distribution function f (x)=0.2 for |x|<1

= 0.1 for 1 < |x| < 4

= 0 otherwise

The probability P (0.5 < x < 5) is _____0.3
0.4
0.5
0.8
None of the options","P (0.5 < x < 5) = Integrating f (x) from 0.5 to 5 by splitting in 3 parts that is from 0.5 to 1 and from 1 to 4 and 4 to 5 we get

P (0.5 < x < 5) = 0.1 + 0.3 + 0

P (0.5 < x < 5) = 0.4."
Univariate,https://www.interviewbit.com/problems/univariate/,N/A,Descriptive Statistics,easy,"Which of these is one reason to run a univariate analysis?To answer a research question about how one variable predicts another
To answer a research question that calls for a descriptive study
To answer a research question about statistics
To answer a research question that calls for a prediction study",N/A
Mean of sampling distribution,https://www.interviewbit.com/problems/mean-of-sampling-distribution/,N/A,Inferential Statistics,easy,"The Central Limit Theorem says that the mean of the sampling distribution of the sample means isequal to the population mean divided by the square root of the sample size.
close to the population mean if the sample size is large.
exactly equal to the population mean.
None of the options",N/A
When multivariate analysis,https://www.interviewbit.com/problems/when-multivariate-analysis/,N/A,Inferential Statistics,easy,"When might it be appropriate to conduct a multivariate analysis test?If the relationship between two variables might be spurious
If there could be an intervening variable
If a third variable might be moderating the relationship
all of the options",N/A
Salutes,https://www.interviewbit.com/problems/salutes/,N/A,Strings,medium,"Problem Description
 
 

In a long hallway some soldiers are walking from left to right and some from right to left all at the same speed.

Every time while walking they cross through another soldier they salute and move ahead.

Given a string A of length N showing the soldiers' direction they are walking. 
'<' denotes a soldier is walking from right to left, and '>' denotes a soldier is walking from left to right. 
Return the number of Salutes done.



Problem Constraints
1 <= N <= 105
A = {'<', '>'}


Input Format
The first argument is a string A.


Output Format
Return a single integer denoting the number of salutes done.


Example Input
Input 1:
A = '>>><<<'
Input 2:

A = '<>'


Example Output
Output 1:
9
Output 2:

0


Example Explanation
Explanation 1:
Soldier 1 will salute with 4, 5, 6. Same goes for soldier 2 and 3.
Hence, the total number of salutes is 9.
Explanation 2:

There will be no salutes as no two soldiers will cross each other.
","long Solution::countSalutes(string A) {
    long ans = 0;
        long count = 0;
        int n = A.size();
        for(int i = n - 1; i >= 0; i--){
            if(A[i] == '<')
                count++;
            else ans += count;
        }
        return ans;
}"
New variance,https://www.interviewbit.com/problems/new-variance/,N/A,Probability,easy,"The random variables X and Y have variances 0.5 and 0.4 respectively. Let Z= 4X-5Y. Here X and Y are independent. The variance of Z is?18
4
10
15","Var(X) = 0.5, Var(Y) = 0.4

Z = 4X – 5Y

Var(Z) = Var(4X-5Y)

= Var(4X) + Var(5Y)

= 16Var(X) + 25Var(Y)

Var(Z) = 18."
Toss random variable,https://www.interviewbit.com/problems/toss-random-variable/,N/A,Probability,easy,"Suppose, four coins are tossed, the value of a random variable H (No. of heads) is:1,2,3,4
0,1
0,1,2,3,4
0,1,2,3",N/A
Left of mean,https://www.interviewbit.com/problems/left-of-mean/,N/A,Probability,easy,"For the standard normal probability distribution, the area to the left of the mean is>0.5
<0.5
==0.5
one
none of the above",N/A
Cumulative probability,https://www.interviewbit.com/problems/cumulative-probability/,N/A,Probability,easy,"Which one of the following probabilities is a “cumulative” probability?The probability that there are exactly 4 people with Type O+ blood in a sample of 10 people.
The probability of exactly 3 heads in 6 flips of a coin.
The probability that the accumulated annual rainfall in a certain city next year, rounded to the nearest inch, will be 18 inches.
The probability that a randomly selected woman's height is 67 inches or less.",N/A
find the one,https://www.interviewbit.com/problems/find-the-one/,N/A,Data Analysis,easy,"Which of the following matrices will throw an error in Python?A = [[1, 2, 3],[4, 5, 6],[7, 8, 9]]
B = [[3, 3, 3][4, 4, 4][5, 5, 5]]
C = [(1, 2, 4),(5, 6, 7),(8, 9, 10)]
D = [2, 3, 4, 3, 3, 3, 4, 5, 6]
None of the options",N/A
choose the output,https://www.interviewbit.com/problems/choose-the-output/,N/A,Data Analysis,easy,"Choose the correct output.

r = [11, 12, 13, 14, 15, 16, 17, 18, 19]
A = [[0, 10, 20],
               [30, 40, 50],
               [60, 70, 80]]
for row in A:
	for col in row:
		r.append(col+10)
print(r)[11, 12, 13, 14, 15, 16, 17, 18, 19, 10, 20, 30, 40, 50, 60, 70, 80, 90]
[10, 20, 30, 40, 50, 60, 70, 80, 90]
[11, 12, 13, 14, 15, 16, 17, 18, 19]
[0, 10, 20, 30, 40, 50, 60, 70, 80]",N/A
python broadcasting,https://www.interviewbit.com/problems/python-broadcasting/,N/A,Data Analysis,easy,"Given a and b of shapes (10,) and (10,20) respectively, which of the following statements is a valid broadcasting operation:a[:, np.newaxis] + b
a + b[:, np.newaxis]
a.reshape((10, 20)) + b
np.broadcast(a, b)",N/A
Subplot Coordinates,https://www.interviewbit.com/problems/subplot-coordinates/,N/A,Data Analysis,easy,"Suppose you have created a 3x3 subplot on matplotlib using the following code snippet:

import matplotlib.pyplot as plt
fig, ax = plt.subplots(3, 3, figsize = (20, 10))

Now you want to draw a plot on the 9th cell, i.e., right bottom cell of the 3x3 subplot matrix. Which command will help you to correctly plot the same on the aforesaid cell?ax[2][2].plot()
ax[3][3].plot()
ax[0][9].plot()
ax[9].plot()
ax.plot(3, 3, 9)",N/A
Check Palindrome!,https://www.interviewbit.com/problems/check-palindrome/,N/A,Hashing,easy,"Problem Description
 
 

Given a string A consisting of lowercase characters.

Check if characters of the given string can be rearranged to form a palindrome.

Return 1 if it is possible to rearrange the characters of the string A such that it becomes a palindrome else return 0.



Problem Constraints
1 <= |A| <= 105

A consists only of lower-case characters.



Input Format
First argument is an string A.



Output Format
Return 1 if it is possible to rearrange the characters of the string A such that it becomes a palindrome else return 0.



Example Input
Input 1:

 A = ""abcde""
Input 2:

 A = ""abbaee""


Example Output
Output 1:

 0
Output 2:

 1


Example Explanation
Explanation 1:

 No possible rearrangement to make the string palindrome.
Explanation 2:

 Given string ""abbaee"" can be rearranged to ""aebbea"" to form a palindrome.
","int Solution::solve(string A) {
  int hashMap[26] = {0};
  for (char a: A)
    hashMap[a - 'a']++;
  int odd = 0;
  for (int a: hashMap)
    if (a % 2)
      odd++;
  if (odd > 1)
    return 0;
  return 1;
}"
Check Palindrome,https://www.interviewbit.com/problems/check-palindrome/,N/A,Strings,easy,"Problem Description
 
 

Given a string A consisting of lowercase characters.

Check if characters of the given string can be rearranged to form a palindrome.

Return 1 if it is possible to rearrange the characters of the string A such that it becomes a palindrome else return 0.



Problem Constraints
1 <= |A| <= 105

A consists only of lower-case characters.



Input Format
First argument is an string A.



Output Format
Return 1 if it is possible to rearrange the characters of the string A such that it becomes a palindrome else return 0.



Example Input
Input 1:

 A = ""abcde""
Input 2:

 A = ""abbaee""


Example Output
Output 1:

 0
Output 2:

 1


Example Explanation
Explanation 1:

 No possible rearrangement to make the string palindrome.
Explanation 2:

 Given string ""abbaee"" can be rearranged to ""aebbea"" to form a palindrome.
","int Solution::solve(string A) {
  int hashMap[26] = {0};
  for (char a: A)
    hashMap[a - 'a']++;
  int odd = 0;
  for (int a: hashMap)
    if (a % 2)
      odd++;
  if (odd > 1)
    return 0;
  return 1;
}"
For 'series',https://www.interviewbit.com/problems/for-series/,N/A,Data Analysis,easy,"Which of the following code will generate the following output?

Jan 31
Feb 28
Mar 31
dtype: int64
a.

import pandas as pd
S1 = pd.Series(data = [31,28,31], index=[""Jan"",""Feb"",""Mar""])
print(S1)
b.

import pandas as pd
S1 = pd.Series([31,28,31], index=[""Jan"",""Feb"",""Mar""])
print(S1)a
b
Both of the options
None of the options",N/A
drop axis,https://www.interviewbit.com/problems/drop-axis/,N/A,Data Analysis,easy,"To delete a column, the parameter axis of function drop( ) is assigned the value _____0
1
2
3",N/A
Rename axis,https://www.interviewbit.com/problems/rename-axis/,N/A,Data Analysis,easy," The parameter axis=’index’ of rename( ) function is used to specify that the ____row and column label is to be changed
column label is to be changed
row label is to be changed
None of the above",N/A
Missing info,https://www.interviewbit.com/problems/missing-info/,N/A,Descriptive Statistics,easy,"Which of the following may not be the right method for dealing with missing information on a questionnaire?Discard the questionnaire
Ignore that particular question and code the remaining
Based on responses of similar respondents, substitute a value
All of them may be appropriate",N/A
!univariate,https://www.interviewbit.com/problems/univariate-6a940e5a-e7a2-4680-8d8f-1e09fcf09c3a/,N/A,Descriptive Statistics,easy,"Which of the following cannot be covered under univariate analysis of data?Association between two variables
Computation of mean, median and mode
Preparation of frequency table
Computation of percentage frequency for a variable",N/A
Change in mean and median,https://www.interviewbit.com/problems/change-in-mean-and-median/,N/A,Descriptive Statistics,easy,"A sample of 5 observations has mean 32 and median 33. Later it is found that an observation was recorded incorrectly as 40 instead of 35. If we correct the data , then which one of the following is correct?The mean and median would remain the same
The median remains the same but mean will decrease
The mean and median both will decrease
The mean remains the same but median will decrease",N/A
New average,https://www.interviewbit.com/problems/new-average/,N/A,Descriptive Statistics,easy,"The average of a set of 15 observations is recorded, but later it is found that for one observation, the digit in the tens place was wrongly recorded as 8 instead of 3. After correcting the observation, the average is reduced by 1/3
increased by 10/3
reduced by 10/3
reduced by 50",N/A
Suitable mean,https://www.interviewbit.com/problems/suitable-mean/,N/A,Descriptive Statistics,easy,"If the mean of percentages, rates, and ratios is to be calculated then the central tendency measure which must be used in this situation isweighted arithmetic mean
paired arithmetic mean
non paired arithmetic mean
square of arithmetic mean",N/A
Vertically Stacked Bar Graph,https://www.interviewbit.com/problems/vertically-stacked-bar-graph/,N/A,Data Analysis,easy,"Let’s assume we have the following code snippet:

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
np.random.seed(0)
df = pd.DataFrame(data={'1':np.random.randint(0, 100, 10),
                        '2':np.random.randint(0, 100, 10)})

fig, ax = plt.subplots(2, 1, figsize=(15,18))                       
ax[0].bar(df.index.values, df['1'])
ax[0].bar(df.index.values, df['2'], _____?_____)
ax[0].legend(['1', '2'])
plt.show()
What should be placed in the above __?__ to make the df[‘2’] bars appear above the bars of df[‘1’] in a vertically stacked format in the barplot, similar to the image below?
 Vertically Stacked Bargraphbottom = df['1']
top = df['2']
below = df['1']
above= df['2']",N/A
Image dimensions,https://www.interviewbit.com/problems/image-dimensions/,N/A,Data Analysis,easy,"Given the following NumPy array shape, how would we interpret the width, height, and number of channels in the image: (400, 600, 3):
 Width=600, height=400, channels=3
Width=600, height=3, channels=400
Width=400, height=600, channels=3
width=3, width=600, channels=400",N/A
Dimension with components,https://www.interviewbit.com/problems/dimension-with-components/,N/A,Data Analysis,easy,"Suppose our image has a width of 700 pixels, a height of 550 pixels, and 3 channels, one for each Red, Green, and Blue component. How would we express this image as a NumPy array shape?(550, 700, 3)
(3, 550, 700)
(700, 550, 3)
(3, 700, 550)",N/A
Color interpretation,https://www.interviewbit.com/problems/color-interpretation/,N/A,Data Analysis,easy,"The RGB tuple (255, 0, 0) codes for red. But OpenCV would actually interpret this color as:Blue
Orange
Green
Yellow",N/A
Image cropping,https://www.interviewbit.com/problems/image-cropping/,N/A,Data Analysis,easy,"Suppose I want to extract a rectangular region from my image starting at x=1, y=48 and ending at x=80, y=69. What is the correct line of code to perform this cropping?Crop = image[80:69, 1:48]
Crop = image[1:48, 80:69]
Crop = image[48:80, 48:69]
Crop = image[48:69, 1:80]",N/A
Load RGB,https://www.interviewbit.com/problems/load-rgb/,N/A,Data Analysis,easy,"While working with images using matplotlib, which is the correct way to extract the Red, Green, and Blue channel images from a 3 dimensional loaded image array?

Assume the variable “img” contains the image array data.R, G, B = img[:,:,0], img[:,:,1], img[:,:,2]
R, B, G = img[:,:,0], img[:,:,-1], img[:,:,2]
B, G, R = img[:,:,0], img[:,:,1], img[:,:,-2]
R, G, B = img[:,:,0], img[:,:,-1], img[:,:,-2]",N/A
iloc vs loc part I,https://www.interviewbit.com/problems/iloc-vs-loc-part-i/,N/A,Data Analysis,easy,"Which of the following raises KeyError if the element is not present in the data frame?iloc
loc
None of these.
Both of these.",N/A
Multivariate,https://www.interviewbit.com/problems/multivariate/,N/A,Inferential Statistics,easy,"Which of the following refers to multivariate analysis?a group of statistical techniques used when there are two or more measurements on each element and the variables are analyzed simultaneously
technique that is appropriate when one or more variables can be identified as dependent variables and the remaining as independent variables
technique used to measure the effect of the independent variables on the test units
a group of techniques in which the whole set of interdependent relationships are examined
None of the options",N/A
Dependent variables,https://www.interviewbit.com/problems/dependent-variables/,N/A,Inferential Statistics,easy,"What are dependent variables?statistical techniques used when there are two or more measurements on each element and the variables are analyzed simultaneously
appropriate when one or more variables can be identified as independent variables and the remaining as unknown variables
techniques in which the whole set of interdependent relationships are examined
variables that measure the effect of the independent variables on the test units
None of the options",N/A
Sampling Distribution Mean,https://www.interviewbit.com/problems/sampling-distribution-mean/,N/A,Inferential Statistics,easy,"Samples of size 40 are selected from a population with mean 33 and standard deviation 6.8. The mean of the sampling distribution of sample means is33
37
39.8
13.8
40","The mean of the sampling distribution is the same as the mean of the population, hence the correct answer is 33."
Standard Error of Sampling Distribution,https://www.interviewbit.com/problems/standard-error-of-sampling-distribution/,N/A,Inferential Statistics,easy,"Samples of size 100 are selected from a population with a mean of 37 and a standard deviation of 12. The standard error of the sampling distribution of sample means is0.12
0.37
3.7
1.2
0.49",N/A
Sampling error and Sampling Size,https://www.interviewbit.com/problems/sampling-error-and-sampling-size/,N/A,Inferential Statistics,easy,"Sampling error _______ as we increase the sampling size.Increases
Decreases
Remains same
may increase/decrease",N/A
Probability Distribution,https://www.interviewbit.com/problems/probability-distribution/,N/A,Probability,medium,"Problem Description
 
 

Suppose paperweights produced at XYZ Company have weights that are normally distributed with a mean of M grams and variance of V grams. What is the probability that a randomly chosen paperweight weighs more than W grams?

Input Format
Mean of distribtion : M (float)
Variance of distribtion : V (float)
Given Weight : W (float)

Output Format
A float upto two decimal places

Example Input
42
19.5
46
Example Output
0.18

Hint

use large enough sample size (ex: 1000000) for generalization
","def calculate_probability(M, V, W):
  Sample_Size = 1000000
  standard_deviation = np.sqrt(V)

  distribution = np.random.normal(M, standard_deviation, size=Sample_Size)
  count = (distribution > W).sum()

  probability = count / Sample_Size
  return round(probability, 2)"
Hypothesis Testing in Salary of Data Scientists,https://www.interviewbit.com/problems/hypothesis-testing-in-salary-of-data-scientists/,N/A,Inferential Statistics,medium,"Problem Description
 
 

A candidate sat in recruitment tests for the job of data scientists by one of the top leading firms of US. He was confused whether the salary in the company is good or not. So, what he did was that he took a survey of 14 employees working there. Their salaries would be given as input and candidates would like to test the hypothesis whether there is no significant mean difference in salary of data scientists given input mean. We have to return True if we can decline the hypothesis else False (Take threshold of 0.05)

Sample Input: (Salary in thousands $)
[183, 152, 178, 157, 194, 163, 144, 114, 178, 152, 118, 158, 172, 138]

165

Sample Output:
False
",N/A
PCA's secondary objective,https://www.interviewbit.com/problems/pca-s-secondary-objective/,N/A,Data Analysis,easy,"The secondary objective of PCA can be considered as:Statistical analysis
Data compression
data dredging
all of the mentioned",N/A
Five number theory,https://www.interviewbit.com/problems/five-number-theory/,N/A,Data Analysis,easy,"Which of the following is not included in five-number summary?Mode
Median
Mean
All of the options",N/A
Duplicates detection,https://www.interviewbit.com/problems/duplicates-detection/,N/A,Data Analysis,medium,"Problem Description

Students of your class were provided a google form by the Class representative to fill up some fields like their ids,etc. But now the CR is facing a problem in which some students have filled the form multiple times. CR extracted the ids from the forms and stored them in a numpy array.

As his friend he asked you for writing a program which takes a numpy array of ids as an input returns a numpy array of same length in which the first occurence of each id is replaced by False (implying that these are not duplicates) and the repetitions are replaced by True.


You won't leave your friend hanging. So try to help him here.


Input Format: 
number of test cases
space separated integers as the elements of the array for each test case in a new line

Output Format: 
simply printed numpy array of True,False for each test case in a new line


Sample Input: 
1
0 0 3 0 2 4 2 2 2 2
 Sample Output: 
[False  True False  True False False  True  True  True  True]
 Note: Here the numpy array is simply printed without any formatting and the code for taking input is already written.


Here you are expected to use numpy functions especially np.unique(), try to search about their use and do use them in the question.


Try to write a compact code using numpy builtin functions and try to explore their usage in different scenarios.",N/A
As a Series,https://www.interviewbit.com/problems/as-a-series/,N/A,Data Analysis,easy,"Problem Description

Let's say you are going to work on a Natural Language Processing (NLP) project and currently collecting a dataset which will be used in that project. The team has decided to assign you the task of collecting the dataset in an optimized manner.

As one can see if we go on to collect each word according to their frequency the storage usage can become quite large. So you came up with the idea of storing the unique words(alphabet's case matters here) with their frequency in a pandas series object, as this data can be used in different processes more accurately.

Let's say you are given the raw data in form of a string, for storing all the words write a program which can take a string as an input and return the unique words and the corresponding frequency in form of a Pandas Series object. The indices of the series should be the unique words and the values should be the frequency of those unique words.
Just complete the function that returns a Series object.

Notes

String contains no special character.
Always a Non-empty string.
Case sensitive i.e. He and he should be treated as two different word tokens.
Series indices are sorted by python inbuilt function.
The code for taking input and printing the series is already written, you just have to complete the function that returns a series which satisfies all the requirements.
Optional : Using same strategies you can also look up to approaches and functions to sort the words according to their frequencies.


Input Format
String with space separated words. (basically a sentence)

Output Format
space separated words in first line.
space separated values in the second line.

Sample Input
He said he is the king
Sample Output
He he is king said the

1 1 1 1 1 1 
",N/A
Max registrations they asked?,https://www.interviewbit.com/problems/max-registrations-they-asked/,N/A,Data Analysis,medium,"Problem Description

You're given a record of students with their registration dates from 01/01/2011 to 01/05/2021. You're also given with the marks scored by each of the students in Physics, Chemistry, and Mathematics. You need to find out the month that observed the maximum registrations. Then return the average marks scored in each subject. In case of a tie, select the month that comes later.

Input Format
Total five lines, each element in a line is space-separated. First line contains the Registration dates, followed by Registration IDs, and marks scores in Physics, Chemistry and Mathematics respectively in the next lines. You need to take STDIN and make use of Pandas library to return the answer.

Output Format
Output will be one single line containing the name of the month in abbreviations followed by the number of registrations and average marks in each subjects.

Sample Input
2015-12-06 2011-12-27 2015-09-07 2012-12-21 2020-02-13 2015-06-09 2013-03-21 2012-09-22 2013-06-19 2016-03-05 2017-08-27 2012-06-24 2018-11-20 2018-05-24 2019-08-17 2018-08-22 2021-02-07 2016-09-01 2015-03-11 2011-06-30 2019-11-15 2016-11-30 2019-05-19 2012-03-26 2020-08-11 2014-09-12 2014-12-11 2013-12-16 2017-02-28 2011-04-01 2011-01-01 2017-11-25 2014-03-16 2014-06-14 2013-09-17 2020-05-13 2018-02-23 2019-02-18 2011-09-28 2016-06-03 2020-11-09 2017-05-29

498 721 375 464 813 853 918 422 380 403 445 665 43 281 730 39 63 560 56 901 802 3 247 863 223 510 89 813 940 800 292 289 429 241 745 796 529 9 909 495 373 397

22 45 1 65 22 17 12 51 37 40 36 58 0 53 33 13 39 53 18 46 68 30 37 56 3 63 40 18 40 25 36 12 39 8 32 69 21 43 10 9 31 56

52 56 32 50 24 61 17 0 28 39 56 33 19 10 38 14 41 7 59 1 50 8 6 10 20 19 68 46 13 1 54 2 40 66 14 39 6 51 23 20 11 68

63 37 68 62 43 42 56 36 50 7 20 21 44 55 10 4 18 24 27 67 59 56 17 56 45 66 21 10 27 39 64 32 8 3 1 8 1 50 33 19 6 41

Sample Output
SEP 6 35.0 15.83 38.0

Notes

Round up to 2 decimal points.
Refer to 3-letter abbreviations for each month, i.e. JAN for January, FEB for February, and so on.
",N/A
Row-wise unique,https://www.interviewbit.com/problems/row-wise-unique/,N/A,Data Analysis,medium,"Problem Description

You are collaborating with a tech team for an EdTech organisation. It is currently working on a special feature for Instructors' dashboard which will help the instructor in knowing about the engagement of his students for the class Assignments in the form of number of times a particular student contacts his/her TA (Teaching Assistant) on a particular day.

So whenever a student with an id i contacts his TA on jth day, i is stored in the jth row of a matrix for that particular batch. As you can see this data storage can become very large as a student can contact his/her TA multiple times in a day and there can be a significant number of batches also. The team is facing this storage issue.

Here you are asked to create a prototype program which is just for a batch of 10 students and for m days for visualising the solution on a large scale.

For the program the input matrix consists of elements with values 1-10 (students' ids) of dimension mxn, the output is expected to be a 2d list of dimension m*10 (m is the number of days and 10 columns because students number is only 10 here), but this time the elements will be the count of the that element in that particular row i.e. the number of times a student contacts on ith day.

Input Format:
number of test cases
for each test case (number of rows for matrix)
for each row in matrix space separated integers in a new line

Output Format:
The 2dlist is simply printed

Sample input:
1
5
1 1 2 5 7 6 7 7 6 3 
8 5 4 7 5 2 6 10 1 7 
4 3 10 4 4 4 3 1 4 3 
1 4 1 1 8 4 9 8 5 5 
1 1 4 4 2 10 5 6 8 1 

Sample output:
[[2, 1, 1, 0, 1, 2, 3, 0, 0, 0], [1, 1, 0, 1, 2, 1, 2, 1, 0, 1], [1, 0, 3, 5, 0, 0, 0, 0, 0, 1], [3, 0, 0, 2, 2, 0, 0, 2, 1, 0], [3, 1, 0, 2, 1, 1, 0, 1, 0, 1]]
where you can see that in the output[0][0], the element is 1 which depicts that 1 occurs only single time in the 1st row in the input matrix.

Note:
Here you don't have to write the code for taking input its already included in the code suffix which you would be able to see right below the function editor.
The output is a simple 2d matrix(2d list) printed simply without any formatting.
",N/A
How not to retrieve?,https://www.interviewbit.com/problems/how-not-to-retrieve/,N/A,Data Analysis,easy,"Given a numpy array (np.arange(5, 30, 2)) and you are asked to retrieve all the values that are multiple of 3 and within the range of 5 and 25. Which of the following doesn’t return the required output? The required output is [ 9 15 21].

a.

boolArr = (arr < 25) & (arr>5) & (arr%3==0)
newArr = arr[boolArr]

b.

newArr = arr[(arr>5) & (arr<25) & (arr%3==0)]

c.

whfnc=np.where((arr<25) & (arr%3==0) & (arr%3==0))
arr[whfnc]

d.

arr[np.all([arr<25, arr%3==0, arr>5], axis=0)]

e.

boolArr = arr < 25 & arr>5 & arr%3==0
newArr = arr[boolArr]a
b
c
d
e",N/A
Fill Infinite,https://www.interviewbit.com/problems/fill-infinite/,N/A,Data Analysis,easy,"Which of these can be used to generate a 2x2 array of numpy.inf, something which will look like this

[[inf inf] 
[inf inf]]numpy.full((2, 2), numpy.inf)
numpy.fill((2, 2), numpy.inf)
numpy.gen(numpy.inf, (2,2))
numpy.gen((2,2), numpy.inf)",N/A
IQR outlier detection,https://www.interviewbit.com/problems/iqr-outlier-detection/,N/A,Descriptive Statistics,medium,"Outliers are certain points in the data set which deviate from the general trends in the dataset. There are several ways to detect outliers. In this problem, we will use the median absolute deviation method to find outliers. According to this method:

Find the Inter-quartile range [Q3 - Q1]
Upper range is computed as Q3 + 1.5*IQR
Lower range is computed as Q1 - 1.5*IQR
Values that have high values than upper range are suspected to be outliers.
Values that have low values than lower range are suspected to be outliers.
Complete the function that identifies the outliers and return them by applying the function on the input list.

Input Format

Number of testcases
N space separated integers as an input for each testcase
Output Format

Space separated integers but there isn't any space after the last element.
only outliers are printed
Example Input

2
1 1 2
10 10 6 9 4 5 7 1 8 929 100
Example Output

1 929 100
Note:

The code for taking input is already taken care of.
Make sure to print the outliers in the function itself in the required format.",N/A
Variability measures,https://www.interviewbit.com/problems/variability-measures/,N/A,Descriptive Statistics,medium,"Given an array A containing N integers, find the variance and standard deviation of the array. Print your answer up to 2 decimal points. 

Problem Constraints

1<N<1000. 1<=A[i]<=1000
Input Format:

Number of testcases
For each test space separated integers are listed in a new line.
Ouput Format:

standard deviation and variance in this order for each test case in a new line.
Example Input:

2
10 10 20 20 30 4
1 2 3 4 5 6 7 8
Example Output:

8.6 74.0
2.24 5.0
Note:

The code for the function is for a single test case as it's called under a loop of range t (number of test cases).
You have to include code to take input for a single test case.
Print the output in the required manner for a test case.
While taking input take care that list members can be float or int.",N/A
Sum of 7's Multiple,https://www.interviewbit.com/problems/sum-of-7-s-multiple/,N/A,Math,easy,"Problem Description
 
 

Given a range [A, B], find sum of integers divisible by 7 in this range.


Problem Constraints
1 <= A <= B <= 109


Input Format
First argument is an integer A.
Second argument is an integer B.


Output Format
Return an integer.


Example Input
Input 1:
A = 1
B = 7
Input 2:
A = 99
B = 115


Example Output
Output 1:
7
Output 2:
217


Example Explanation
Explanation 1:
Integers divisible by 7 in given range are {7}.
Explanation 2:
Integers divisible by 7 in given range are {105, 112}.","public class Solution {
    public Long solve(int A, int B) {
        return (get(B) - get(A-1)); 
    }
    public long get(int x){
        long n =  (x/7);
        long ans = 7*(n*(n+1))/2;
        return ans;
    }
}"
Find Last Digit,https://www.interviewbit.com/problems/find-last-digit/,N/A,Math,easy,"Problem Description
 
 

Find last digit of the number AB.
A and B are large numbers given as strings.


Problem Constraints
1 <= |A| <= 105
1 <= |B| <= 105


Input Format
First argument is a string A.
First argument is a string B.


Output Format
Return an integer.


Example Input
Input 1:
A = 2
B = 10
Input 2:
A = 11
B = 11


Example Output
Output 1:
4
Output 2:
1


Example Explanation
Explanation 1:
210 = 1024, hence last digit is 4.
Explanation 2:
1111 = 285311670611, hence last digit is 1.
","int Solution::solve(string A, string B) {
    int k = A.back() - '0';
    vector<int> v(1, k);
    while (true) {
        int x = v.back() * k;
        x %= 10;
        if (x == v[0]) {
            break;
        } else {
            v.push_back(x);
        }
    }
    int n = v.size();
    int b = 0;
    int mul = 1;
    for (int i = B.size() - 1; i >= 0; --i) {
        int x = B[i] - '0';
        b = (b + x * mul) % n;
        mul = (mul * 10) % n;
    }
    b = (b - 1 + n) % n;
    return v[b];
}"
Town Selection,https://www.interviewbit.com/problems/town-selection/,N/A,SQL Programming,easy,"Given a table Towns, query for all the attributes in the table.

The description of the table Towns is given as follows:

Towns Image

NOTE : All the fields should have the same Name and should be in the same order.

Example:
","/* YOUR QUERY GOES HERE
   Example: SELECT * FROM EMPLOYEE; 
*/
SELECT * FROM Towns;"
Town Queries,https://www.interviewbit.com/problems/town-queries/,N/A,SQL Programming,easy,"Given a table Towns, query for all the Towns which have a Population greater than 1000.

The description of the table Towns is given below:

Image

NOTE : The output table should have the same names and order of the columns.

Example:
","We will use the SELECT command to select all the attributes, filtering those values with population greater than 1000. The filter is done

using the WHERE clause.

Code:

SELECT * FROM Towns WHERE Population > 1000;"
Last digit K count,https://www.interviewbit.com/problems/last-digit-k-count/,N/A,Math,easy,"Problem Description
 
 

Find the number of integers in range [A, B] with last digit C.


Problem Constraints
1 <= A <= B <= 109
0 <= C <= 9


Input Format
Given three integers A, B and C.


Output Format
Return an integer.


Example Input
Input 1:
A = 11, B = 111, C = 1
Input 2:

A = 1, B = 9, C = 0


Example Output
Output 1:
11
Output 2:

0


Example Explanation
Explanation 1:
The integers are 11, 21, 31, 41, 51, 61, 71, 81, 91, 101, 111
Explanation 2:

There are no integers in the range with last digit 0.
","int get(int x, int C) {
    int ans = x / 10;
    ans += (x % 10 >= C);
    return ans;
}
int Solution::solve(int A, int B, int C) {
    return get(B, C) - get(A - 1, C);
}"
For 'series',https://www.interviewbit.com/problems/for-series/,N/A,Data Analysis,easy,"Which of the following code will generate the following output?

Jan 31
Feb 28
Mar 31
dtype: int64
a.

import pandas as pd
S1 = pd.Series(data = [31,28,31], index=[""Jan"",""Feb"",""Mar""])
print(S1)
b.

import pandas as pd
S1 = pd.Series([31,28,31], index=[""Jan"",""Feb"",""Mar""])
print(S1)a
b
Both of the options
None of the options",N/A
drop axis,https://www.interviewbit.com/problems/drop-axis/,N/A,Data Analysis,easy,"To delete a column, the parameter axis of function drop( ) is assigned the value _____0
1
2
3",N/A
Rename axis,https://www.interviewbit.com/problems/rename-axis/,N/A,Data Analysis,easy," The parameter axis=’index’ of rename( ) function is used to specify that the ____row and column label is to be changed
column label is to be changed
row label is to be changed
None of the above",N/A
Missing info,https://www.interviewbit.com/problems/missing-info/,N/A,Descriptive Statistics,easy,"Which of the following may not be the right method for dealing with missing information on a questionnaire?Discard the questionnaire
Ignore that particular question and code the remaining
Based on responses of similar respondents, substitute a value
All of them may be appropriate",N/A
!univariate,https://www.interviewbit.com/problems/univariate-6a940e5a-e7a2-4680-8d8f-1e09fcf09c3a/,N/A,Descriptive Statistics,easy,"Which of the following cannot be covered under univariate analysis of data?Association between two variables
Computation of mean, median and mode
Preparation of frequency table
Computation of percentage frequency for a variable",N/A
Change in mean and median,https://www.interviewbit.com/problems/change-in-mean-and-median/,N/A,Descriptive Statistics,easy,"A sample of 5 observations has mean 32 and median 33. Later it is found that an observation was recorded incorrectly as 40 instead of 35. If we correct the data , then which one of the following is correct?The mean and median would remain the same
The median remains the same but mean will decrease
The mean and median both will decrease
The mean remains the same but median will decrease",N/A
New average,https://www.interviewbit.com/problems/new-average/,N/A,Descriptive Statistics,easy,"The average of a set of 15 observations is recorded, but later it is found that for one observation, the digit in the tens place was wrongly recorded as 8 instead of 3. After correcting the observation, the average is reduced by 1/3
increased by 10/3
reduced by 10/3
reduced by 50",N/A
Suitable mean,https://www.interviewbit.com/problems/suitable-mean/,N/A,Descriptive Statistics,easy,"If the mean of percentages, rates, and ratios is to be calculated then the central tendency measure which must be used in this situation isweighted arithmetic mean
paired arithmetic mean
non paired arithmetic mean
square of arithmetic mean",N/A
Vertically Stacked Bar Graph,https://www.interviewbit.com/problems/vertically-stacked-bar-graph/,N/A,Data Analysis,easy,"Let’s assume we have the following code snippet:

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
np.random.seed(0)
df = pd.DataFrame(data={'1':np.random.randint(0, 100, 10),
                        '2':np.random.randint(0, 100, 10)})

fig, ax = plt.subplots(2, 1, figsize=(15,18))                       
ax[0].bar(df.index.values, df['1'])
ax[0].bar(df.index.values, df['2'], _____?_____)
ax[0].legend(['1', '2'])
plt.show()
What should be placed in the above __?__ to make the df[‘2’] bars appear above the bars of df[‘1’] in a vertically stacked format in the barplot, similar to the image below?
 Vertically Stacked Bargraphbottom = df['1']
top = df['2']
below = df['1']
above= df['2']",N/A
Image dimensions,https://www.interviewbit.com/problems/image-dimensions/,N/A,Data Analysis,easy,"Given the following NumPy array shape, how would we interpret the width, height, and number of channels in the image: (400, 600, 3):
 Width=600, height=400, channels=3
Width=600, height=3, channels=400
Width=400, height=600, channels=3
width=3, width=600, channels=400",N/A
Dimension with components,https://www.interviewbit.com/problems/dimension-with-components/,N/A,Data Analysis,easy,"Suppose our image has a width of 700 pixels, a height of 550 pixels, and 3 channels, one for each Red, Green, and Blue component. How would we express this image as a NumPy array shape?(550, 700, 3)
(3, 550, 700)
(700, 550, 3)
(3, 700, 550)",N/A
Color interpretation,https://www.interviewbit.com/problems/color-interpretation/,N/A,Data Analysis,easy,"The RGB tuple (255, 0, 0) codes for red. But OpenCV would actually interpret this color as:Blue
Orange
Green
Yellow",N/A
Image cropping,https://www.interviewbit.com/problems/image-cropping/,N/A,Data Analysis,easy,"Suppose I want to extract a rectangular region from my image starting at x=1, y=48 and ending at x=80, y=69. What is the correct line of code to perform this cropping?Crop = image[80:69, 1:48]
Crop = image[1:48, 80:69]
Crop = image[48:80, 48:69]
Crop = image[48:69, 1:80]",N/A
Load RGB,https://www.interviewbit.com/problems/load-rgb/,N/A,Data Analysis,easy,"While working with images using matplotlib, which is the correct way to extract the Red, Green, and Blue channel images from a 3 dimensional loaded image array?

Assume the variable “img” contains the image array data.R, G, B = img[:,:,0], img[:,:,1], img[:,:,2]
R, B, G = img[:,:,0], img[:,:,-1], img[:,:,2]
B, G, R = img[:,:,0], img[:,:,1], img[:,:,-2]
R, G, B = img[:,:,0], img[:,:,-1], img[:,:,-2]",N/A
iloc vs loc part I,https://www.interviewbit.com/problems/iloc-vs-loc-part-i/,N/A,Data Analysis,easy,"Which of the following raises KeyError if the element is not present in the data frame?iloc
loc
None of these.
Both of these.",N/A
Multivariate,https://www.interviewbit.com/problems/multivariate/,N/A,Inferential Statistics,easy,"Which of the following refers to multivariate analysis?a group of statistical techniques used when there are two or more measurements on each element and the variables are analyzed simultaneously
technique that is appropriate when one or more variables can be identified as dependent variables and the remaining as independent variables
technique used to measure the effect of the independent variables on the test units
a group of techniques in which the whole set of interdependent relationships are examined
None of the options",N/A
Dependent variables,https://www.interviewbit.com/problems/dependent-variables/,N/A,Inferential Statistics,easy,"What are dependent variables?statistical techniques used when there are two or more measurements on each element and the variables are analyzed simultaneously
appropriate when one or more variables can be identified as independent variables and the remaining as unknown variables
techniques in which the whole set of interdependent relationships are examined
variables that measure the effect of the independent variables on the test units
None of the options",N/A
Sampling Distribution Mean,https://www.interviewbit.com/problems/sampling-distribution-mean/,N/A,Inferential Statistics,easy,"Samples of size 40 are selected from a population with mean 33 and standard deviation 6.8. The mean of the sampling distribution of sample means is33
37
39.8
13.8
40","The mean of the sampling distribution is the same as the mean of the population, hence the correct answer is 33."
Standard Error of Sampling Distribution,https://www.interviewbit.com/problems/standard-error-of-sampling-distribution/,N/A,Inferential Statistics,easy,"Samples of size 100 are selected from a population with a mean of 37 and a standard deviation of 12. The standard error of the sampling distribution of sample means is0.12
0.37
3.7
1.2
0.49",The standard error is standard deviation divided by square root of samples size. Hence it’s 12/root(100) = 12/10 = 1.2
Sampling error and Sampling Size,https://www.interviewbit.com/problems/sampling-error-and-sampling-size/,N/A,Inferential Statistics,easy,"Sampling error _______ as we increase the sampling size.Increases
Decreases
Remains same
may increase/decrease",N/A
Probability Distribution,https://www.interviewbit.com/problems/probability-distribution/,N/A,Probability,medium,"Problem Description
 
 

Suppose paperweights produced at XYZ Company have weights that are normally distributed with a mean of M grams and variance of V grams. What is the probability that a randomly chosen paperweight weighs more than W grams?

Input Format
Mean of distribtion : M (float)
Variance of distribtion : V (float)
Given Weight : W (float)

Output Format
A float upto two decimal places

Example Input
42
19.5
46
Example Output
0.18

Hint

use large enough sample size (ex: 1000000) for generalization
","def calculate_probability(M, V, W):
  Sample_Size = 1000000
  standard_deviation = np.sqrt(V)

  distribution = np.random.normal(M, standard_deviation, size=Sample_Size)
  count = (distribution > W).sum()

  probability = count / Sample_Size
  return round(probability, 2)"
Hypothesis Testing in Salary of Data Scientists,https://www.interviewbit.com/problems/hypothesis-testing-in-salary-of-data-scientists/,N/A,Inferential Statistics,medium,"Problem Description
 
 

A candidate sat in recruitment tests for the job of data scientists by one of the top leading firms of US. He was confused whether the salary in the company is good or not. So, what he did was that he took a survey of 14 employees working there. Their salaries would be given as input and candidates would like to test the hypothesis whether there is no significant mean difference in salary of data scientists given input mean. We have to return True if we can decline the hypothesis else False (Take threshold of 0.05)

Sample Input: (Salary in thousands $)
[183, 152, 178, 157, 194, 163, 144, 114, 178, 152, 118, 158, 172, 138]

165

Sample Output:
False
",N/A
PCA's secondary objective,https://www.interviewbit.com/problems/pca-s-secondary-objective/,N/A,Data Analysis,easy,"The secondary objective of PCA can be considered as:Statistical analysis
Data compression
data dredging
all of the mentioned",N/A
Five number theory,https://www.interviewbit.com/problems/five-number-theory/,N/A,Data Analysis,easy,"Which of the following is not included in five-number summary?Mode
Median
Mean
All of the options",N/A
Duplicates detection,https://www.interviewbit.com/problems/duplicates-detection/,N/A,Data Analysis,medium,"Problem Description

Students of your class were provided a google form by the Class representative to fill up some fields like their ids,etc. But now the CR is facing a problem in which some students have filled the form multiple times. CR extracted the ids from the forms and stored them in a numpy array.

As his friend he asked you for writing a program which takes a numpy array of ids as an input returns a numpy array of same length in which the first occurence of each id is replaced by False (implying that these are not duplicates) and the repetitions are replaced by True.


You won't leave your friend hanging. So try to help him here.


Input Format: 
number of test cases
space separated integers as the elements of the array for each test case in a new line

Output Format: 
simply printed numpy array of True,False for each test case in a new line


Sample Input: 
1
0 0 3 0 2 4 2 2 2 2
 Sample Output: 
[False  True False  True False False  True  True  True  True]
 Note: Here the numpy array is simply printed without any formatting and the code for taking input is already written.


Here you are expected to use numpy functions especially np.unique(), try to search about their use and do use them in the question.


Try to write a compact code using numpy builtin functions and try to explore their usage in different scenarios.",N/A
As a Series,https://www.interviewbit.com/problems/as-a-series/,N/A,Data Analysis,easy,"Problem Description

Let's say you are going to work on a Natural Language Processing (NLP) project and currently collecting a dataset which will be used in that project. The team has decided to assign you the task of collecting the dataset in an optimized manner.

As one can see if we go on to collect each word according to their frequency the storage usage can become quite large. So you came up with the idea of storing the unique words(alphabet's case matters here) with their frequency in a pandas series object, as this data can be used in different processes more accurately.

Let's say you are given the raw data in form of a string, for storing all the words write a program which can take a string as an input and return the unique words and the corresponding frequency in form of a Pandas Series object. The indices of the series should be the unique words and the values should be the frequency of those unique words.
Just complete the function that returns a Series object.

Notes

String contains no special character.
Always a Non-empty string.
Case sensitive i.e. He and he should be treated as two different word tokens.
Series indices are sorted by python inbuilt function.
The code for taking input and printing the series is already written, you just have to complete the function that returns a series which satisfies all the requirements.
Optional : Using same strategies you can also look up to approaches and functions to sort the words according to their frequencies.


Input Format
String with space separated words. (basically a sentence)

Output Format
space separated words in first line.
space separated values in the second line.

Sample Input
He said he is the king
Sample Output
He he is king said the

1 1 1 1 1 1 
",N/A
Max registrations they asked?,https://www.interviewbit.com/problems/max-registrations-they-asked/,N/A,Data Analysis,medium,"Problem Description

You're given a record of students with their registration dates from 01/01/2011 to 01/05/2021. You're also given with the marks scored by each of the students in Physics, Chemistry, and Mathematics. You need to find out the month that observed the maximum registrations. Then return the average marks scored in each subject. In case of a tie, select the month that comes later.

Input Format
Total five lines, each element in a line is space-separated. First line contains the Registration dates, followed by Registration IDs, and marks scores in Physics, Chemistry and Mathematics respectively in the next lines. You need to take STDIN and make use of Pandas library to return the answer.

Output Format
Output will be one single line containing the name of the month in abbreviations followed by the number of registrations and average marks in each subjects.

Sample Input
2015-12-06 2011-12-27 2015-09-07 2012-12-21 2020-02-13 2015-06-09 2013-03-21 2012-09-22 2013-06-19 2016-03-05 2017-08-27 2012-06-24 2018-11-20 2018-05-24 2019-08-17 2018-08-22 2021-02-07 2016-09-01 2015-03-11 2011-06-30 2019-11-15 2016-11-30 2019-05-19 2012-03-26 2020-08-11 2014-09-12 2014-12-11 2013-12-16 2017-02-28 2011-04-01 2011-01-01 2017-11-25 2014-03-16 2014-06-14 2013-09-17 2020-05-13 2018-02-23 2019-02-18 2011-09-28 2016-06-03 2020-11-09 2017-05-29

498 721 375 464 813 853 918 422 380 403 445 665 43 281 730 39 63 560 56 901 802 3 247 863 223 510 89 813 940 800 292 289 429 241 745 796 529 9 909 495 373 397

22 45 1 65 22 17 12 51 37 40 36 58 0 53 33 13 39 53 18 46 68 30 37 56 3 63 40 18 40 25 36 12 39 8 32 69 21 43 10 9 31 56

52 56 32 50 24 61 17 0 28 39 56 33 19 10 38 14 41 7 59 1 50 8 6 10 20 19 68 46 13 1 54 2 40 66 14 39 6 51 23 20 11 68

63 37 68 62 43 42 56 36 50 7 20 21 44 55 10 4 18 24 27 67 59 56 17 56 45 66 21 10 27 39 64 32 8 3 1 8 1 50 33 19 6 41

Sample Output
SEP 6 35.0 15.83 38.0

Notes

Round up to 2 decimal points.
Refer to 3-letter abbreviations for each month, i.e. JAN for January, FEB for February, and so on.
",N/A
Row-wise unique,https://www.interviewbit.com/problems/row-wise-unique/,N/A,Data Analysis,medium,"Problem Description

You are collaborating with a tech team for an EdTech organisation. It is currently working on a special feature for Instructors' dashboard which will help the instructor in knowing about the engagement of his students for the class Assignments in the form of number of times a particular student contacts his/her TA (Teaching Assistant) on a particular day.

So whenever a student with an id i contacts his TA on jth day, i is stored in the jth row of a matrix for that particular batch. As you can see this data storage can become very large as a student can contact his/her TA multiple times in a day and there can be a significant number of batches also. The team is facing this storage issue.

Here you are asked to create a prototype program which is just for a batch of 10 students and for m days for visualising the solution on a large scale.

For the program the input matrix consists of elements with values 1-10 (students' ids) of dimension mxn, the output is expected to be a 2d list of dimension m*10 (m is the number of days and 10 columns because students number is only 10 here), but this time the elements will be the count of the that element in that particular row i.e. the number of times a student contacts on ith day.

Input Format:
number of test cases
for each test case (number of rows for matrix)
for each row in matrix space separated integers in a new line

Output Format:
The 2dlist is simply printed

Sample input:
1
5
1 1 2 5 7 6 7 7 6 3 
8 5 4 7 5 2 6 10 1 7 
4 3 10 4 4 4 3 1 4 3 
1 4 1 1 8 4 9 8 5 5 
1 1 4 4 2 10 5 6 8 1 

Sample output:
[[2, 1, 1, 0, 1, 2, 3, 0, 0, 0], [1, 1, 0, 1, 2, 1, 2, 1, 0, 1], [1, 0, 3, 5, 0, 0, 0, 0, 0, 1], [3, 0, 0, 2, 2, 0, 0, 2, 1, 0], [3, 1, 0, 2, 1, 1, 0, 1, 0, 1]]
where you can see that in the output[0][0], the element is 1 which depicts that 1 occurs only single time in the 1st row in the input matrix.

Note:
Here you don't have to write the code for taking input its already included in the code suffix which you would be able to see right below the function editor.
The output is a simple 2d matrix(2d list) printed simply without any formatting.
",N/A
How not to retrieve?,https://www.interviewbit.com/problems/how-not-to-retrieve/,N/A,Data Analysis,easy,"Given a numpy array (np.arange(5, 30, 2)) and you are asked to retrieve all the values that are multiple of 3 and within the range of 5 and 25. Which of the following doesn’t return the required output? The required output is [ 9 15 21].

a.

boolArr = (arr < 25) & (arr>5) & (arr%3==0)
newArr = arr[boolArr]

b.

newArr = arr[(arr>5) & (arr<25) & (arr%3==0)]

c.

whfnc=np.where((arr<25) & (arr%3==0) & (arr%3==0))
arr[whfnc]

d.

arr[np.all([arr<25, arr%3==0, arr>5], axis=0)]

e.

boolArr = arr < 25 & arr>5 & arr%3==0
newArr = arr[boolArr]a
b
c
d
e",N/A
Fill Infinite,https://www.interviewbit.com/problems/fill-infinite/,N/A,Data Analysis,easy,"Which of these can be used to generate a 2x2 array of numpy.inf, something which will look like this

[[inf inf] 
[inf inf]]","numpy.full((2, 2), numpy.inf)
numpy.fill((2, 2), numpy.inf)
numpy.gen(numpy.inf, (2,2))
numpy.gen((2,2), numpy.inf)"
IQR outlier detection,https://www.interviewbit.com/problems/iqr-outlier-detection/,N/A,Descriptive Statistics,medium,"Outliers are certain points in the data set which deviate from the general trends in the dataset. There are several ways to detect outliers. In this problem, we will use the median absolute deviation method to find outliers. According to this method:

Find the Inter-quartile range [Q3 - Q1]
Upper range is computed as Q3 + 1.5*IQR
Lower range is computed as Q1 - 1.5*IQR
Values that have high values than upper range are suspected to be outliers.
Values that have low values than lower range are suspected to be outliers.
Complete the function that identifies the outliers and return them by applying the function on the input list.

Input Format

Number of testcases
N space separated integers as an input for each testcase
Output Format

Space separated integers but there isn't any space after the last element.
only outliers are printed
Example Input

2
1 1 2
10 10 6 9 4 5 7 1 8 929 100
Example Output

1 929 100
Note:

The code for taking input is already taken care of.
Make sure to print the outliers in the function itself in the required format.",N/A
Variability measures,https://www.interviewbit.com/problems/variability-measures/,N/A,Descriptive Statistics,medium,"Given an array A containing N integers, find the variance and standard deviation of the array. Print your answer up to 2 decimal points. 

Problem Constraints

1<N<1000. 1<=A[i]<=1000
Input Format:

Number of testcases
For each test space separated integers are listed in a new line.
Ouput Format:

standard deviation and variance in this order for each test case in a new line.
Example Input:

2
10 10 20 20 30 4
1 2 3 4 5 6 7 8
Example Output:

8.6 74.0
2.24 5.0
Note:

The code for the function is for a single test case as it's called under a loop of range t (number of test cases).
You have to include code to take input for a single test case.
Print the output in the required manner for a test case.
While taking input take care that list members can be float or int.",N/A
Sum of 7's Multiple,https://www.interviewbit.com/problems/sum-of-7-s-multiple/,N/A,Math,easy,"Problem Description
 
 

Given a range [A, B], find sum of integers divisible by 7 in this range.


Problem Constraints
1 <= A <= B <= 109


Input Format
First argument is an integer A.
Second argument is an integer B.


Output Format
Return an integer.


Example Input
Input 1:
A = 1
B = 7
Input 2:
A = 99
B = 115


Example Output
Output 1:
7
Output 2:
217


Example Explanation
Explanation 1:
Integers divisible by 7 in given range are {7}.
Explanation 2:
Integers divisible by 7 in given range are {105, 112}.
","public class Solution {
    public Long solve(int A, int B) {
        return (get(B) - get(A-1)); 
    }
    public long get(int x){
        long n =  (x/7);
        long ans = 7*(n*(n+1))/2;
        return ans;
    }
}"
Find Last Digit,https://www.interviewbit.com/problems/find-last-digit/,N/A,Math,easy,"Problem Description
 
 

Find last digit of the number AB.
A and B are large numbers given as strings.


Problem Constraints
1 <= |A| <= 105
1 <= |B| <= 105


Input Format
First argument is a string A.
First argument is a string B.


Output Format
Return an integer.


Example Input
Input 1:
A = 2
B = 10
Input 2:
A = 11
B = 11


Example Output
Output 1:
4
Output 2:
1


Example Explanation
Explanation 1:
210 = 1024, hence last digit is 4.
Explanation 2:
1111 = 285311670611, hence last digit is 1.
","int Solution::solve(string A, string B) {
    int k = A.back() - '0';
    vector<int> v(1, k);
    while (true) {
        int x = v.back() * k;
        x %= 10;
        if (x == v[0]) {
            break;
        } else {
            v.push_back(x);
        }
    }
    int n = v.size();
    int b = 0;
    int mul = 1;
    for (int i = B.size() - 1; i >= 0; --i) {
        int x = B[i] - '0';
        b = (b + x * mul) % n;
        mul = (mul * 10) % n;
    }
    b = (b - 1 + n) % n;
    return v[b];
}"
Town Selection,https://www.interviewbit.com/problems/town-selection/,N/A,SQL Programming,easy,"Given a table Towns, query for all the attributes in the table.

The description of the table Towns is given as follows:

Towns Image

NOTE : All the fields should have the same Name and should be in the same order.

Example:
","/* YOUR QUERY GOES HERE
   Example: SELECT * FROM EMPLOYEE; 
*/
SELECT * FROM Towns;"
Town Queries,https://www.interviewbit.com/problems/town-queries/,N/A,SQL Programming,easy,"Given a table Towns, query for all the Towns which have a Population greater than 1000.

The description of the table Towns is given below:

Image

NOTE : The output table should have the same names and order of the columns.

Example:
","We will use the SELECT command to select all the attributes, filtering those values with population greater than 1000. The filter is done

using the WHERE clause.

Code:

SELECT * FROM Towns WHERE Population > 1000;"
Last digit K count,https://www.interviewbit.com/problems/last-digit-k-count/,N/A,Math,easy,"Problem Description
 
 

Find the number of integers in range [A, B] with last digit C.


Problem Constraints
1 <= A <= B <= 109
0 <= C <= 9


Input Format
Given three integers A, B and C.


Output Format
Return an integer.


Example Input
Input 1:
A = 11, B = 111, C = 1
Input 2:

A = 1, B = 9, C = 0


Example Output
Output 1:
11
Output 2:

0


Example Explanation
Explanation 1:
The integers are 11, 21, 31, 41, 51, 61, 71, 81, 91, 101, 111
Explanation 2:

There are no integers in the range with last digit 0.","int get(int x, int C) {
    int ans = x / 10;
    ans += (x % 10 >= C);
    return ans;
}
int Solution::solve(int A, int B, int C) {
    return get(B, C) - get(A - 1, C);
}"
Double Increasing Series,https://www.interviewbit.com/problems/double-increasing-series/,N/A,Dynamic Programming,medium,"Problem Description
 
 

Given two integers A and B.
Find the number of sequences of length B, such that every element of this sequence is an positive integer and is less than of equal to A, also every previous element in the sequence is less than or equal to half of the next element.


Problem Constraints
1 <= A <= 105
1 <= B <= 20


Input Format
Given two integers A and B.


Output Format
Return an integer, the number of possible sequences modulo 109+7.


Example Input
Input 1:
A = 4, B = 2
Input 2:

A = 4, B = 3


Example Output
Output 1:
4
Output 2:

1


Example Explanation
Explanation 1:
The possible sequences are {1, 2}, {1, 3}, {1, 4}, {2, 4}.
Explanation 2:

The only possible sequence is {1, 2, 4}.
","const int mod =1e9+7;
int Solution::solve(int A, int B) {
    assert(1<=A && A<=1e5);
    assert(1<=B && B<=20);
    int dp[A+1][B+1];
    memset(dp, 0, sizeof(dp));
    for(int i=1;i<=A;i++){
        for(int j=1;j<=B;j++){
            if(j==1){
                dp[i][j]=i;
            }
            else{
                dp[i][j]=dp[i-1][j]+dp[i/2][j-1];
            }
            dp[i][j]%=mod;
        }
    }
    return dp[A][B];
}"
Greater of Lesser,https://www.interviewbit.com/problems/greater-of-lesser/,N/A,Arrays,easy,"Problem Description
 
 

Given two integer arrays A and B, and an integer C.
Find the number of integers in A which are greater than C and find the number of integers in B which are less than C.
Return maximum of these two values.


Problem Constraints
1 <= |A|, |B| <= 105
1 <= Ai, Bi, C <=109


Input Format
First argument is an integer array A.
Second argument is an integer array B.
Third argument is an integer C.


Output Format
Return an integer.


Example Input
Input 1:
A = [1, 2, 3, 4]
B = [5, 6, 7, 8]
C = 4
Input 2:

A = [1, 10, 100]
B = [9, 9, 9]
C = 50


Example Output
Output 1:
0
Output 2:

3


Example Explanation
Explanation 1:
There are no integers greater than C in A.
There are no integers less than C in B.
Explanation 2:

Integers greater than C in A are [100].
Integers less than C in A are [9, 9, 9].
","int Solution::solve(vector<int> &A, vector<int> &B, int C) {
    int c1 = 0, c2 = 0;
    assert(1<=C && C<=1e9);
    assert(1<=A.size() && A.size()<=1e5);
    assert(1<=B.size() && B.size()<=1e5);
    for (int x: A) {
        assert(1 <= x && x <= 1e9);
        if (x > C) {
            c1++;
        }
    }
    for (int x: B) {
        assert(1 <= x && x <= 1e9);
        if (x < C) {
            c2++;
        }
    }
    return max(c1, c2);
}"
Frequency of Characters,https://www.interviewbit.com/problems/frequency-of-characters/,N/A,Strings,easy,"Problem Description
 
 

Given a string A, find the frequency of all the characters in it.


Problem Constraints
1 <= |A| <= 105
Ai = {Lowercase latin alphabets}


Input Format
Given a string A.


Output Format
Return an integer array of length 26.
Array should contain frequency of characters in increasing order of characters.


Example Input
Input 1:
A = ""abcdefghijklmnopqrstuvwxyz""
Input 2:

A = ""interviewbit""


Example Output
Output 1:
{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
Output 2:

{0, 1, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 2, 0, 1, 1, 0, 0, 0}


Example Explanation
Explanation 1:
Every charcater is present once in the string.
Explanation 2:

'b' is at indices 10.
'e' is at indices 4, 8
'i' is at indices 1, 7, 11
'n' is at indices 2
'r' is at indices 5
't' is at indices 3, 12
'v' is at indices 6
'w' is at indices 9
Rest of the characters are not present in the string","vector<int> Solution::solve(string A) {
    assert(1<=A.size() && A.size()<=1e5);
    vector<int> cnt(26, 0);
    for(char x: A){
        assert('a'<=x && x<='z');
        cnt[x-'a']++;
    }
    return cnt;
}"
Spiral Matrix,https://www.interviewbit.com/problems/spiral-matrix/,N/A,Arrays,easy,"Problem Description
 
 

Given an array of A of length B×C.
Make a Spiral matrix (2D array) of B rows and C columns.

Note: See example input for pattern.


Problem Constraints
1 <= Ai <=105
1 <= B×C <= 105


Input Format
First argument is an integer array A.
Second argument is an integer B.
Third argument is an integer C.


Output Format
Return 2D integer array.


Example Input
Input 1:
A = [1, 2, 4, 8]
B = 2
C = 2
Input 2:

A = [1, 2, 3, 4, 5, 6, 7, 8, 9]
B = 3
C = 3


Example Output
Output 1:
[[1, 2],
 [8, 4]]
Output 2:

[[1, 2, 3],
 [8, 9, 4],
 [7, 6, 5]]
","int dx[] = {0, 1, 0, -1};
int dy[] = {1, 0, -1, 0};
vector < vector < int > > Solution::solve(vector < int > & A, int B, int C) {
    assert(1 <= A.size() && A.size() <= 1e5);
    assert(A.size() == B * C);
    int j = 0;
    int x = 0, y = -1;
    vector < vector < int >> ans(B, vector < int > (C, 0));
    for (int i = 0; i < B * C; ++i) {
        assert(1 <= A[i] && A[i] <= 1e5);
        int xx = x + dx[j];
        int yy = y + dy[j];
        if (xx < 0 || xx >= B || yy < 0 || yy >= C || ans[xx][yy] != 0) {
            j = (j + 1) % 4;
            xx = x + dx[j];
            yy = y + dy[j];
        }
        ans[xx][yy] = A[i];
        x = xx;
        y = yy;
    }
    return ans;
}"
Student Query,https://www.interviewbit.com/problems/student-query/,N/A,SQL Programming,easy,"Given a table STUDENT, query for all the Names with Class 1 and SubjectCount greater than 3.

The description of the table STUDENT  is given below:

Image

NOTE : The name of the output column should be ‘Name’.

Example:

 ","/* YOUR QUERY GOES HERE
   Example: SELECT * FROM EMPLOYEE; 
*/
SELECT Name FROM STUDENT WHERE Class = 1 AND SubjectCount > 3;"
Collatz Conjecture,https://www.interviewbit.com/problems/collatz-conjecture/,N/A,Time Complexity,easy,"Problem Description
 
 

Given two integers A and B, where A is the first element of the sequence then find Bth element of the sequence.
If the kth element of the sequence is X then k+1th element calculated as:
if X is even then next element is X/2.
else next element is 3×X + 1.


Problem Constraints
1 <= A <= 109
1 <= B <= 105


Input Format
Given two integers A and B.


Output Format
Return an integer.


Example Input
Input 1:
A = 1
B = 3
Input 2:

A = 5
B = 6


Example Output
Output 1:
2
Output 2:

1


Example Explanation
Explanation 1:
 The sequence is as follows 1 -> 4 -> 2
Explanation 2:

The sequence is as follows 5 -> 16 -> 8 -> 4 -> 2 -> 1","long Solution::solve(int A, int B) {
    assert(1 <= A && A <= 1e9);
    assert(1 <= B && B <= 1e5);
    long ans = A;
    for (int i = 1; i < B; i++) {
        if (ans % 2) {
            ans = 3 * ans + 1;
        } else {
            ans /= 2;
        }
    }
    return ans;
}"
Country Filtration,https://www.interviewbit.com/problems/country-filtration/,N/A,SQL Programming,easy,"Given a table COUNTRY, query for all the country names with Code NA.

The description of the table COUNTRY is as given below:

Image

NOTE : The output table should contain one column ‘Name’ . 

Example : 
","The WHERE clause is used along with the SELECT clause to filter some attributes based on some given condition.

Code:

SELECT Name FROM COUNTRY WHERE Code = 'NA';"
Information Selector,https://www.interviewbit.com/problems/information-selector/,N/A,SQL Programming,easy,"Given a table STUDENTS, query for all the student’s Name and Class whose Age is greater than 15.

The description of the STUDENTS table is as given below:

Image

NOTE : The output table should contain 2 columns ‘Name’ and ‘Class’.

Example :
","/* YOUR QUERY GOES HERE
   Example: SELECT * FROM EMPLOYEE; 
*/
SELECT Name, Class FROM STUDENTS WHERE Age > 15;"
Town Of Threes,https://www.interviewbit.com/problems/town-of-threes/,N/A,SQL Programming,easy,"Given a table TOWNS, query for all the Town Names and Population, such that the ID is a multiple of 3.

The description of the table TOWNS is as given below:

Image

NOTE : The output should contain 2 columns ‘TownName’ and ‘Population’

Example :
","We can add any boolean expression to our SELECT clause filter with the WHERE clause. The condition that will be added in the WHERE

clause is “If TownID % 3 = 0, return true, else false”. Also to SELECT multiple attributes, we write them separated by commas.

Code:

SELECT TownName, Population FROM TOWNS WHERE ID % 3 = 0;"
Digital Root,https://www.interviewbit.com/problems/digital-root/,N/A,Math,easy,"Problem Description
 
 

Given an integer A.
Find the digital root of A.
Digital root is the repeated sum of digits of untill there is only one digit left.


Problem Constraints
1 <= A <= 109


Input Format
Given an integer A.


Output Format
Return an integer.


Example Input
Input 1:
A = 99
Input 2:

A = 100


Example Output
Output 1:
9
Output 2:

1


Example Explanation
Explanation 1:
99 -> 9+9 = 18 -> 1+8 = 9
Explanation 2:

100 -> 1+0+0 = 1
","int digit_sum(int x){
    int sum=0;
    while(x > 0){
        sum += x%10;
        x/=10;
    }
    return sum;
}
int Solution::solve(int A) {
    while(A > 9){
        A = digit_sum(A);
    }
    return A;
}"
Product of All,https://www.interviewbit.com/problems/product-of-all/,N/A,Arrays,easy,"Problem Description
 
 

Given an integer array A.
Create an array B such that Bi is the product of all elements of A excluding Ai.
Since the products can be too large take modulo 109 +7.


Problem Constraints
1 <= |A| <= 105
1 <= Ai <= 109


Input Format
Given an integer array A.


Output Format
Return an integer array.


Example Input
Input 1:
A = [1, 2, 3, 4]
Input 2:

A = [9, 9, 9]


Example Output
Output 1:
[24, 12, 8, 6]
Output 2:

[81, 81, 81]


Example Explanation
Explanation 1:
[2×3×4, 1×3×4, 1×2×4, 1×2×3]
Explanation 2:

[9×9, 9×9, 9×9]
","vector<int> Solution::solve(vector<int> &A) {
    int mod = 1e9+7;
    int n = A.size();
    assert(1<=n && n<=1e5);
    for(int &x: A)assert(1<=x && x<=1e9);
    long long pre[n], suf[n];
    pre[0] = 1;
    for(int i = 1; i < n; ++i){
        pre[i] = (pre[i-1]*A[i-1])%mod;
    }
    suf[n-1] = 1;
    for(int i = n-2; i >= 0; --i){
        suf[i] = (suf[i+1]*A[i+1])%mod;
    }
    vector<int> ans(n);
    for(int i = 0; i < n; ++i){
        ans[i] = (pre[i]*suf[i])%mod;
    }
    return ans;
}"
Chips Factory,https://www.interviewbit.com/problems/chips-factory/,N/A,Arrays,easy,"Problem Description
 
 

A chips factory is packing chips in packets.
The packets of chips are represented as an array A.
Find the packet of chips which are empty (Ai = 0) and move them to the end of the array.
Return the resultant array.


Problem Constraints
1 <= |A| <= 105
0 <= Ai <= 109


Input Format
Given an integer array A.


Output Format
Return an integer array.


Example Input
Input 1:
A = [0, 1, 2, 3]
Input 2:

A = [1, 0, 0, 0]


Example Output
Output 1:
[1, 2, 3, 0]
Output 2:

[1, 0, 0, 0]


Example Explanation
Explanation 1:
The only empty packet is at index 1 so we move it last of the array.
Explanation 2:

The  packets are already in required arrangement.
","vector<int> Solution::solve(vector<int> &A) {
    vector<int> ans;
    int cnt = 0;
    for(int x: A){
        assert(0<=x && x<=1e9);
        if(x == 0){
            cnt++;
        }
        else{
            ans.push_back(x);
        }
    }
    while(cnt > 0){
        ans.push_back(0);
        cnt--;
    }
    return ans;
}"
Bit Flipping,https://www.interviewbit.com/problems/bit-flipping/,N/A,Bit Manipulation,easy,"Problem Description
 
 

Given an integer A.
Write binary representation of the integer without leading zeros.
Flip all bits then return the integer value of the binary number formed.
Flipping means 0 -> 1 and 1 -> 0.


Problem Constraints
1 <= A <= 109


Input Format
Given an integer A.


Output Format
Return an integer.


Example Input
Input 1:
A = 7
Input 2:

A = 5


Example Output
Output 1:
0
Output 2:

2


Example Explanation
Explanation 1:
7 -> 111 -> 000 ->0
Explanation 2:

5 -> 101 -> 010 ->2
","int Solution::solve(int A) {
    assert(1<=A && A<=1e9);
    int x = 1;
    while(x <= A){
        x <<= 1;
    }
    x--;
    return (x ^ A);
}"
Number of Sundays,https://www.interviewbit.com/problems/number-of-sundays/,N/A,Math,easy,"Problem Description
 
 

Given the start day of the month A and number of days in the month B, find number of sundays in the month.


Problem Constraints
A = {""Monday"", ""Tuesday"", ""Wednesday"", ""Thursday"", ""Friday"", ""Saturday"", ""Sunday""}
1 <= B <= 109


Input Format
First argument is an string A.
Second argument is an integer B.


Output Format
Return an integer.


Example Input
Input 1:
A = ""Sunday""
B = 1
Input 2:

A = ""Monday""
B = 14


Example Output
Output 1:
1
Output 2:

2


Example Explanation
Explanation 1:
The only day in the month is sunday.
Explanation 2:

The 7th and 14th day of the month will be sunday
","int Solution::solve(string A, int B) {
    map <string, int> ext;
    ext[""Monday""] = 0;
    ext[""Tuesday""] = 1;
    ext[""Wednesday""] = 2;
    ext[""Thursday""] = 3;
    ext[""Friday""] = 4;
    ext[""Saturday""] = 5;
    ext[""Sunday""] = 6;
    assert(ext.find(A) != ext.end());
    assert(1<=B && B<=1e9);
    B += ext[A];
    B /= 7;
    return B;
}"
Greater than All,https://www.interviewbit.com/problems/greater-than-all/,N/A,Arrays,easy,"Problem Description
 
 

Given an integer array A.
Find the count of elements whose value is greater than all of its previous elements.

Note: Since there are no elements before first element so it should be considered in our answer.


Problem Constraints
1 <= |A| <= 105
1 <= Ai <= 109


Input Format
Given an integer array A.


Output Format
Return an integer.


Example Input
Input 1:
A = [1, 2, 3, 4]
Input 2:

A = [1, 1, 2, 2]


Example Output
Output 1:
4
Output 2:

2


Example Explanation
Explanation 1:
All elements are greater than all of its prior elements.
Explanation 2:

Index 1 will be considerd in answer.
Also Elements at index 3 is greater than all of it's previous elements.
","int Solution::solve(vector<int> &A) {
    int mx = 0;
    int ans = 0;
    assert(1<=A.size() && A.size()<=1e5);
    for(int x: A){
        assert(1<=x && x<=1e9);
        if(x > mx){
            ans++;
            mx = x;
        }
    }
    return ans;
}"
Product of Digits,https://www.interviewbit.com/problems/product-of-digits/,N/A,Math,easy,"Problem Description
 
 

Given an integer A.
Find the product of all of it's digits.


Problem Constraints
0 <= A <= 109


Input Format
Given an integer.


Output Format
Return an integer.


Example Input
Input 1:
A = 111
Input 2:

A = 123


Example Output
Output 1:
1
Output 2:

6


Example Explanation
Explanation 1:
111 -> 1×1×1 = 1
Explanation 2:

123 -> 1×2×3 = 6
","int Solution::solve(int A) {
    assert(0<=A && A<=1e9);
    int product = 1;
    do{
        product *= A%10;
        A /= 10;
    }
    while(A > 0);
    return product;
}"
Firefighter's Average,https://www.interviewbit.com/problems/firefighter-s-average/,N/A,SQL Programming,easy,"Given a table FIREFIGHTERS, query the average of all the people saved by the Firefighters whose CountryCode is PM.

The description of the table FIREFIGHTERS is as follows:

Image

NOTE : The output should contain only 1 column ‘AVG(PeopleSaved)’ .

Example : 
","The AVG() function is used to calculate the average value of some attribute in the given table. Using this function, we can SELECT the

average of the number of people saved, by the firefighters who belong to the country code “PM”.

Code:

SELECT AVG(PeopleSaved) FROM FIREFIGHTERS WHERE CountryCode = 'PM';"
Firefighter's Sum,https://www.interviewbit.com/problems/firefighter-s-sum/,N/A,SQL Programming,easy,"Given a table FIREFIGHTERS, query the sum of all the people saved by the Firefighters whose CountryCode is PG.

The description of the table FIREFIGHTERS is as follows:

Image

NOTE : The output should contain 1 column by the name ‘SUM(PeopleSaved)’.

Example : 
","The SUM() function returns the sum of all the attributes which satisfies some given condition. The condition is that CountryCode = PG,

which can be specified using the WHERE clause.

Code:

SELECT SUM(PeopleSaved) FROM FIREFIGHTERS WHERE CountryCode = 'PG';"
Largest Difference,https://www.interviewbit.com/problems/largest-difference/,N/A,SQL Programming,easy,"Given a table FIREFIGHTERS, find the largest difference between the number of people saved by 2 firefighters.

The description of the table FIREFIGHTERS is given below:

Image

NOTE : The output should contain only one column by the name ‘A’.

Example :
",select MAX(PeopleSaved) - MIN(PeopleSaved) as A from FIREFIGHTERS
Maximum Substring,https://www.interviewbit.com/problems/maximum-substring/,N/A,Strings,easy,"Problem Description
 
 

Given a string A consisting of only characters 'a' and 'b'.
Divide the string into substrings of length B.
Find the subtring with maximum count of 'a' and return the count.

Note: If the length of the string is not a multiple of B and there are some characters left in the end consider them also as a substring.


Problem Constraints
1 <= |A| <= 105
Ai = {'a', 'b'}
1 <= B <= 105


Input Format
First argument A is a string.
Second argument is an integer B.


Output Format
Return an integer.


Example Input
Input 1:
A = ""baab""
B = 2
Input 2:

A = ""bba""
B = 2


Example Output
Output 1:
1
Output 2:

1


Example Explanation
Explanation 1:
The subtrings are ""ba"" and ""ab"".
Both have count of 'a' equal to 1.
Explanation 2:

The substrings are ""bb"" and ""a"".
""a"" has the highest count which is 1.
","int Solution::solve(string A, int B) {
    int n = A.size();
    assert(1<=n && n<=1e5);
    assert(1<=B && B<=1e5);
    for(char x: A)assert(x=='a'||x=='b');
    int ans = 0;
    int cnt = 0;
    for(int i = 0; i < n; ++i){
        if(i%B == 0){
            ans = max(ans, cnt);
            cnt = 0;
        }
        if(A[i] == 'a'){
            cnt++;
        }
    }
    ans = max(ans, cnt);
    return ans;
}"
Round Table,https://www.interviewbit.com/problems/round-table/,N/A,Math,easy,"Problem Description
 
 

There is a party at Ram's house, he will be inviting A friends to his party.
There is round table at his house which has A+1 seats.
Among all those friends Shyam is Ram's best friend and Ram wants to sit with him.
Find the number of ways to sit such that Ram and Shayam will sit together.
Since this number can be very large take modulo 109 + 7.


Problem Constraints
1 <= A <= 105


Input Format
Given an integer A.


Output Format
Return an integer.


Example Input
Input 1:
A = 1
Input 2:

A = 2


Example Output
Output 1:
2
Output 2:

4


Example Explanation
Explanation 1:
Let the two people be
1 -> Ram
2 -> Shyam
Then the possible arrangements are {1, 2}, {2, 1}
Explanation 2:

Let the three people be
1 -> Ram
2 -> Shyam
3 -> Third friend
Then the possible arrangements are {1, 2, 3}, {3, 1, 2}, {2, 1, 3}, {3, 2, 1}
","int Solution::solve(int A) {
    assert(1<=A && A<=1e9);
    int mod = 1e9 + 7;
    long long ans = 2;
    for(int i = 2; i <= A; ++i){
        ans *= i;
        ans %= mod;
    }
    return ans;
}"
Odd Even Rule,https://www.interviewbit.com/problems/odd-even-rule/,N/A,Math,easy,"Problem Description
 
 

Due to pollution Delhi government has applied odd even rule in Delhi.
Traffic police on guard is recording the registration number of vehicles passing through his area and storing the last digit of the number in an array A.
You are given the array A and date of the day B. Also fine for breaking the rule is C Rs.
Find the total fine in Rs collected by the traffic police.


Problem Constraints
1 <= |A| <= 105
1 <= B <= 31
1 <= C <= 1000


Input Format
First arguement is an integer array A.
Second argument is an integer B.
Third argument is an integer C.


Output Format
Return an integer.


Example Input
Input 1:
A = [1, 2, 3]
B = 31
C = 100
Input 2:

A = [0, 1, 1]
B = 2
C = 51


Example Output
Output 1:
100
Output 2:

102


Example Explanation
Explanation 1:
Vehicle 2 is not following the rule so only he will be fined.
Explanation 2:

Vehicle 2 and 3 are not following the rule so both of them will be fined.
","int Solution::solve(vector<int> &A, int B, int C) {
    int n = A.size();
    assert(1<=n && n<=1e5);
    assert(1<=B && B<=31);
    assert(1<=C && C<=1000);
    int ans = 0;
    B %= 2;
    for(int &x: A){
        if(x%2 != B){
            ans += C;
        }
    }
    return ans;
}"
Distance Maximizer,https://www.interviewbit.com/problems/distance-maximizer/,N/A,SQL Programming,medium,"Given a table HOUSES, find the manhattan distance of the house which is the farthest from John’s house which lies at coordinates (20, 4).

Basically you have to find the manhattan distance of some house which is the maximum amongst all the other houses from John’s house.

Manhattan Distance between 2 points P(x1, y1), Q(x2, y2) is given as |x1 - x2| + |y1 - y2|.

The description of the table HOUSES is given below:



NOTE : The output should contain only 1 column by the name ‘A’ .

Example :
","/*
The function which calculates maximum value over some values is the MAX() function. For each of the house coordinates, we will calculate
its Manhattan Distance from the point (20, 4) and SELECT the maximum of them all.
*/

select MAX(ABS(XCoordinate - 20) + ABS(YCoordinate - 4)) as A from HOUSES;"
Euclid's Distance,https://www.interviewbit.com/problems/euclid-s-distance/,N/A,SQL Programming,medium,"Given a table HOUSES, find the euclidean distance between points with the largest X and Y coordinate, and the points with the smallest X and Y coordinate.

The Euclidean Distance between 2 points P(x1, y1) and Q(x2, y2) is defined as: sqrt((x1 - x2)2 + (y1 - y2)2).

The description of the table HOUSES is given as follows:



NOTE : The output should contain one column by the name ‘A’ .

Example :
","/*
The points with largest and smallest corresponding coordinates can be found with the MAX() and MIN() function. Using this corresponding points
we can use the formula given for Euclidean Distance between 2 points to calculate and SELECT the result. The SQRT function can calculate the
square root of a given number.
*/

SELECT SQRT((MAX(XCoordinate) - MIN(XCoordinate)) * (MAX(XCoordinate) - MIN(XCoordinate)) + (MAX(YCoordinate) - MIN(YCoordinate)) * (MAX(YCoordinate) - MIN(YCoordinate))) as A FROM HOUSES;"
Big Salary,https://www.interviewbit.com/problems/big-salary/,N/A,SQL Programming,medium,"Given a table WORKERS, find how many workers have the maximum total earnings among all the workers.

The total earnings of a worker is calculated as Daily Wage * Number of Days Worked.

The description of the table workers is given below:

Image

NOTE : The output should contain one column by the name ‘A’.
","/*
We can use the COUNT() function to count number of occurences of the maximum earnings amongst all the the workers. The maximum earnings can
be calculated by using the MAX() function. The condition to calculate the count will be to calculate the count for all those attributes
where the earnings is equal to the maximum earnings calculated.
*/

SELECT COUNT(DaysWorked * DailyWage) as A FROM WORKERS WHERE DailyWage * DaysWorked = (SELECT MAX(DailyWage * DaysWorked) FROM WORKERS);"
Armstrong Number,https://www.interviewbit.com/problems/armstrong-number/,N/A,Math,easy,"Problem Description
 
 

Given an integer A, check if it is an Armstrong number of not.
An Armstrong number is a number that is the sum of its own digits each raised to the power of the number of digits.


Problem Constraints
1 <= A <= 109


Input Format
Given an integer A.


Output Format
Return an integer.


Example Input
Input 1:
A = 371
Input 2:

A = 123


Example Output
Output 1:
1
Output 2:

0


Example Explanation
Explanation 1:
3×3×3 + 7×7×7 + 1×1×1 = 371
Explanation 2:

1×1×1 + 2×2×2 + 3×3×3 != 123
","int Solution::solve(int A) {
    assert(1<=A && A<=1e9);
    int B = A;
    long long sum = 0;
    int cnt[10] = {0};
    int d = 0;
    while(B > 0){
        int k = B%10;
        cnt[k]++;
        d++;
        B /= 10;
    }
    for(int i = 1; i < 10; ++i){
        long long p = 1;
        for(int j = 0; j < d; ++j){
            p *= i;
        }
        sum += p*cnt[i];
    }
    if(A == sum){
        return 1;
    }
    return 0;
}"
Leap Year,https://www.interviewbit.com/problems/leap-year/,N/A,Math,easy,"Problem Description
 
 

Given an integer A, which represents a year.
Check if it is a Leap year or not.


Problem Constraints
1 <= A <= 109


Input Format
Given an integer A.


Output Format
Return an integer.


Example Input
Input 1:
A = 2020
Input 2:

A = 2021


Example Output
Output 1:
1
Output 2:

0


Example Explanation
Explanation 1:
Year 2020 is leap year
Explanation 2:

Year 2021 is not a leap year","int Solution::solve(int A) {
    assert(1<=A && A<=1e9);
    if(A%400 == 0){
        return 1;
    }
    if(A%4 == 0 && A%100!=0){
        return 1;
    }
    return 0;
}"
Conditional Work,https://www.interviewbit.com/problems/conditional-work/,N/A,SQL Programming,medium,"Given a table NUMBERS, determine for each row, if the sum of the numbers are ‘Positive’, ‘Negative’, or ‘Zero’.

The description of the table NUMBERS is given below:

Image

Note: Output should be printed with column name A.
Example:
 Example","/* YOUR QUERY GOES HERE
   Example: SELECT * FROM EMPLOYEE; 
*/
SELECT CASE
WHEN A + B + C = 0 THEN 'Zero'
WHEN A + B + C < 0 THEN 'Negative'
ELSE 'Positive'
END AS A
FROM NUMBERS;"
Role Ordering,https://www.interviewbit.com/problems/role-ordering/,N/A,SQL Programming,hard,"Given a table GAMERS, pivot the table in such a manner that the Player is sorted in alphabetical order and displayed under its corresponding Role. Print NULL if no more players are associated with the corresponding role. The roles are Healer, Attacker, Defender, Tactician.

The description of the table GAMERS is given below:

Image

NOTE : The output should contain 4 columns.

Example :
","/* YOUR QUERY GOES HERE
   Example: SELECT * FROM EMPLOYEE; 
*/
SET @h=0, @a=0, @d=0, @t=0;
SELECT MIN(Healer),MIN(Attacker),MIN(Defender),MIN(Tactician)
FROM
(SELECT IF(Role='Healer',Player,NULL) AS Healer,
        IF(Role='Attacker',Player,NULL) AS Attacker,
        IF(Role='Defender',Player,NULL) AS Defender,
        IF(Role='Tactician',Player,NULL) AS Tactician,
 CASE Role
    WHEN 'Healer' THEN @h:=@h+1
    WHEN 'Attacker' THEN @a:=@a+1
    WHEN 'Defender' THEN @d:=@d+1
    WHEN 'Tactician' THEN @t:=@t+1
 END
AS idn FROM GAMERS ORDER BY Player )
AS temp GROUP BY temp.idn;"
Role Player,https://www.interviewbit.com/problems/role-player/,N/A,SQL Programming,hard,"Given a table GAMERS, query for a list sorted by alphabetical order of all the Players in the table, followed by the First letter of the Role each player plays in the game enclosed in braces (). Example: Ram(H)

The description of the table GAMERS is given below:

Image

NOTE  : The output should contain 1 column by the name ‘N’.

Example : 
","/* YOUR QUERY GOES HERE
   Example: SELECT * FROM EMPLOYEE; 
*/
SELECT CONCAT(Player,'(',SUBSTR(Role,1,1),')') AS N
FROM GAMERS
ORDER BY N;"
Role Counter,https://www.interviewbit.com/problems/role-counter/,N/A,SQL Programming,medium,"Given a table GAMERS, query for the count of each Role of the Players in the given table. Sort the result based on ascending order of the count and print the result in the following format:

[Role] Count is [Role_Count]

The description of the table GAMERS is given below:
Image

NOTE : The output should contain one table by the name ‘COUNT’ .

Example :
","/*The number of occurences of an attribute in a given column is calculated by using the COUNT() function of SQL. The output can be formatted
in the manner given in the question using the CONCAT() function. To sort the output in descending order of count, we will use the
ORDER BY clause.
Code:*/

SELECT CONCAT(Role,' Count is ',COUNT(Role)) as COUNT
FROM GAMERS
GROUP BY Role
ORDER BY COUNT(Role), Role DESC;"
Vowel Country,https://www.interviewbit.com/problems/vowel-country/,N/A,SQL Programming,medium,"Given a table PLACES, count the number of Countries which end with a vowel.

The description of the table PLACES is as given below:

Image

NOTE : The output should contain one column by the name ‘COUNT(Country)’.

Example : 
","/* YOUR QUERY GOES HERE
   Example: SELECT * FROM EMPLOYEE; 
*/
SELECT COUNT(Country) FROM PLACES WHERE (Country LIKE '%a' OR Country LIKE '%e' OR Country LIKE '%i' OR Country LIKE '%o' OR Country LIKE '%u');"
Lowest Common Multiple (LCM),https://www.interviewbit.com/problems/lowest-common-multiple-lcm/,N/A,Math,easy,"Problem Description
 
 

Find Lowest Common Multiple of given two integers.


Problem Constraints
1 <= A <= 109
1 <= B <= 109


Input Format
First argument is an integer A.
Second argument is an integer B.


Output Format
Return an integer.


Example Input
Input 1:
A = 6
B = 4
Input 2:

A = 1
B = 11


Example Output
Output 1:
12
Output 2:

11


Example Explanation
Explanation 1:
12 is the smallest integer which is divisible by 4 and 6 both.
Explanation 2:

11 is the smallest integer which is divisible by 1 and 11 both.
","long Solution::solve(int A, int B) {
    assert(1<=A && A<=1e9);
    assert(1<=B && B<=1e9);
    long long ans = A;
    ans *= B;
    ans /= __gcd(A, B);
    return ans;
}"
Character Frequencies,https://www.interviewbit.com/problems/character-frequencies/,N/A,Strings,easy,"Problem Description
 
 

Given a string A containing only lowercase characters.
Find the frequencies of the characters in order of their occurrence.


Problem Constraints
1 <= |A| <= 105


Input Format
Given a string A.


Output Format
Return an array of integer.


Example Input
Input 1:
A = ""interviewbit""
Input 2:

A = ""scaler""


Example Output
Output 1:
[3, 1, 2, 2, 1, 1, 1, 1]
Output 2:

[1, 1, 1, 1, 1, 1]


Example Explanation
Explanation 1:
Characters in their order of occurence and frequecies are {'i', 3}, {'n', 1}, {'t', 2}, {'e', 2}, {'r', 1}, {'v', 1}, {'w', 1}, {'b', 1}.
Explanation 2:

Characters in their order of occurence and frequecies are {'s', 1}, {'c', 1}, {'a', 1}, {'l', 1}, {'e', 1}, {'r', 1}.
","vector<int> Solution::solve(string A) {
    assert(1<=A.size() && A.size()<=1e5);
    string order="""";
    map<char, int> mp;
    for(char x: A){
        assert('a'<=x && x<='z');
        if(order.find(x)==string::npos){
            order.push_back(x);
        }
        mp[x]++;
    }
    vector<int> ans;
    for(char x: order){
        ans.push_back(mp[x]);
    }
    return ans;
}"
Engineers Joined,https://www.interviewbit.com/problems/engineers-joined/,N/A,SQL Programming,easy,"Given 2 tables ENGINEER and DATA, query the sum of Count of all the engineers whose Type is FrontEnd.

Note: The column ID is the same in both the tables.

The description of the tables are given below:

ENGINEER:

Image

DATA:

Image

 

NOTE : The output should contain one column by the name ‘A’

Example :
",SELECT SUM(ENGINEER.Count) as A FROM ENGINEER INNER JOIN DATA ON ENGINEER.ID = DATA.ID WHERE DATA.Type = 'FrontEnd';
Many Tables,https://www.interviewbit.com/problems/many-tables/,N/A,SQL Programming,easy,"Given 2 tables ENGINEER and DATA, query for the total count of each Type in the ENGINEER table. Print the result in alphabetical order of the Type.

Note: The ID columns in both tables are identical.

The description of the 2 tables are given below:

ENGINEER:

Image

DATA:

‘ID’ in DATA table is identical to ‘ID’ in ENGINEER table

DATA

NOTE : The output should contain 1 columns by the name ‘A’. The output should be Sorted by Type .

Example :
","/* YOUR QUERY GOES HERE
   Example: SELECT * FROM EMPLOYEE; 
*/
SELECT SUM(ENGINEER.Count) AS A FROM ENGINEER INNER JOIN DATA ON ENGINEER.ID = DATA.ID GROUP BY DATA.Type ORDER BY DATA.Type;"
Which Season?,https://www.interviewbit.com/problems/which-season/,N/A,Math,easy,"Problem Description
 
 

Given an integer A which represents a month.
Find the season according to the month.
Spring – March to May
Summer – June to August
Autumn – September to November
Winter – December to February
If the month is out of the range 1 to 12 output should be “Invalid”.


Problem Constraints
1 <= A <= 100


Input Format
Given an integer A.


Output Format
Return a string.


Example Input
Input 1:
A = 6
Input 2:

A = 13


Example Output
Output 1:
""Summer""
Output 2:

""Invalid""


Example Explanation
Explanation 1:
6th month is june, in june there is ""Summer"".
Explanation 2:

13th month doesn't exist so ""Invalid"".
","string Solution::solve(int A) {
    assert(1<=A && A<=100);
    if(A > 12){
        return ""Invalid"";
    }
    if(3<=A && A<=5){
        return ""Spring"";
    }
    if(6<=A && A<=8){
        return ""Summer"";
    }
    if(9<=A && A<=11){
        return ""Autumn"";
    }
    return ""Winter"";
}"
String Inversion,https://www.interviewbit.com/problems/string-inversion/,N/A,Strings,easy,"Problem Description
 
 

Given a string A. Change the cases of all the characters.
If the character is lowercase convert it to uppercase and if the character is uppercase convert it to lowercase.

Note: All the characters in the string are latin uppercase or lowercase letters.


Problem Constraints
1 <= |A| <= 105


Input Format
Given a string A.


Output Format
Return a string.


Example Input
Input 1:
A = 6 = ""InterviewBit""
Input 2:

A = ""Scaler""


Example Output
Output 1:
""iNTERVIEWbIT""
Output 2:

""sCALER""
","char change(char x){
    if('a'<=x && x<='z'){
        return 'A'+x-'a';
    }
    return 'a'+x-'A';
}
string Solution::solve(string A) {
    assert(1<=A.size() && A.size()<=1e5);
    for(char &x: A){
        assert(('a'<=x && x<='z')||('A'<=x && x<='Z'));
        x = change(x);
    }
    return A;
}"
Top Performer,https://www.interviewbit.com/problems/top-performer/,N/A,SQL Programming,hard,"Given 2 tables EMPLOYEE and EVALUATION, build a report containing the 2 columns, Name and Rating. Employees with Ratings less than 6 should appear as NULL in the table. The entries in the table should be sorted by descending order of Rating, followed by Names in lexicographic order.

The description of the tables are given below:

EMPLOYEE:

Image

EVALUATION:

Image

NOTE : The output should contain 2 columns by the name ‘Names’ and ‘Rating’.

Example :
","/* YOUR QUERY GOES HERE
   Example: SELECT * FROM EMPLOYEE; 
*/
SELECT CASE
    WHEN EVALUATION.Rating >= 6 THEN EMPLOYEE.Name
    ELSE NULL
    END AS Names, EVALUATION.Rating
FROM EMPLOYEE INNER JOIN EVALUATION ON EMPLOYEE.Points BETWEEN EVALUATION.Lower AND EVALUATION.Upper
ORDER BY EVALUATION.Rating DESC, Names ASC;"
Low and High Grades,https://www.interviewbit.com/problems/low-and-high-grades/,N/A,SQL Programming,medium,"Given 2 tables EMPLOYEE and EVALUATION, query for the count of names whose Rating is less than 3. Also, query for the count of names whose Rating is greater than 8.

The description of the tables are given below:

EMPLOYEE:

Image

EVALUATION:

Image

NOTE : The output should first give the count of names whose rating is less than 3 and than the count of names whose rating is greater than 8.

Example : 

Count(Name)

5

Count(Name)

10

 ","/* YOUR QUERY GOES HERE
   Example: SELECT * FROM EMPLOYEE; 
*/
SELECT COUNT(Name) FROM EMPLOYEE INNER JOIN EVALUATION ON EMPLOYEE.Points BETWEEN EVALUATION.Lower AND EVALUATION.Upper WHERE EVALUATION.Rating < 3;
SELECT COUNT(Name) FROM EMPLOYEE INNER JOIN EVALUATION ON EMPLOYEE.Points BETWEEN EVALUATION.Lower AND EVALUATION.Upper WHERE EVALUATION.Rating > 8;"
Socks Pair,https://www.interviewbit.com/problems/socks-pair/,N/A,Math,easy,"Problem Description
 
 

Given an integer array A of integers.
Every element in the array repersent a colour of a sock, find how many pair of socks with matching colours there are.


Problem Constraints
1 <= |A| <= 105
1 <= Ai <= |A|


Input Format
Given an integer array A.


Output Format
Return an integer.


Example Input
Input 1:
A = [1, 2, 3]
Input 2:

A = [2, 2, 2, 2]


Example Output
Output 1:
0
Output 2:

2


Example Explanation
Explanation 1:
No pair of socks can be formed.
Explanation 2:

Two pairs of socks can be formed.
","int Solution::solve(vector<int> &A) {
    int n = A.size();
    assert(1<=n && n<=1e5);
    int cnt[n+1] = {0};
    for(int x: A){
        assert(1<=x && x<=n);
        cnt[x]++;
    }
    int ans = 0;
    for(int i = 1; i <= n; ++i){
        ans += cnt[i]/2;
    }
    return ans;
}"
Pythagorean Triplets,https://www.interviewbit.com/problems/pythagorean-triplets/,N/A,Arrays,easy,"Problem Description
 
 

A Pythagorean triplet is a set of three integers a, b and c such that a2 + b2 = c2.
Find the number of pythagorean triplets such that all the elements of the triplet are less than or equal to A.


Problem Constraints
1 <= A <= 103


Input Format
Given an integer A.


Output Format
Return an integer.


Example Input
Input 1:
A = 5
Input 2:

A = 13


Example Output
Output 1:
1
Output 2:

3


Example Explanation
Explanation 1:
Then only triplet is {3, 4, 5}
Explanation 2:

The triplets are {3, 4, 5}, {6, 8, 10}, {5, 12, 13}.","int Solution::solve(int A) {
    assert(1<=A && A<=1e3);
    map<int, bool> pre;
    for(int i = 1; i <= A; ++i){
        pre[i*i] = 1;
    }
    int ans = 0;
    for(int i = 1; i <= A; ++i){
        for(int j = i; j <= A; ++j){
            if(pre.find(i*i+j*j)!=pre.end()){
                ans++;
            }
        }
    }
    return ans;
}"
Study Selection,https://www.interviewbit.com/problems/study-selection/,N/A,SQL Programming,medium,"Given a table STUDY, query for all the attributes, which have marks greater than 80.

The description of the table STUDY is given below:

Image

NOTE : The output should contain 4 columns  ‘ID’ , ‘Name’ ,’Age’ and ‘Marks’ .

Example : 
","/* YOUR QUERY GOES HERE
   Example: SELECT * FROM EMPLOYEE; 
*/
SELECT * FROM STUDY WHERE ID IN (SELECT ID FROM STUDY WHERE Marks > 80);"
Study Update,https://www.interviewbit.com/problems/study-update/,N/A,SQL Programming,medium,"Given a table STUDY, update the marks of all the students to 50, whose marks lie in the range 25 - 50 (excluding 25 , including 50 i.e. (25,50] ) . Then print the new table.

The description of the table STUDY is given below:

Image

Note: Create a copy of the original table.

Example :
","/*
Create a copy of the original table. We can update all the Marks to 50, by selecting marks where marks > 25 and marks < 50 and using a new query to print the modified table.
*/

CREATE TABLE STUDYCOPY AS SELECT * FROM STUDY;
UPDATE STUDY SET Marks = 50 WHERE Marks IN (SELECT Marks FROM STUDYCOPY WHERE Marks > 25 and Marks <= 50);
SELECT * FROM STUDY;"
Study Deletion,https://www.interviewbit.com/problems/study-deletion/,N/A,SQL Programming,medium,"Given a table STUDY, delete all the entries in the table where the AGE of the students lies between 19-22. Then print the new table.

The description of the table STUDY is given below:

Image

NOTE : The output should contain 4 columns ‘ID’ , ‘Name’ , ‘Age’ and ‘Marks’ .

Example :
","/* YOUR QUERY GOES HERE
   Example: SELECT * FROM EMPLOYEE; 
*/
CREATE TABLE STUDYCOPY AS SELECT * FROM STUDY;
DELETE FROM STUDY WHERE Age IN (SELECT Age FROM STUDYCOPY WHERE Age >= 19 and Age <= 22);
SELECT * FROM STUDY;"
Same Countries,https://www.interviewbit.com/problems/same-countries/,N/A,SQL Programming,medium,"Given a table LABOURERS, match all the pairs of Labourers that are from the same country, along with the country name. Keep the ordering by Name of the first laborer, then second laborer, and then Country name. The output format should be like this:

Image

Where Labourer1 and Labourer2 come from the same country.

The description of the table LABOURERS is given below:

Image","/* YOUR QUERY GOES HERE
   Example: SELECT * FROM EMPLOYEE; 
*/
SELECT A.Name AS Labourer1, B.Name AS Labourer2, A.Country
FROM LABOURERS A, LABOURERS B
WHERE A.ID <> B.ID
AND A.Country = B.Country
ORDER BY A.Name, B.Name, A.Country;"
Two Stores,https://www.interviewbit.com/problems/two-stores/,N/A,Math,easy,"Problem Description
 
 

You want to buy A candies, there are two candy stores in your town.
The stores sell candies in packets, first store sells B candies for C rupees and the other store sells D candies for E rupees.
Find the minimum cost to buy exactly A candies if you can buy any amount of packets from both stores.
If it is not possible to do so return -1.


Problem Constraints
1 <= A <= 105
1 <= B, C, D, E <= 104


Input Format
Given five input arguments A, B, C, D, E all of them are integers.


Output Format
Return an integer.


Example Input
Input 1:
A = 5
B = 3
C = 3
D = 3
E = 2
Input 2:

A = 7
B = 1
C = 1
D = 3
E = 2


Example Output
Output 1:
-1
Output 2:

5


Example Explanation
Explanation 1:
There no way to buy exactly 5 candies from stores.
Explanation 2:

We buy two packets from second store and 1 packet from first store.
11 + 23 = 7
11 + 22 = 5
","int Solution::solve(int A, int B, int C, int D, int E) {
    assert(1<=A && A<=1e5);
    assert(1<=B && B<=1e4);
    assert(1<=C && C<=1e4);
    assert(1<=D && D<=1e4);
    assert(1<=E && E<=1e4);
    int ans=2e9;
    for(int i = 0; i*B <= A; ++i){
        int rem = A - i*B;
        if(rem%D)continue;
        int val=i*C + rem/D*E;
        ans=min(ans, val);
    }
    if(ans == 2e9){
        ans=-1;
    }
    return ans;
}"
Palindromic Time,https://www.interviewbit.com/problems/palindromic-time/,N/A,Time Complexity,easy,"Problem Description
 
 

Given a string A which represents a time in 24 hour HH:MM format.
Find the minimum number of minutes need to pass to reach palindromic time.
Let some time be XY:ZW then it is palindromic if X == W and Y == Z.


Problem Constraints
String A represents a valid time in HH:MM format.


Input Format
Given a string A.


Output Format
Return an integer.


Example Input
Input 1:
A = ""23:59""
Input 2:

A = ""21:00""


Example Output
Output 1:
1
Output 2:

12


Example Explanation
Explanation 1:
After 1 minute time will be 00:00 which is a palindromic time.
Explanation 2:

After 12 minute time will be 21:12 which is a palindromic time.
","int Solution::solve(string A) {
    int hh = (A[0]-'0')*10 + (A[1]-'0');
    int mm = (A[3]-'0')*10 + (A[4]-'0');
    assert(0<=hh && hh<24);
    assert(0<=mm && mm<60);
    assert(A[2]==':');
    int ans = 0;
    while(hh/10 != mm%10 || hh%10 != mm/10){
        mm++;
        ans++;
        if(mm == 60){
            mm = 0;
            hh++;
        }
        if(hh == 24){
            hh = 0;
        }
    }
    return ans;
}"
Dice Rolls,https://www.interviewbit.com/problems/dice-rolls/,N/A,Dynamic Programming,medium,"Problem Description
 
 

You rolled a dice K times and got a sum of A after summing all the values you got after a roll.
Find the number of ways you could have got a sum of A after rolling K times, since this value can be very large return modulo 109+7.


Problem Constraints
1 <= A <= 106


Input Format
Given an integer A.


Output Format
Return and integer.


Example Input
Input 1:
A = 2
Input 2:

A = 3


Example Output
Output 1:
2
Output 2:

4


Example Explanation
Explanation 1:
Ways to get sum 2 are {1, 1} {2}.
Explanation 2:

Ways to get sum 3 are {1, 1, 1}, {1, 2}, {2, 1}, {3}
","int Solution::solve(int A) {
    assert(1<=A && A<=1e6);
    int mod = 1e9+7;
    int dp[A+1] = {1};
    for(int i = 1; i <= A; ++i){
        for(int j = 1; j <= min(i, 6); ++j){
            dp[i] += dp[i-j];
            dp[i] %= mod;
        }
    }
    return dp[A];
}"
Swap Bits,https://www.interviewbit.com/problems/swap-bits/,N/A,Bit Manipulation,easy,"Problem Description
 
 

Given an integer A.
Swap the Bth and Cth bit from right in binary representation of A.
Return the integer formed.


Problem Constraints
1 <= A < 230
1 <= B, C <= 30


Input Format
First argument is an integer A.
Second argument is an integer B.
Third argument is an integer C.


Output Format
Return an integer.


Example Input
Input 1:
A = 9
B = 1
C = 2
Input 2:

A = 1
B = 1
C = 3


Example Output
Output 1:
10
Output 2:

4


Example Explanation
Explanation 1:
5 -> 101
Swapping 1st and 2nd bit from right gives 110.
Explanation 2:

1 -> 001
Swapping 1st and 3rd bit from right gives 100.
","int Solution::solve(int A, int B, int C) {
    B--;
    C--;
    int f1 = (A >> B) & 1;
    int f2 = (A >> C) & 1;
    A += (f1 << C) + (f2 << B) - (f1 << B) - (f2 << C);
    return A;
}"
Pangram Check,https://www.interviewbit.com/problems/pangram-check/,N/A,Time Complexity,easy,"Problem Description
 
 

Given a sentence represented as an array A of strings that contains all lowercase alphabets.
Chech if it is a pangram or not.
A pangram is a unique sentence in which every letter of the lowercase alphabet is used at least once.


Problem Constraints
1 <= |A| <= 105
1 <= |Ai|<= 5


Input Format
Given an array of strings A.


Output Format
Return an integer.


Example Input
Input 1:
A = [""the"", ""quick"", ""brown"", ""fox"", ""jumps"", ""over"", ""the"", ""lazy"", ""dog""]
Input 2:

A = [""bit"", ""scale""]




Example Output
Output 1:
1
Output 2:

0


Example Explanation
Explanation 1:
We can check that all english alphabets are present in given sentence.
Explanation 2:

Not all english alphabets are present.
","int Solution::solve(vector < string > & A) {
    assert(1 <= A.size() && A.size() <= 1e5);
    bool vis[26] = {0};
    for (string x: A) {
        assert(1 <= x.size() && x.size() <= 5);
        for (char y: x) {
            assert('a' <= y && y <= 'z');
            vis[y - 'a'] = 1;
        }
    }
    for (int i = 0; i < 26; ++i) {
        if (!vis[i]) {
            return 0;
        }
    }
    return 1;
}"
Connected Components,https://www.interviewbit.com/problems/connected-components/,N/A,Graph Data Structure & Algorithms,easy,"Problem Description
 
 

Given a graph with A nodes.
The edges in graph are given in a 2D array B.
There is an undirected edge between B[i][0] and B[i][1].
Find the number of connected components in the given graph.


Problem Constraints
1 <= A <= 105
1 <= |B| <= 105
1 <= B[i][0], B[i][1] <= A


Input Format
First argument is an integer A.
Second argument is a 2D integer array B.


Output Format
Return an integer.


Example Input
Input 1:
A = 4
B = [[1, 2],
     [2, 3]]
Input 2:

A = 3
B = [1, 2]
    [2, 1]


Example Output
Output 1:
2
Output 2:

2


Example Explanation
Explanation 1:
 The two connected components are [1, 2, 3] and [4].
Explanation 2:

The two connected components are [1, 2] and [3].
","void dfs(int cur, vector<vector<int>> &edges, bool vis[]){
    vis[cur] = 1;
    for(int x: edges[cur]){
        if(!vis[x]){
            dfs(x, edges, vis);
        }
    }
    return;
}
int Solution::solve(int A, vector<vector<int> > &B) {
    vector<vector<int>> edges(A);
    assert(1<=A && A<=1e5);
    assert(1<=B.size() && B.size()<=1e5);
    for(auto te :B){
        int x = te[0];
        int y = te[1];
        assert(1<=x && x<=A);
        assert(1<=y && y<=A);
        edges[x-1].push_back(y-1);
        edges[y-1].push_back(x-1);
    }
    bool vis[A] = {0};
    int ans = 0;
    for(int i = 0; i < A; ++i){
        if(!vis[i]){
            dfs(i, edges, vis);
            ans++;
        }
    }
    return ans;
}"
Diagonal Flip,https://www.interviewbit.com/problems/diagonal-flip/,N/A,Arrays,easy,"Problem Description
 
 

Given a square binary matrix of drimensions N×N.
Flip the matrix diagonally and return the matrix.


Problem Constraints
1 <= N <= 1000
A[i][j] ={0, 1}


Input Format
Given a 2D integer array.


Output Format
Return a 2D integer array.


Example Input
Input 1:
A = 4
B = [[1, 0],
     [0, 1]]
Input 2:

A = [[1, 0],
     [1, 0]]


Example Output
Output 1:
[[1, 0],
 [0, 1]]
Output 2:

[[1, 1],
 [0, 0]]
 


Example Explanation
Explanation 1:
We will swap the values at positions (1, 2) and (2, 1).
Explanation 2:

We will swap the values at positions (1, 2) and (2, 1).
","vector<vector<int> > Solution::solve(vector<vector<int> > &A) {
    assert(1<=A.size() && A.size()<=1000);
    for(int i = 0; i < A.size(); ++i){
        assert(1<=A[i].size() && A[i].size()<=1000 && A.size()==A[i].size());
        for(int j = 0; j <= i; ++j){
            assert(A[i][j]==0 || A[i][j]==1);
            assert(A[j][i]==0 || A[j][i]==1);
            swap(A[i][j], A[j][i]);
        }
    }
    return A;
}"
Valid Password,https://www.interviewbit.com/problems/valid-password/,N/A,Strings,easy,"Problem Description
 
 

Given a password as a character array A.
Check if it is valid or not.
Password should have at least one numerical digit(0-9).
Password's length should be in between 8 to 15 characters.
Password should have at least one lowercase letter(a-z).
Password should have at least one uppercase letter(A-Z).
Password should have at least one special character ( @, #, %, &, !, $, *).


Problem Constraints
1 <= |A| <= 20


Input Format
Given a character array A.


Output Format
Return an integer.


Example Input
Input 1:
A = ['S', 'c', 'a', 'l', 'e', 'r', '@', '1']
Input 2:

A = ['I', 'n', 't', 'e', 'r', 'v', 'i', 'e', 'w', 'B', 'i', 't']


Example Output
Output 1:
1
Output 2:

0


Example Explanation
Explanation 1:
All the characteristic required for password are present in given password.
Explanation 2:

The password given does not have any special character and also it does not have any numerical digit.","int Solution::solve(string A) {
    assert(1<=A.size() && A.size()<=20);
    bool digit = false;
    bool upper = false;
    bool lower = false;
    bool special = false;
    for(char &x: A){
        if('a'<=x && x<='z'){
            lower = true;
        }
        if('A'<=x && x<='Z'){
            upper = true;
        }
        if('0'<=x && x<='9'){
            digit = true;
        }
        if(x=='@' || x=='#' || x=='%' || x=='&' || x=='!' || x=='$' || x=='*'){
            special = true;
        }
    }
    if(8<=A.size() && A.size()<=15){
        if(digit && upper && lower && special){
            return 1;
        }
        return 0;
    }
    return 0;
}"
Positive Negative,https://www.interviewbit.com/problems/positive-negative/,N/A,Arrays,easy,"Problem Description
 
 

Given an integer array A.
Find the number of positive and negative integers in it an return them in an array.


Problem Constraints
1 <= |A| <= 105
-109 <= Ai <= 109


Input Format
Given an integer array A.


Output Format
Return an integer array of length two, first value should be count of positive integers and other count of negative integers.


Example Input
Input 1:
A = [1, 2, 3]
Input 2:

A = [1, 0, -1]


Example Output
Output 1:
[3, 0]
Output 2:

[1, 1]


Example Explanation
Explanation 1:
Positive values are [1, 2, 3].
There are no negative values.
Explanation 2:

Only positive value is [1].
Only negative value is [-1].
","vector<int> Solution::solve(vector<int> &A) {
    assert(1<=A.size() && A.size()<=1e5);
    int pos = 0;
    int neg = 0;
    for(int x: A){
        assert(-1e9<=x && x<=1e9);
        if(x > 0){
            pos++;
        }
        if(x < 0){
            neg++;
        }
    }
    return {pos, neg};
}"
Climbing Stairs,https://www.interviewbit.com/problems/climbing-stairs/,N/A,Time Complexity,medium,"Problem Description
 
 

Given an integer array A of length N. Where Ai is the cost of stepping on the ith stair.
From ith stair, you can go to i+1th or i+2th numbered stair.
Initially, you are at 1st stair find the minimum cost to reach Nth stair.


Problem Constraints
2 <= N <= 105
1 <= Ai <= 104


Input Format
The first and only argument is an integer array A.


Output Format
Return an integer.


Example Input
Input 1:
A = [1, 2, 1, 3]
Input 2:

A = [1, 2, 3, 4]


Example Output
Output 1:
5
Output 2:

7


Example Explanation
Explanation 1:
1 -> 3 -> 4
Explanation 2:

1 -> 2 -> 4
","int Solution::solve(vector<int> &A) {
    int n = A.size();
    assert(1 <= n && n <= 1e5);
    for(int &x: A) assert(1 <= x && x <= 1e4);
    A[1] += A[0];
    for(int i = 2; i < n; ++i){
        A[i] += min(A[i-1], A[i-2]);
    }
    return A.back();
}"
Integers in Strings,https://www.interviewbit.com/problems/integers-in-strings/,N/A,Time Complexity,medium,"Problem Description
 
 

Given a string A, consisting of comma-separated positive integers.
Extract the given integers from the string and return an integer array consisting of the integers present in the string.

Note: All given integers will fit in a 32-bit signed integer.


Problem Constraints
1 <= |A| <= 105


Input Format
The first and only argument is a string A.


Output Format
Return an integer array.
The array should contain all the integers in the same order as they appear in the string.


Example Input
Input 1:
A = ""1,2,3""
Input 2:

A = ""1,99,3""


Example Output
Output 1:
[1, 2, 3]
Output 2:

[1, 99, 3]


Example Explanation
Explanation 1:
The array is given in Example output.
Explanation 2:

The array is given in Example output.
","vector<int> Solution::solve(string A) {
    int n = A.size();
    assert(1 <= n && n <= 1e5);
    for(char &x: A) assert(x == ',' || isdigit(x));
    vector<int> ans;
    int num = 0;
    for(char &x: A){
        if(x == ','){
            ans.push_back(num);
            num = 0;
        }
        else{
            num = num*10 + x-'0';
        }
    }
    ans.push_back(num);
    return ans;
}"
Word Count,https://www.interviewbit.com/problems/word-count/,N/A,Time Complexity,medium,"Problem Description
 
 

Given a string A. The string contains some words separated by spaces.
Return the number of words in the given string.


Problem Constraints
1 <= |A| <= 105
Ai = { lowercase English letters or spaces}


Input Format
The first and only argument is a string A.


Output Format
Return an integer.


Example Input
Input 1:
A = ""bonjour""
Input 2:

A = ""hasta la vista""


Example Output
Output 1:
1
Output 2:

3


Example Explanation
Explanation 1:
The string has only one word ""bonjour"".
Explanation 2:

The string have three words ""hasta"", ""la"", ""vista"".
","int Solution::solve(string A) {
    int n = A.size();
    assert(1 <= n && n <= 1e5);
    for(char &x: A) assert(x == ' ' || ('a' <= x && x <= 'z'));
    int ans = 0;
    for(int i = 0; i < n; ++i){
        if(A[i] == ' ') continue;
        while(i < n && A[i] != ' ') ++i;
        ++ans;
    }
    return ans;
}"
Extracting Numbers,https://www.interviewbit.com/problems/extracting-numbers/,N/A,Time Complexity,easy,"Problem Description
 
 

Given a string A. The string contains alphanumeric characters.
Find the sum of all numbers present in it.

Note: All the numbers will fit in a 32-bit signed integer.


Problem Constraints
1 <= |A| <= 105


Input Format
The first and only argument is a string A.


Output Format
Return an integer.


Example Input
Input 1:
A = ""a12b34c""
Input 2:

A = ""123""


Example Output
Output 1:

46
Output 2:

123


Example Explanation
Explanation 1:
The numbers are 12, 34.
12 + 34 = 46
Explanation 2:

The only number is 123.
","long Solution::solve(string A) {
    int n = A.size();
    assert(1 <= n && n <= 1e5);
    for(char &x: A) assert(isalnum(x));
    long long ans = 0;
    for(int i = 0; i < n; ++i){
        if(!isdigit(A[i])) continue;
        string num = """";
        while(i < n && isdigit(A[i])) num += A[i++];
        ans += stoi(num);
    }
    return ans;
}"
Palindromic Words,https://www.interviewbit.com/problems/palindromic-words/,N/A,Strings,easy,"Problem Description
 
 

Given a sentence as a string A.
Return the number of palindromic words in the sentence.


Problem Constraints
1 <= A <= 105
Ai = {Lowercase English letters and whitespaces}


Input Format
The first and only argument is a string A.


Output Format
Return an integer.


Example Input
Input 1:
A = ""the fastest racecar""
Input 2:

A = ""wow mom""


Example Output
Output 1:
1
Output 2:

2


Example Explanation
Explanation 1:
The word ""racecar"" is only a palindromic word in the sentence ""the fastest racecar"".
Explanation 2:

The words ""wow"" and ""mom"" both are palindromic word in the sentence ""wow mom"".
","int check(string s){
    int l = 0, r = s.size() - 1;
    while(l < r){
        if(s[l] != s[r]) return 0;
        ++l, --r;
    }
    return 1;
}
int Solution::solve(string A) {
    int n = A.size();
    assert(1 <= n && n <= 1e5);
    for(char &x: A) assert(x == ' ' || ('a' <= x && x <= 'z'));
    int ans = 0;
    for(int i = 0; i < n; ++i){
        if(A[i] == ' ') continue;
        string temp = """";
        while(i < n && A[i] != ' ') temp += A[i++];
        ans += check(temp);
    }
    return ans;
}"
Palindrome Numbers,https://www.interviewbit.com/problems/palindrome-numbers/,N/A,Two Pointers,medium,"Problem Description
 
 

Given two integers A and B which represent an integer range [A, B].
Find the maximum number of distinct palindromic integers we can take from the given range,
such that the absolute difference between any two integers doesn't exceed C.


Problem Constraints
1 <= A <= B <= 105
1 <= C <= 105


Input Format
The first argument is an integer A.
The second argument is an integer B.
The third argument is an integer C.


Output Format
Return an integer.


Example Input
Input 1:
A = 80
B = 110
C = 10
Input 2:

A = 1
B = 10
C = 10


Example Output
Output 1:
2
Output 2:

9


Example Explanation
Explanation 1:
The plaindromic integers are 88, 99, 101.
We will pick 99, 101.
Explanation 2:

The plaindromic integers are 1, 2, 3, 4, 5, 6, 7, 8, 9.
We can pick all the palindrome integers.
","bool ispal(int x){
    int org = x;
    int rev = 0;
    while(x > 0){
        rev = rev*10 + x%10;
        x /= 10;
    }
    return (org == rev);
}
int Solution::solve(int A, int B, int C) {
    assert(1 <= A && A <= B && B <= 1e5);
    assert(1 <= C && C <= 1e5);
    vector<int> pal;
    for(int i = A; i <= B; ++i){
        if(ispal(i)) pal.push_back(i);
    }
    int n = pal.size();
    int j = 0;
    int ans = 0;
    for(int i = 0; i < n; ++i){
        while(j < n && pal[j] - pal[i] <= C ) ++j;
        ans = max(ans, j-i);
    }
    return ans;
}"
Palindromic Substrings,https://www.interviewbit.com/problems/palindromic-substrings/,N/A,Dynamic Programming,medium,"Problem Description
 
 

Given a string A consisting of only lowercase English letters.
Return the number of substrings of A which are palindrome.


Problem Constraints
1 <= A <= 103


Input Format
The first and only argument is a string A.


Output Format
Return an integer.


Example Input
Input 1:
A = ""aba""
Input 2:

A = ""abcd""


Example Output
Output 1:
4
Output 2:

4


Example Explanation
Explanation 1:
The plaindrome substrings are ""a"", ""b"", ""a"" and ""aba"".
Explanation 2:

The plaindrome substrings are ""a"", ""b"", ""c"" and ""d"".
","int Solution::solve(string A) {
    int n = A.size();
    assert(1 <= n && n <= 1e3);
    for(char &x: A) assert('a' <= x && x <= 'z');
    bool dp[n][n];
    memset(dp, 0, sizeof(dp));
    int ans = 0;
    for(int i = n-1; i >= 0; --i){
        for(int j = i; j < n; ++j){
            if(i == j) dp[i][j] = 1;
            else if(i+1 == j) dp[i][j] = (A[i] == A[j]);
            else dp[i][j] = dp[i+1][j-1] & (A[i] == A[j]);
            if(dp[i][j]) ++ans;
        }
    }
    return ans;
}"
5'th Highest Marks,https://www.interviewbit.com/problems/5-th-highest-marks/,N/A,SQL Programming,medium,"Given the ‘STUDENTS’ table. Write an SQL query to find the 5’th highest marks in the students table.

K'th Highest Marks

NOTE : The output should contain one column by the name ‘MARKS’ .

Example :
","SELECT MARKS
FROM STUDENTS
ORDER BY MARKS DESC
LIMIT 1 OFFSET 4
;"
Performance Improvement,https://www.interviewbit.com/problems/performance-improvement/,N/A,SQL Programming,medium,"Raw Problem

You are given a table having the marks of one student in every test (Tests are held every day). You have to output the tests in which the student has improved his performance. For a student to improve his performance he has to score more than the previous test. Given that TestIDs are in increasing order, forming a continuous sequence without any missing numbers.

 

Table: Tests

Performance Improvement

NOTE: The output should contain one column by the name ‘TestId’.

Example :



Sample Input:



Sample Output:

 ","SELECT Tests.TestId 
FROM   Tests 
       JOIN Tests AS t 
         ON t.TestId = Tests.TestId-1
WHERE  Tests.Marks > t.Marks"
Famous Books,https://www.interviewbit.com/problems/famous-books/,N/A,SQL Programming,hard,"You are given 2 tables, One containing the available Books and the other containing the Books that have been bought by a customer. You have to find the Id’s of all the ‘Famous’ Books. A book is called ‘Famous’ if it is bought by at least 3 customers.

 

Table 1: Books (Id - primary key )

Books

Table 2: BoughtBooks (Id-primary key, BooksId-foreign key to Books)

BoughtBooks

NOTE : The output should contain one column by the name ‘Id’ .

Example :
","SELECT Books.Id 
FROM Books
WHERE Books.id IN 
(
    SELECT BooksId FROM BoughtBooks
    GROUP BY BooksId 
    HAVING COUNT(*) > 2
);"
Chess Tournament,https://www.interviewbit.com/problems/chess-tournament/,N/A,SQL Programming,hard,"A chess tournament is being held which consists of several matches between a player and a computer. After every match one player is declared as the winner.

You are given two tables, One table consists of the players that will be playing the tournament while the other table consists of the matches that will be played in the tournament and its Result. The Result would be 1 if the player won the match, 0 otherwise. You have to output the names of the players who have won atleast one match and lost atmost one match.

Table:Players



Table:Matches



 NOTE : The output should contain only one column by the name ‘Name’ .

Example :
",select Name from Players where Id in(select Id from Matches  group by Id having SUM(Result)>0 and count(*)-SUM(Result)<=1);
NULL sorting,https://www.interviewbit.com/problems/null-sorting/,N/A,SQL Programming,hard,"You are given a table ‘Students’ which consists of the student information of every student along with the marks that they obtained in a test out of 100. However there were students who were Absent for the test, their marks section would contain ‘Absent’ word. Help the teacher arrange the students first based on their marks and second based on their first name.(You just have to output the names of the students).



NOTE : The output should contain only one column by the name ‘Name’ .

Example :
","select Name
from (
select Id,Name,Marks,
case when Marks='Absent' then 0 else 1 end as is_absent
from Students
) x
order by is_absent desc,Marks desc,Name"
I hate Vowels,https://www.interviewbit.com/problems/i-hate-vowels/,N/A,SQL Programming,hard,"You are given a ‘Students’ table consisting of Id,Name and marks of two tests namely Marks1 and Marks2. The teacher wants to sort the table based on their marks(in descending order). However the teacher has a particular hate towards students whose Names starts with a vowel. Therefore the teacher would take the maximum of the two tests for students whose name doesn’t start with a vowel while sorting, and would take the minimum of the two tests for the students whose name starts with a vowel while sorting.



NOTE : The output should contain one column by the name ‘Name’.

Example : 
","select Name
from Students
order by 
case
    when (Name LIKE 'a%' OR Name LIKE 'e%' OR Name LIKE 'i%' OR Name LIKE 'o%' OR Name LIKE 'u%') 
    then case 
        when(Marks1<=Marks2) then Marks1 else Marks2 end 
    else case when(Marks1>=Marks2) then Marks1 else Marks2 end 
end 
desc;"
Birthdays,https://www.interviewbit.com/problems/birthdays/,N/A,SQL Programming,hard,"You are given one table ‘Students’ which consists of Id,Name and Birthdate of students. Write an SQL query to find for each date the number of students having their birthday on that day and their names (seperated by commas). Also the Dates should be ordered in ascending order.



NOTE : The output should contain only one column by the name ‘Name’ .

Example :
","SELECT 
    GROUP_CONCAT(DISTINCT Name SEPARATOR ',') AS Names
        FROM Students
            GROUP BY BirthDate
                ORDER BY BirthDate "
Class Average,https://www.interviewbit.com/problems/class-average/,N/A,SQL Programming,hard,"You are given a table ‘Students’ which consists of the marks that students from different classes obtained in the final exam. Write an SQL query to find for each departments the number of students who managed to score above total average (average considering students of all classes) . The output should be sorted by ClassId .



NOTE : The output should contain one column by the name ‘A’ . 

Example :
",select COUNT(*) as A from (select * from Students where Marks>=(select AVG(Marks) from Students)) a  group by ClassId order by ClassId
Tournament 2.0,https://www.interviewbit.com/problems/tournament-2-0/,N/A,SQL Programming,hard,"A tournament is being held where several matches takes place between a player from team 1 and a player from team 2. After every match one of the players is declared as the winner. However there are some players in Team2 who are known cheaters. Write an SQL Query to find the percentage of matches Won by Team1 against a non cheater from team 2 on every day. percentage of wins=(total games won against non cheaters)/(total games played against non cheaters). The percentage of wins should be rounded upto 4 decimals.

Also the name of the output coloumn should be ‘Percentage Wins’. Also the output should be order ascending order of the Dates.

Table:Team1

Id is primary key.



Table: Team2 (Cheater will be 1 if that player from Team2 is a cheater, 0 otherwise).

Id is primary key.



Table:Matches (Result would be 1 if PlayerId1 wins the match, 0 if PlayerId2 wins the match).

Also PlayerId1 is foreign key to Team1 and PlayerId2 is foreign key to Team2.



NOTE : The name of the output column should be ‘Percentage Wins’ .

Example : 
","select
round(sum(Result)/count(*),4) as 'Percentage Wins'
from Matches
where PlayerId2 not in (select Id from Team2 where Cheater=1)
group by Date
order by Date;"
Job Offer,https://www.interviewbit.com/problems/job-offer/,N/A,SQL Programming,hard,"You are given 3 tables namely ‘Students’ , ‘Departments’ and ‘Jobs’.

Write an SQL query to find for each student their name and the date of the job offer. The output should be sorted by Department Names. Note that there might be students who did not receive a single offer, in such cases you should not include them in the output table.

Table: Students

Id:primary key



Table:Departments

DepartmentId of this table and DepartmentId of Students table are identical



Table: Jobs

Id of this table and Id of Students table are identical.



 

NOTE : The output should contain one column by the name ‘Offers’ which should contain StudentName and The Date of the offer seperated by a ’ , ‘ .

Example :
","select CONCAT(s.Name, ',' ,j.Date) as Offers
from Students s join Departments d
on (s.DepartmentId=d.DepartmentId)
left join Jobs j
on (s.Id=j.Id)
where j.Date is not NULL
order by d.DepartmentName
;"
Job Offers 2.0,https://www.interviewbit.com/problems/job-offers-2-0/,N/A,SQL Programming,hard,"You are given 3 tables namely ‘Students’ , ‘Departments’ and ‘Jobs’.

Write an SQL query to find sum of Distinct salaries obtained by students from ‘CSE’ department. The output should be sorted by the Department names.

Note: There might be students who have got multiple job offers.

 

Table: Students

Id:primary key



 

Table:Departments

DepartmentId of this table and DepartmentId of Students table are identical



Table: Jobs

Id of this table and Id of Students table are identical.



NOTE : The output should contain one column by the name ‘Salary’ .

Example :
","select
sum(distinct Salary) as Salary
from (
select s.Id,
s.Name,
s.DepartmentId,
j.Salary
from Students s, Jobs j
where s.Id = j.Id
and (select DepartmentName from Departments where Departments.DepartmentId=s.DepartmentId)='CSE'
) x
group by DepartmentId"
Next And Previous,https://www.interviewbit.com/problems/next-and-previous/,N/A,SQL Programming,hard,"Given a table Students. Write an SQL qurey to find for all students the marks which are immediately greater than the student’s marks . The output should have 1 column ‘Next’ and should contain the marks which are immediately greater than the student’s marks for each student which are Sorted by their Name.

Table : ‘Students’



NOTE : The output should have 1 column ‘Next’ and should contain the marks which are immediately greater than the student’s marks for each student which are Sorted by their Name. The one who got the heighest marks should have ‘NULL’ in its output .

Example : 



 ","select Name,Marks,
 lead(Marks) OVER (order by Marks) forward,
 lag(Marks) OVER (order by Marks) rewind
from Students"
Minimum GPA,https://www.interviewbit.com/problems/minimum-gpa/,N/A,SQL Programming,hard,"Given 2 tables ‘Students’ and ‘Departments’. Write an SQL query to find the students who has the Lowest GPA in each of the departments. 

Table: Students

Id:primary key



Table:Departments

DepartmentId of this table and DepartmentId of Students table are identical



NOTE : The output should contain one column by the name ‘A’ , which should contain DepartmentName , Name and GPA  all seperated by a comma. Also the output should be sorted by DepartmentName .

Example :
","select d.DepartmentName as Department,s.Name as Name,s.GPA as GPA 
from Students s
join Departments d
on s.DepartmentId = d.DepartmentId
where (s.DepartmentId, s.GPA) in(
select DepartmentId, min(GPA) as GPA
from Students
group BY DepartmentId
)
order by DepartmentName"
Number of offers,https://www.interviewbit.com/problems/number-of-offers/,N/A,SQL Programming,hard,"Given 2 tables ‘Students’ and ‘Jobs’, write an SQL query to find for every student the number of offers they got in the month of November. The output should contain 1 coloumn by the name ‘Job_Offers’ which should contain the number of jobs received by each of the student in the month of November. Also it should be sorted by the Id of the students.

Table:Students

Id: primary key



 

Table: Jobs

Id of this table and Id of Students table are identical



NOTE : The output should contain one column ‘Job_Offers’ .

Example :
","select sum(if(month(Date) = '11', 1, 0)) as Job_Offers
from Students s
left join Jobs j on j.Id = s.Id
group by s.Id
order by s.Id;"
Common Elements,https://www.interviewbit.com/problems/common-elements/,N/A,Hashing,easy,"Problem Description
 
 

Given two integer arrays, A and B of size N and M, respectively. Your task is to find all the common elements in both the array.

 

NOTE:

 

Each element in the result should appear as many times as it appears in both arrays.
The result can be in any order.


Problem Constraints
1 <= N, M <= 105

1 <= A[i] <= 109



Input Format
First argument is an integer array A of size N.

Second argument is an integer array B of size M.



Output Format
Return an integer array denoting the common elements.



Example Input
Input 1:

 A = [1, 2, 2, 1]
 B = [2, 3, 1, 2]
Input 2:

 A = [2, 1, 4, 10]
 B = [3, 6, 2, 10, 10]


Example Output
Output 1:

 [1, 2, 2]
Output 2:

 [2, 10]


Example Explanation
Explanation 1:

 Elements (1, 2, 2) appears in both the array. Note 2 appears twice in both the array.
Explantion 2:

 Elements (2, 10) appears in both the array.
","vector<int> Solution::solve(vector<int> &A, vector<int> &B) {
    int n = A.size(), m = B.size();
    unordered_map<int,int> hashmap;
    for(int i = 0 ; i < n; i++){
        hashmap[A[i]] ++;
        assert(A[i] >= 1 && A[i] <= 1e9);
    }
    vector<int> ans;
    for(int i = 0; i < m; i++){
        if(hashmap.find(B[i]) != hashmap.end() && hashmap[B[i]] != 0){
            ans.push_back(B[i]);
            hashmap[B[i]]--;
        }
    }
    return ans;
}"
Exploring the farmer's market,https://www.interviewbit.com/problems/exploring-the-farmer-s-market/,N/A,SQL Programming,medium,"Raw Problem
 

?? [DISCLAIMER!] - This is an exploratory problem and there is no right answer to this question. Please ignore the Wrong Answer prompt in the output.

Put yourself into the shoes of a Data Analyst working for Amazon Fresh Stores. You can play around with this database to explore how a Farmer’s Market(Mandi) operates and help the Market Manager with insights to drive business ahead.</p>



Click here to open the image.
",N/A
Distinct Numbers,https://www.interviewbit.com/problems/distinct-numbers/,N/A,Hashing,easy,"Problem Description
 
 

You are given an array of integers A having D distinct numbers. There is an operation that you can apply any number of times on the A.

In one operation, you can do A[i] = A[i] ? X; where X can be any integer and ? is a XOR operation.

Return the minimum number of such operations required to modify A in such a way that it only contains at most B distinct numbers.


Problem Constraints
1 <= |A| <= 105

0 <= A[i] <= 109

1 <= K <= 105


Input Format
First argument is an array of integers A
Second argument is an integer B


Output Format
Return an integer denoting the minimum number of operations


Example Input
Input 1:
A = [1, 2, 3]
B = 2
Input 2:
A = [1, 2, 2]
B = 2


Example Output
Output 1:
1
Output 2:
0


Example Explanation
For Input 1:
A[0] ? 2 = 1 ? 2 = 3
A = [3, 2, 3]
So, Minimum operations = 1
For Input 2:
No operation is required","int Solution::solve(vector<int> &A, int B){
    int N = A.size();

    // Assert statements Begin
    assert(1 <= N and N <= 1e5);
    for(auto &x: A){
        assert(0 <= x and x <= 1e9);
    }
    assert(1 <= B and B <= 1e5);
    // Assert statements End

    map<int, int> mp;
    for(auto &x: A){
        mp[x] += 1;
    }
    if(mp.size() <= B){
        return 0;
    }
    vector<int> v;
    for(auto &x: mp){
        v.push_back(x.second);
    }
    sort(v.begin(), v.end(), greater<int>());
    int sum = 0;
    for(int i = B; i < v.size(); i++){
        sum += v[i];
    }
    return sum;
}"
Maxed Arrays,https://www.interviewbit.com/problems/maxed-arrays/,N/A,Stacks And Queues,medium,"Problem Description
 
 

An array of integers X of length N is called Maxed with respect to a particular element K inside it if:
3 <= N
If the index of the element K is i, then 1 < i < N
max(X[1], … , X[i]) ? max(X[2], … , X[i])
max(X[i], … , X[N]) ? max(X[i], … , X[N-1])
Given an array A of integers, for each element in A from index 1 to |A|, you need to find the sum of the length of all the subarrays of A that are Maxed with respect to each of these elements. Output is an array B where B[i] denotes the sum of the length of all the Maxed subarrays with respect to A[i].


Problem Constraints
1 <= |A| <= 105

0 <= A[i] <= 109


Input Format
The first argument is an integer array A.


Output Format
Return an integer array, the answer for each element in A.


Example Input
Input 1:
A = [0, 2, 1]
Input 2:
A = [5, 3, 2, 5, 7]


Example Output
Output 1:
[0, 0, 0]
Output 2:
[0, 9, 16, 0, 0]


Example Explanation
For Input 1:
There is no subarray for the 0th element because it would always be the first element in each subarray.
For the 1st element, there is only the subarray [0, 2, 1] which satisfies the first 2 conditions. But it doesn’t satisfy the 2nd condition as max(0, 2) = max(2).
There is no subarray for 2nd element because it would always be the last element in each subarray.
For Input 2:
There is no subarray for the 0th element because it would always be the first element in each subarray.
The 2 subarrays that satisfy the conditions for the 1st element are [5, 3, 2, 5] and [5, 3, 2, 5, 7]. The sum of lengths is 4 + 5 = 9.
A total of 4 subarrays satisfy the conditions for the 2nd element - [5, 3, 2, 5], [5, 3, 2, 5, 7], [3, 2, 5, 7] and [3, 2, 5]. Sum = 3 + 4 + 4 + 5 = 16.
No subarray satisfies the conditions for the 3rd and 4th elements.
","vector<long long> Solution::solve(vector<int> &A) {
    int n=A.size();
    vector<pair<long,int>> pre(n,{0,0});
    vector<pair<long,int>> post(n,{0,0});
    stack<int> pres;
    stack<int> posts;
    long preSum=0;
    long postSum=0;
    for(int i=0;i<n;i++){
        while(!pres.empty()&&A[pres.top()]<=A[i]){
            preSum-=pres.top();
            pres.pop();
        }
        pre[i].first=preSum;
        pre[i].second=pres.size();
        pres.push(i);
        preSum+=i;
        int idx=n-1-i;
        while(!posts.empty()&&A[posts.top()]<=A[idx]){
            postSum-=posts.top();
            posts.pop();
        }
        post[idx].first=postSum;
        post[idx].second=posts.size();
        posts.push(idx);
        postSum+=idx;
    }
    vector<long long int> ret(n,0);
    for(int i=0;i<n;i++){
        ret[i]=post[i].first*pre[i].second-\
            pre[i].first*post[i].second+\
            pre[i].second*post[i].second;
    }
    return ret;
}"
Compact Scientific Notation,https://www.interviewbit.com/problems/compact-scientific-notation/,N/A,Strings,hard,"Problem Description
 
 

You are presented with a positive decimal number, denoted as 'x.' Your objective is to convert it into ""simple exponential notation.""


In this notation, if x?=?a·10b, where 1???a?<?10, the representation takes the form ""aEb."" If b equals zero, the ""Eb"" part should be omitted. When 'a' is an integer, it must be written without a decimal point. Additionally, there should be no extraneous zeroes in 'a' and 'b.'


Problem Constraints
The length of the number will not exceed 106.


Input Format
The first argument is the positive decimal number X.


Output Format

Return the ""simple exponential notation"" of the given number X.


Example Input
Input 1:
.100
Input 2:
16


Example Output
Output 1:

1E-1
Output 2:
1.6E1


Example Explanation
For Input 1:
The given decimal number is 0.1. This is represented as ""1E-1"" in compact scientific notation since it can be expressed as 1 multiplied by 10 to the power of -1.
For Input 2:
The provided decimal number is 16. In compact scientific notation, this is represented as ""1.6E1"" as it can be expressed as 1.6 multiplied by 10 to the power of 1.","string Solution::solve(string s) {
  int l = s.size();
    //  assert(l >= 1 && l <= 1000000);
    
     int k = l, a, b;
     int p = l - 1;
      
     while (s[p] == '0') p--;
     l = p + 1;
     for (int i = 0; i < l; i++) {
       if (s[i] == '.') {
         k = i;
         break;
       }
     }
      
     p = l - 1;
     while (s[p] == '0' || s[p] == '.') p--;
      
      
     l = p + 1;
     p = 0;
     while (s[p] == '0' || s[p] == '.') p++;
      
     if (p < k)
       b = k - p - 1;
     else
       b = k - p;
        
        
     string result = """";
     result += s[p];
     int flag = 0;
      
     for (int i = p + 1; i < l; i++)
       if (s[i] == '.')
         continue;
       else if (!flag) {
         result += '.';
         result += s[i];
         flag = 1;
       } else
         result += s[i];
          
     if (b != 0)
       result += ('E' + to_string(b));
        
     return result;
}"
Parity-Swapping Integer Minimization,https://www.interviewbit.com/problems/parity-swapping-integer-minimization/,N/A,Greedy Algorithm,medium,"Problem Description
 
 

Given a non-negative integer consisting of n digits, you can perform any number of swaps between adjacent digits if the swapped digits have different parities. Find the minimum integer you can obtain after completing any number of swaps.


Problem Constraints
1 ? n ? 3 × 105


Input Format
The first argument is a number.


Output Format
Return the minimum integer you can obtain after performing any number of swaps.


Example Input
Input 1: 
0709
Input 2:
246432


Example Output
Output 1:

0079
Output 2:

234642


Example Explanation
For Input 1:

You can perform the following sequence of operations: 0709 ? 0079.

For Input 2:
You can perform the following sequence of operations: 246432 ? 246342 ? 243642 ? 234642
","string Solution::solve(string s) {
    int l = s.size();
    // assert(l >= 1 && l <= 300000);
    
    string even_digits, odd_digits;
    for (char digit : s) {
        if ((digit - '0') % 2 == 0) {
            even_digits.push_back(digit);
        } else {
            odd_digits.push_back(digit);
        }
    }
    
    reverse(even_digits.begin(), even_digits.end());
    reverse(odd_digits.begin(), odd_digits.end());
    
    string result = """";
    while (!even_digits.empty() || !odd_digits.empty()) {
        if (even_digits.empty()) {
            result += odd_digits.back();
            odd_digits.pop_back();
            continue;
        }
        if (odd_digits.empty()) {
            result += even_digits.back();
            even_digits.pop_back();
            continue;
        }
    
        if (even_digits.back() < odd_digits.back()) {
            result += even_digits.back();
            even_digits.pop_back();
        } else {
            result += odd_digits.back();
            odd_digits.pop_back();
        }
    }
    
    return result;
    
}"
Binary String Cleanup Challenge,https://www.interviewbit.com/problems/binary-string-cleanup-challenge/,N/A,Strings,easy,"Problem Description
 
 

Ryan was tidying up his house for the party when he stumbled upon a messy string hidden under the carpets. Eager to clean it up in a precise and stylish manner, he decided to make it as clean as possible using a specific set of moves.

The string, denoted as s, is a binary string of length n, consisting solely of 0s and 1s. Ryan can perform a move by selecting two consecutive characters si and si+1. If si is 1 and si+1 is 0, he can erase exactly one of them. The string shrinks after each erasure.

Ryan can make an arbitrary number of moves (possibly zero) and aims to create the cleanest possible string. He defines cleanliness such that for two different strings x and y, the shorter string is considered cleaner. If the lengths are the same, the lexicographically smaller string is cleaner.

Your task is to print the cleanest possible string that Ryan can obtain by performing some number of moves.


Problem Constraints
1 =< n <= 105


Input Format
The first argument is the string.


Output Format
Return the cleanest string Ryan can achieve after performing some number of moves (possibly zero).


Example Input
Input 1:
10
0001111111
Input 2:
4
0101


Example Output
Output 1:
0001111111
Output 2:
001


Example Explanation
For Input 1:
Ryan can't perform any moves.

For Input 2:
Ryan should erase s2.
","string Solution::solve(string s) {

    assert(s.length() >= 1 && s.length() <= 100000); 

    int n = s.length();
    bool nonDecreasing = true;

    for (int i = 1; i < n; i++) {
        if (s[i] < s[i - 1]) {
            nonDecreasing = false;
            break;
        }
    }

    if (nonDecreasing) {
        return s;
    }

    int leadingZeroes = 0;
    for (int i = 0; i < n; i++) {
        if (s[i] == '1') {
            break;
        }
        leadingZeroes++;
    }

    int trailingOnes = 0;
    for (int i = n - 1; i >= 0; i--) {
        if (s[i] == '0') {
            break;
        }
        trailingOnes++;
    }

    string result;
    for (int i = 0; i < leadingZeroes + 1; i++) {
        result += '0';
    }

    for (int i = 0; i < trailingOnes; i++) {
        result += '1';
    }

    return result;
    
}"
L++ Expression Validity Analyzer,https://www.interviewbit.com/problems/l-expression-validity-analyzer/,N/A,Stacks And Queues,easy,"Problem Description
 
 

Elena, now deeply engrossed in her exploration of compiler development, has encountered a fascinating challenge related to her new language, L++.

In this linguistic puzzle, she's dealing with abstract instructions represented by the characters ""<"" and "">,"" which serve as a shorthand for generating XML code tags in L++.

The rule she's uncovered is that for an expression to be valid, every ""<"" symbol must be followed, at some point (though not necessarily immediately), by a corresponding "">"" symbol. Additionally, each "">"" symbol should correspond to exactly one ""<"" symbol.

To illustrate, expressions like ""<<>>,"" ""<>,"" and ""<><>"" are considered valid, while expressions like "">>,"" and ""><><"" are not.

Elena needs your help in analyzing a set of expressions provided as input to determine the length of the longest prefix that adheres to these rules. If no valid prefix exists, the output should be 0.


Problem Constraints
1 ? The length of a single expression ? 106


Input Format
The first argument is the expression.


Output Format
Return the length of the longest valid prefix or 0 if there's no such valid prefix.


Example Input
Input 1:
<<>>
Input 2:
><
Input 3:
<>>>


Example Output
Output 1:
4
Output 2:
0
Output 3:
2


Example Explanation
For Input 1:
The entire expression <<>> is valid. There are two '<' symbols and two '>' symbols, and each '<' symbol corresponds to exactly one '>'. Therefore, the length of the longest valid prefix is 4.

For Input 2:
The expression >< is not valid. There is one '<' symbol, but there is no corresponding '>' symbol. Therefore, the length of the longest valid prefix is 0.

For Input 3:
The expression <>>> is not valid. The longest valid prefix is <> which has a length of 2.
","int Solution::solve(string s) {
    int l = s.size();
    assert(l >= 1 && l <= 100000);
    
    stack<char> stack;
    int count = 0;

    for (int i = 0; i < s.length(); i++) {
        if (s[i] == '<') {
            stack.push(s[i]);
        } else if (s[i] == '>' && !stack.empty() && stack.top() == '<') {
            stack.pop();
        }

        if (stack.empty()) {
            count = i + 1;
        }
    }

    return count;
    
}"
Bead Challenge,https://www.interviewbit.com/problems/bead-challenge/,N/A,Time Complexity,easy,"Problem Description
 
 

You possess a vector A of size N, where Ai denotes the weight of the i-th bead among n beads on a table. Engaging in a competition against a machine, you have the liberty to select any two beads, keeping one for yourself (Ai) and surrendering the other to the machine (Aj). If you choose to retain Ai, you can partition its weight into k beads of equal weight (resulting in a new weight of Ai/k for the i-th bead). However, you must keep one of these new beads and discard the remaining k-1 beads. Subsequently, the machine will amplify the weight of the j-th bead (initially Aj) to k times its original weight (kAj). The objective is to achieve equal weights for all beads through a series of operations. Return 1 if successful or 0 if unsuccessful in this challenge.


Problem Constraints
2 <= |A| <= 105

1 <= Ai <= 106


Input Format
The first and only argument is array of integers A.


Output Format
Return 1 if you successfully achieve equal weights for all N beads; otherwise, return 0.


Example Input
Input 1:
A = [2, 3, 1]
Input 2:
A = [100, 2, 50, 10, 1]


Example Output
Output 1:
0
Output 2:
1


Example Explanation*
For Input 1:
We can never make all beads of equal size.
For Input 2:
Let's examine the vector A, which is [100, 2, 50, 10, 1], containing 5 elements. Two operations are performed on it:

Select a3 (which is 50) and a2 (which is 2), with k as 5. Replace a3 with a3 / k, resulting in 10, and replace a2 with a2 * k, resulting in 10. The modified array is now [100, 10, 10, 10, 1].

Choose a1 (which is 100) and a5 (which is 1), with k as 10. Replace a1 with a1 / k, resulting in 10, and replace a5 with a5 * k, resulting in 10. The final array is [10, 10, 10, 10, 10].
","void add_divs(int x, map<int, int>&divs){
    int i = 2;
    while(i * i <= x){
        while (x % i == 0){
            divs[i]++;
            x /= i;
        }
        i++;
    }
    if(x > 1) divs[x]++;
}
int Solution::solve(vector<int> &A) {
    map<int, int> divs;
    int n = A.size();
    assert(n >= 2 && n <= 100000);
    for(int i = 0; i < n; i++) {
        assert(A[i] >= 1 && A[i] <= 1000000);
        add_divs(A[i], divs);
    }
    for(auto e: divs){
        if(e.second % n != 0) return 0;
    }
    return 1;
}"
X-Permutations,https://www.interviewbit.com/problems/x-permutations/,N/A,Math,hard,"Problem Description
 
 

Given an integer A, an array Z of integers of size A contains all the numbers from 1 to A. Now there can be many different permutations of this array. For a particular X, if Zi = i for exactly X different i from 1 to A, the permutation is called X-Permutation. For each X from 0 to A, find the number of X-Permutations for each X modulo 1000000007.


Problem Constraints
1 <= A <= 105


Input Format
The first argument is an integer A.


Output Format
Return an integer array of size A+1 where each element is the number of X-Permutations.


Example Input
Input 1:
A = 3
Input 2:
A = 1


Example Output
Output 1:
[2, 3, 0, 1]
Output 2:
[0, 1]


Example Explanation
For Input 1:
For X=0, permutations [3, 1, 2] and [2, 3, 1] satisfy.
For X=1, permutations [1, 3, 2], [2, 1, 3], and [3, 2, 1] satisfy.
For X=2, no permutation satisfies.
For X=3, permutation [1, 2, 3] satisfies.
For Input 2:
For X=0, no permutation satisfies.
For X=1, permutation [1] satisfies.
","const long mod = 1000000007;
long f[100005], fin[100005];

long fast_pow(long a, long p) {
    long res = 1;
    while (p) {
        if (p % 2 == 0) {
            a = (a * a) % mod;
            p /= 2;
        } else {
            res = (res * a) % mod;
            p--;
        }
    }
    return res;
}

void calc() {
    f[0] = 1;
    for (long i = 1; i <= 100000; i++) {
        f[i] = (f[i - 1] * i) % mod;
    }
    fin[100000] = fast_pow(f[100000], mod - 2);
    for (long i = 100000; i > 0; i--) {
        fin[i - 1] = (fin[i] * i) % mod;
    }
}

long nCr(long n, long r) {
    if (r > n) {
        return 0;
    }
    return (((f[n] * fin[r]) % mod) * fin[n - r]) % mod;
}

int z = 0;
vector<int> Solution::solve(int A) {
    assert(A >= 1 && A <= 1e5);
    if (!z) {
        calc();
        z = 1;
    }
    vector<int> ans(A + 1);
    long x = 0;
    ans[A] = 1;
    for (int i = A - 1; i >= 0; i--) {
        ans[i] = (((nCr(A, i) * f[A - i]) % mod) * x) % mod;
        if ((A - i) % 2) {
            x = (x + fin[A - i + 1]) % mod;
        } else {
            x = (x - fin[A - i + 1] + mod) % mod;
        }
    }
    return ans;
}"
Buy Water Balloons,https://www.interviewbit.com/problems/buy-water-balloons/,N/A,Dynamic Programming,medium,"Problem Description
 
 

As Holi is coming, Karan wants to buy some water balloons to prepare for it. He visits a shopkeeper who has N different types of balloons. Each type of balloon has a price denoted by array A. 

The shopkeeper has an offer where Karan can buy at most B balloons at the price of one. The price of these B or less balloons would be equal to the price of the maximum-priced balloon. Karan wants to buy only one balloon of each type. He has an amount equal to C, so he can’t spend more amount than C. What is the maximum number of balloons he can buy?


Problem Constraints
1 <= |A| <= 105

1 <= A[i] <= 104

1 <= B <= |A|

1 <= C <= 109


Input Format
The first argument is an integer array A.
The second argument is an integer B.
The third argument is an integer C.


Output Format
Return an integer, the answer to the problem.


Example Input
Input 1:
A = [2, 4, 5, 3, 7]
B = 2
C = 6
Input 2:
A = [1]
B = 1
C = 1


Example Output
Output 1:
3
Output 2:
1


Example Explanation
For Input 1:
First, Karan can buy type 2 and type 4 at the price of 4 as type 2 has the maximum price. Then he buys the type 1 alone at the price of 2. He spends a total amount of 6 buying 3 balloons.
For Input 2:
He buys type 1 at price 1.
","int Solution::solve(vector<int> &A, int B, int C) {
    sort(A.begin(),A.end());
    int n = A.size();
    vector<int> dp(n,0);
    
    for(int j=n-1;j>=0;j--){
        int x = C;
        for(int i=j;i>=0 && x>0;){
        if(A[i]<=x){
            dp[j] += (i + 1 >= B) ? B : i + 1;
            x -= A[i];
            i -= B;
        }else{
            if(i==j){
                break;
            }
            i--;
        }
        
    }
    }
    return *max_element(dp.begin(),dp.end());
}"
GP Triplets,https://www.interviewbit.com/problems/gp-triplets/,N/A,Math,easy,"Problem Description
 
 

Given an array of integers A, find the number of triplets (i, j, k) such that the sequence A[i], A[j], A[k] form a non-decreasing Geometric Progression.


Problem Constraints
1 <= |A| <= 105

1 <= A[i] <= 109


Input Format
The first argument is an integer array A.


Output Format
Return an integer, the answer to the problem.


Example Input
Input 1:
A = [2, 8, 4, 1]
Input 2:
A = [2, 2, 4, 2]


Example Output
Output 1:
2
Output 2:
6


Example Explanation
For Input 1:
The triplets {4, 1, 3}, {1, 3, 2} form a GP.
For Input 2:
All the permutations of {1, 2, 4} form a GP.
","int Solution::solve(vector<int> &A) {
    int n = A.size();
    assert(n >= 1 && n <= 1000);

    map<int, int> m;
    for (int i = 0; i < n; i++) {
        assert(A[i] >= 1 && A[i] <= 1e9);
        m[A[i]]++;
    }

    int ans = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (i == j)
                continue;
            if (A[j] % A[i])
                continue;
            int r = A[j] / A[i];
            if (r == 1)
                ans += m[A[i]] - 2;
            else {
                if (r <= 1000000000 / A[j])
                    ans += m[A[j] * r];
            }
        }
    }
    return ans;
}"
GP Triplets QXSsA,https://www.interviewbit.com/problems/gp-triplets-qxssa/,N/A,Math,easy,"Problem Description
 
 

Given an array of integers A, find the number of triplets (i, j, k) such that the sequence A[i], A[j], A[k] form a non-decreasing Geometric Progression.


Problem Constraints
1 <= |A| <= 103

1 <= A[i] <= 109


Input Format
The first argument is an integer array A.


Output Format
Return an integer, the answer to the problem.


Example Input
Input 1:
A = [2, 8, 4, 1]
Input 2:
A = [2, 2, 4, 2]


Example Output
Output 1:
2
Output 2:
6


Example Explanation
For Input 1:
The triplets {4, 1, 3}, {1, 3, 2} form a GP.
For Input 2:
All the permutations of {1, 2, 4} form a GP.
","int Solution::solve(vector<int> &A) 
{
    sort (A.begin(), A.end());
    
    int count = 0;
    for (int i = 0; i < A.size(); i++)
    {
        for (int j = i + 1; j < A.size(); j++)
        {
            for (int k = j + 1; k < A.size(); k++)
            {
                if (A[i] == A[j] && A[j] == A[k])
                {
                    count += 6; // 3! permutation if all are equal.
                }
                else if (A[k]*1ll*A[i] == A[j]*1ll*A[j] && 
                         A[j]%A[i] == 0 &&
                         A[k]%A[j] == 0)
                {
                    count++;
                } 
            }
        }
    }
    
    return count;
}
"
